# 0 ".qccziynBy/rising.c"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdc-predef.h" 1 3
# 0 "<command-line>" 2
# 1 ".qccziynBy/rising.c"
# 0 "rising-cpp.c"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdc-predef.h"
# 0 "<command-line>"
# 1 "rising-cpp.c"





# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/lib/gcc/x86_64-mk-linux/11.2.0/include/stdint.h" 1 3 4
# 9 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/lib/gcc/x86_64-mk-linux/11.2.0/include/stdint.h" 3 4
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdint.h" 1 3 4
# 26 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdint.h" 3 4
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/libc-header-start.h" 1 3 4
# 33 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/libc-header-start.h" 3 4
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/features.h" 1 3 4
# 473 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/features.h" 3 4
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/sys/cdefs.h" 1 3 4
# 462 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/sys/cdefs.h" 3 4
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/wordsize.h" 1 3 4
# 463 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/sys/cdefs.h" 2 3 4
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/long-double.h" 1 3 4
# 464 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/sys/cdefs.h" 2 3 4
# 474 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/features.h" 2 3 4
# 497 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/features.h" 3 4
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/gnu/stubs.h" 1 3 4
# 10 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/gnu/stubs.h" 3 4
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/gnu/stubs-64.h" 1 3 4
# 11 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/gnu/stubs.h" 2 3 4
# 498 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/features.h" 2 3 4
# 34 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/libc-header-start.h" 2 3 4
# 27 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdint.h" 2 3 4
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types.h" 1 3 4
# 27 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types.h" 3 4
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/wordsize.h" 1 3 4
# 28 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types.h" 2 3 4
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/timesize.h" 1 3 4
# 29 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types.h" 2 3 4



# 31 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types.h" 3 4
typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;






typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;



typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 141 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types.h" 3 4
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/typesizes.h" 1 3 4
# 142 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types.h" 2 3 4
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/time64.h" 1 3 4
# 143 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;
typedef long int __suseconds64_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 28 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdint.h" 2 3 4
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/wchar.h" 1 3 4
# 29 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdint.h" 2 3 4
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/wordsize.h" 1 3 4
# 30 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdint.h" 2 3 4




# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/stdint-intn.h" 1 3 4
# 24 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 35 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdint.h" 2 3 4


# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/stdint-uintn.h" 1 3 4
# 24 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/stdint-uintn.h" 3 4
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
# 38 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdint.h" 2 3 4





typedef __int_least8_t int_least8_t;
typedef __int_least16_t int_least16_t;
typedef __int_least32_t int_least32_t;
typedef __int_least64_t int_least64_t;


typedef __uint_least8_t uint_least8_t;
typedef __uint_least16_t uint_least16_t;
typedef __uint_least32_t uint_least32_t;
typedef __uint_least64_t uint_least64_t;





typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 71 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 87 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
# 101 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdint.h" 3 4
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
# 10 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/lib/gcc/x86_64-mk-linux/11.2.0/include/stdint.h" 2 3 4
# 7 "rising-cpp.c" 2
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/string.h" 1 3
# 26 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/string.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/libc-header-start.h" 1 3
# 27 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/string.h" 2 3






# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/lib/gcc/x86_64-mk-linux/11.2.0/include/stddef.h" 1 3 4
# 209 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/lib/gcc/x86_64-mk-linux/11.2.0/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 34 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/string.h" 2 3
# 43 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/string.h" 3
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
    __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__access__ (__write_only__, 1, 4)));




extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 91 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/string.h" 3
extern void *memchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 104 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/string.h" 3
extern void *rawmemchr (const void *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 117 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/string.h" 3
extern void *memrchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)))
      __attribute__ ((__access__ (__read_only__, 1, 3)));





extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
    __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) __attribute__ ((__access__ (__write_only__, 1, 3)));



# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/locale_t.h" 1 3
# 22 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/locale_t.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/__locale_t.h" 1 3
# 28 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/__locale_t.h" 3
struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/locale_t.h" 2 3

typedef __locale_t locale_t;
# 157 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/string.h" 2 3


extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    locale_t __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)))
     __attribute__ ((__access__ (__write_only__, 1, 3)));





extern char *strdup (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 230 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/string.h" 3
extern char *strchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 257 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/string.h" 3
extern char *strrchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 270 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/string.h" 3
extern char *strchrnul (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strcspn (const char *__s, const char *__reject)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 307 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/string.h" 3
extern char *strpbrk (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 334 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/string.h" 3
extern char *strstr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 364 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/string.h" 3
extern char *strcasestr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));







extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)))
    __attribute__ ((__access__ (__read_only__, 1, 2)))
    __attribute__ ((__access__ (__read_only__, 3, 4)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern size_t strlen (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern size_t strnlen (const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern char *strerror (int __errnum) __attribute__ ((__nothrow__ , __leaf__));
# 428 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/string.h" 3
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) __attribute__ ((__access__ (__write_only__, 2, 3)));




extern const char *strerrordesc_np (int __err) __attribute__ ((__nothrow__ , __leaf__));

extern const char *strerrorname_np (int __err) __attribute__ ((__nothrow__ , __leaf__));





extern char *strerror_l (int __errnum, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));



# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/strings.h" 1 3
# 23 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/strings.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/lib/gcc/x86_64-mk-linux/11.2.0/include/stddef.h" 1 3 4
# 24 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/strings.h" 2 3










extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bcopy (const void *__src, void *__dest, size_t __n)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 68 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/strings.h" 3
extern char *index (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 96 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/strings.h" 3
extern char *rindex (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern int ffs (int __i) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int ffsl (long int __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern int strcasecmp_l (const char *__s1, const char *__s2, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));



extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));



# 447 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/string.h" 2 3



extern void explicit_bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)))
    __attribute__ ((__access__ (__write_only__, 1, 2)));



extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));



extern const char *sigabbrev_np (int __sig) __attribute__ ((__nothrow__ , __leaf__));


extern const char *sigdescr_np (int __sig) __attribute__ ((__nothrow__ , __leaf__));



extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)))
    __attribute__ ((__access__ (__write_only__, 1, 2)));
# 511 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/string.h" 3
extern char *basename (const char *__filename) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 523 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/string.h" 3

# 8 "rising-cpp.c" 2
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/fenv.h" 1 3
# 26 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/fenv.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/libc-header-start.h" 1 3
# 27 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/fenv.h" 2 3
# 64 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/fenv.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/fenv.h" 1 3
# 24 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/fenv.h" 3
enum
  {
    FE_INVALID =

      0x01,
    __FE_DENORM = 0x02,
    FE_DIVBYZERO =

      0x04,
    FE_OVERFLOW =

      0x08,
    FE_UNDERFLOW =

      0x10,
    FE_INEXACT =

      0x20
  };







enum
  {
    FE_TONEAREST =

      0,
    FE_DOWNWARD =

      0x400,
    FE_UPWARD =

      0x800,
    FE_TOWARDZERO =

      0xc00
  };



typedef unsigned short int fexcept_t;






typedef struct
  {
    unsigned short int __control_word;
    unsigned short int __glibc_reserved1;
    unsigned short int __status_word;
    unsigned short int __glibc_reserved2;
    unsigned short int __tags;
    unsigned short int __glibc_reserved3;
    unsigned int __eip;
    unsigned short int __cs_selector;
    unsigned int __opcode:11;
    unsigned int __glibc_reserved4:5;
    unsigned int __data_offset;
    unsigned short int __data_selector;
    unsigned short int __glibc_reserved5;

    unsigned int __mxcsr;

  }
fenv_t;
# 106 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/fenv.h" 3
typedef struct
  {
    unsigned short int __control_word;
    unsigned short int __glibc_reserved;
    unsigned int __mxcsr;
  }
femode_t;
# 65 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/fenv.h" 2 3






extern int feclearexcept (int __excepts) __attribute__ ((__nothrow__ , __leaf__));



extern int fegetexceptflag (fexcept_t *__flagp, int __excepts) __attribute__ ((__nothrow__ , __leaf__));


extern int feraiseexcept (int __excepts) __attribute__ ((__nothrow__ , __leaf__));




extern int fesetexcept (int __excepts) __attribute__ ((__nothrow__ , __leaf__));




extern int fesetexceptflag (const fexcept_t *__flagp, int __excepts) __attribute__ ((__nothrow__ , __leaf__));



extern int fetestexcept (int __excepts) __attribute__ ((__nothrow__ , __leaf__));




extern int fetestexceptflag (const fexcept_t *__flagp, int __excepts) __attribute__ ((__nothrow__ , __leaf__));






extern int fegetround (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));


extern int fesetround (int __rounding_direction) __attribute__ ((__nothrow__ , __leaf__));






extern int fegetenv (fenv_t *__envp) __attribute__ ((__nothrow__ , __leaf__));




extern int feholdexcept (fenv_t *__envp) __attribute__ ((__nothrow__ , __leaf__));



extern int fesetenv (const fenv_t *__envp) __attribute__ ((__nothrow__ , __leaf__));




extern int feupdateenv (const fenv_t *__envp) __attribute__ ((__nothrow__ , __leaf__));







extern int fegetmode (femode_t *__modep) __attribute__ ((__nothrow__ , __leaf__));



extern int fesetmode (const femode_t *__modep) __attribute__ ((__nothrow__ , __leaf__));
# 157 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/fenv.h" 3
extern int feenableexcept (int __excepts) __attribute__ ((__nothrow__ , __leaf__));




extern int fedisableexcept (int __excepts) __attribute__ ((__nothrow__ , __leaf__));


extern int fegetexcept (void) __attribute__ ((__nothrow__ , __leaf__));



# 9 "rising-cpp.c" 2
# 1 "/root/mnt/basilisk/src/common.h"
# 1 "/root/mnt/basilisk/src/ast/std/stdlib.h"
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdlib.h" 1 3
# 25 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdlib.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/libc-header-start.h" 1 3
# 26 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdlib.h" 2 3





# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/lib/gcc/x86_64-mk-linux/11.2.0/include/stddef.h" 1 3 4
# 321 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/lib/gcc/x86_64-mk-linux/11.2.0/include/stddef.h" 3 4
typedef int wchar_t;
# 32 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdlib.h" 2 3







# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/waitflags.h" 1 3
# 40 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdlib.h" 2 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/waitstatus.h" 1 3
# 41 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdlib.h" 2 3
# 55 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdlib.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/floatn.h" 1 3
# 119 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/floatn.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/floatn-common.h" 1 3
# 24 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/floatn-common.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/long-double.h" 1 3
# 25 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/floatn-common.h" 2 3
# 120 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/floatn.h" 2 3
# 56 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdlib.h" 2 3


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;





__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 97 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdlib.h" 3
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__ , __leaf__)) ;



extern double atof (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



__extension__ extern long long int atoll (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 140 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdlib.h" 3
extern _Float32 strtof32 (const char *__restrict __nptr,
     char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern _Float64 strtof64 (const char *__restrict __nptr,
     char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern _Float128 strtof128 (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern _Float32x strtof32x (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern _Float64x strtof64x (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 176 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdlib.h" 3
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int strfromd (char *__dest, size_t __size, const char *__format,
       double __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));

extern int strfromf (char *__dest, size_t __size, const char *__format,
       float __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));

extern int strfroml (char *__dest, size_t __size, const char *__format,
       long double __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
# 232 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdlib.h" 3
extern int strfromf32 (char *__dest, size_t __size, const char * __format,
         _Float32 __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf64 (char *__dest, size_t __size, const char * __format,
         _Float64 __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf128 (char *__dest, size_t __size, const char * __format,
   _Float128 __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf32x (char *__dest, size_t __size, const char * __format,
   _Float32x __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf64x (char *__dest, size_t __size, const char * __format,
   _Float64x __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
# 274 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdlib.h" 3
extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     locale_t __loc) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));
# 316 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdlib.h" 3
extern _Float32 strtof32_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern _Float64 strtof64_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern _Float128 strtof128_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern _Float32x strtof32x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern _Float64x strtof64x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));
# 360 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdlib.h" 3
extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) atoi (const char *__nptr)
{
  return (int) strtol (__nptr, (char **) ((void *)0), 10);
}
extern __inline __attribute__ ((__gnu_inline__)) long int
__attribute__ ((__nothrow__ , __leaf__)) atol (const char *__nptr)
{
  return strtol (__nptr, (char **) ((void *)0), 10);
}


__extension__ extern __inline __attribute__ ((__gnu_inline__)) long long int
__attribute__ ((__nothrow__ , __leaf__)) atoll (const char *__nptr)
{
  return strtoll (__nptr, (char **) ((void *)0), 10);
}
# 385 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdlib.h" 3
extern char *l64a (long int __n) __attribute__ ((__nothrow__ , __leaf__)) ;


extern long int a64l (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/sys/types.h" 1 3
# 27 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/sys/types.h" 3






typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;


typedef __loff_t loff_t;




typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;





typedef __off_t off_t;






typedef __off64_t off64_t;




typedef __pid_t pid_t;





typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;




# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/clock_t.h" 1 3






typedef __clock_t clock_t;
# 127 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/sys/types.h" 2 3

# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/clockid_t.h" 1 3






typedef __clockid_t clockid_t;
# 129 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/sys/types.h" 2 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/time_t.h" 1 3






typedef __time_t time_t;
# 130 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/sys/types.h" 2 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/timer_t.h" 1 3






typedef __timer_t timer_t;
# 131 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/sys/types.h" 2 3



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/lib/gcc/x86_64-mk-linux/11.2.0/include/stddef.h" 1 3 4
# 145 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/sys/types.h" 2 3



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;







typedef __uint8_t u_int8_t;
typedef __uint16_t u_int16_t;
typedef __uint32_t u_int32_t;
typedef __uint64_t u_int64_t;


typedef int register_t __attribute__ ((__mode__ (__word__)));
# 176 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/sys/types.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/endian.h" 1 3
# 24 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/endian.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/endian.h" 1 3
# 35 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/endian.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/endianness.h" 1 3
# 36 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/endian.h" 2 3
# 25 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/endian.h" 2 3
# 35 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/endian.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/byteswap.h" 1 3
# 33 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/byteswap.h" 3
static __inline __uint16_t
__bswap_16 (__uint16_t __bsx)
{

  return __builtin_bswap16 (__bsx);



}






static __inline __uint32_t
__bswap_32 (__uint32_t __bsx)
{

  return __builtin_bswap32 (__bsx);



}
# 69 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/byteswap.h" 3
__extension__ static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{

  return __builtin_bswap64 (__bsx);



}
# 36 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/endian.h" 2 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/uintn-identity.h" 1 3
# 32 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/uintn-identity.h" 3
static __inline __uint16_t
__uint16_identity (__uint16_t __x)
{
  return __x;
}

static __inline __uint32_t
__uint32_identity (__uint32_t __x)
{
  return __x;
}

static __inline __uint64_t
__uint64_identity (__uint64_t __x)
{
  return __x;
}
# 37 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/endian.h" 2 3
# 177 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/sys/types.h" 2 3


# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/sys/select.h" 1 3
# 30 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/sys/select.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/select.h" 1 3
# 31 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/sys/select.h" 2 3


# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/sigset_t.h" 1 3



# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/__sigset_t.h" 1 3




typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
# 5 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/sigset_t.h" 2 3


typedef __sigset_t sigset_t;
# 34 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/sys/select.h" 2 3



# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/struct_timeval.h" 1 3







struct timeval
{
  __time_t tv_sec;
  __suseconds_t tv_usec;
};
# 38 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/sys/select.h" 2 3

# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/struct_timespec.h" 1 3
# 10 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/struct_timespec.h" 3
struct timespec
{
  __time_t tv_sec;



  __syscall_slong_t tv_nsec;
# 26 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/struct_timespec.h" 3
};
# 40 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/sys/select.h" 2 3
# 49 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/sys/select.h" 3
typedef long int __fd_mask;
# 59 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/sys/select.h" 3
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 91 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/sys/select.h" 3

# 101 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/sys/select.h" 3
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 113 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/sys/select.h" 3
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 126 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/sys/select.h" 3

# 180 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/sys/types.h" 2 3





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 219 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/sys/types.h" 3
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/pthreadtypes.h" 1 3
# 23 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/pthreadtypes.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/thread-shared-types.h" 1 3
# 44 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/thread-shared-types.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/pthreadtypes-arch.h" 1 3
# 21 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/pthreadtypes-arch.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/wordsize.h" 1 3
# 22 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/pthreadtypes-arch.h" 2 3
# 45 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/thread-shared-types.h" 2 3




typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;

typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;
# 74 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/thread-shared-types.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/struct_mutex.h" 1 3
# 22 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/struct_mutex.h" 3
struct __pthread_mutex_s
{
  int __lock;
  unsigned int __count;
  int __owner;

  unsigned int __nusers;



  int __kind;

  short __spins;
  short __elision;
  __pthread_list_t __list;
# 53 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/struct_mutex.h" 3
};
# 75 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/thread-shared-types.h" 2 3
# 87 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/thread-shared-types.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/struct_rwlock.h" 1 3
# 23 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/struct_rwlock.h" 3
struct __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;

  int __cur_writer;
  int __shared;
  signed char __rwelision;




  unsigned char __pad1[7];


  unsigned long int __pad2;


  unsigned int __flags;
# 55 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/struct_rwlock.h" 3
};
# 88 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/thread-shared-types.h" 2 3




struct __pthread_cond_s
{
  __extension__ union
  {
    __extension__ unsigned long long int __wseq;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __wseq32;
  };
  __extension__ union
  {
    __extension__ unsigned long long int __g1_start;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __g1_start32;
  };
  unsigned int __g_refs[2] ;
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
};

typedef unsigned int __tss_t;
typedef unsigned long int __thrd_t;

typedef struct
{
  int __data ;
} __once_flag;
# 24 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/pthreadtypes.h" 2 3



typedef unsigned long int pthread_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef union
{
  struct __pthread_mutex_s __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;


typedef union
{
  struct __pthread_cond_s __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;





typedef union
{
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 228 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/sys/types.h" 2 3



# 395 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdlib.h" 2 3






extern long int random (void) __attribute__ ((__nothrow__ , __leaf__));


extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern int rand (void) __attribute__ ((__nothrow__ , __leaf__));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));



extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__ , __leaf__));







extern double drand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) __attribute__ ((__nothrow__ , __leaf__));
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern void *malloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) ;

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (1, 2))) ;






extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__)) __attribute__ ((__alloc_size__ (2)));







extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__))
     __attribute__ ((__alloc_size__ (2, 3)));



extern void free (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));


# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/alloca.h" 1 3
# 24 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/alloca.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/lib/gcc/x86_64-mk-linux/11.2.0/include/stddef.h" 1 3 4
# 25 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/alloca.h" 2 3







extern void *alloca (size_t __size) __attribute__ ((__nothrow__ , __leaf__));






# 569 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdlib.h" 2 3





extern void *valloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (2))) ;



extern void abort (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int at_quick_exit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern void exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





extern void quick_exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





extern void _Exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));




extern char *getenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;




extern char *secure_getenv (const char *__name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) __attribute__ ((__nothrow__ , __leaf__));
# 675 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdlib.h" 3
extern char *mktemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 688 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdlib.h" 3
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 698 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdlib.h" 3
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 710 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdlib.h" 3
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 720 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdlib.h" 3
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 731 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdlib.h" 3
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 742 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdlib.h" 3
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 752 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdlib.h" 3
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 762 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdlib.h" 3
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 774 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdlib.h" 3
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 784 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdlib.h" 3
extern int system (const char *__command) ;





extern char *canonicalize_file_name (const char *__name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 800 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdlib.h" 3
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__ , __leaf__)) ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);




extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;


# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/stdlib-bsearch.h" 1 3
# 19 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/stdlib-bsearch.h" 3
extern __inline __attribute__ ((__gnu_inline__)) void *
bsearch (const void *__key, const void *__base, size_t __nmemb, size_t __size,
  __compar_fn_t __compar)
{
  size_t __l, __u, __idx;
  const void *__p;
  int __comparison;

  __l = 0;
  __u = __nmemb;
  while (__l < __u)
    {
      __idx = (__l + __u) / 2;
      __p = (void *) (((const char *) __base) + (__idx * __size));
      __comparison = (*__compar) (__key, __p);
      if (__comparison < 0)
 __u = __idx;
      else if (__comparison > 0)
 __l = __idx + 1;
      else
 return (void *) __p;
    }

  return ((void *)0);
}
# 826 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdlib.h" 2 3




extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern long int labs (long int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;


__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;






extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;


__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
# 872 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdlib.h" 3
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));





extern int mblen (const char *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__ , __leaf__));



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__))
    __attribute__ ((__access__ (__read_only__, 2)));

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__access__ (__write_only__, 1, 3))) __attribute__ ((__access__ (__read_only__, 2)));






extern int rpmatch (const char *__response) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 958 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdlib.h" 3
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3))) ;







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) __attribute__ ((__nothrow__ , __leaf__));



extern int unlockpt (int __fd) __attribute__ ((__nothrow__ , __leaf__));




extern char *ptsname (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) __attribute__ ((__access__ (__write_only__, 2, 3)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 1014 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdlib.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/stdlib-float.h" 1 3
# 24 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/stdlib-float.h" 3
extern __inline __attribute__ ((__gnu_inline__)) double
__attribute__ ((__nothrow__ , __leaf__)) atof (const char *__nptr)
{
  return strtod (__nptr, (char **) ((void *)0));
}
# 1015 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdlib.h" 2 3
# 1026 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdlib.h" 3

# 2 "/root/mnt/basilisk/src/ast/std/stdlib.h" 2
# 2 "/root/mnt/basilisk/src/common.h"
# 1 "/root/mnt/basilisk/src/ast/std/stdio.h"
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdio.h" 1 3
# 27 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdio.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/libc-header-start.h" 1 3
# 28 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdio.h" 2 3





# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/lib/gcc/x86_64-mk-linux/11.2.0/include/stddef.h" 1 3 4
# 34 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdio.h" 2 3


# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/lib/gcc/x86_64-mk-linux/11.2.0/include/stdarg.h" 1 3 4
# 40 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/lib/gcc/x86_64-mk-linux/11.2.0/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 37 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdio.h" 2 3


# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/__fpos_t.h" 1 3




# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/__mbstate_t.h" 1 3
# 13 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/__mbstate_t.h" 3
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 6 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/__fpos_t.h" 2 3




typedef struct _G_fpos_t
{
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
# 40 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdio.h" 2 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/__fpos64_t.h" 1 3
# 10 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/__fpos64_t.h" 3
typedef struct _G_fpos64_t
{
  __off64_t __pos;
  __mbstate_t __state;
} __fpos64_t;
# 41 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdio.h" 2 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/__FILE.h" 1 3



struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 42 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdio.h" 2 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/FILE.h" 1 3



struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 43 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdio.h" 2 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/struct_FILE.h" 1 3
# 35 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/struct_FILE.h" 3
struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;




typedef void _IO_lock_t;





struct _IO_FILE
{
  int _flags;


  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;


  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2;
  __off_t _old_offset;


  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;







  __off64_t _offset;

  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
# 44 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdio.h" 2 3


# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/cookie_io_functions_t.h" 1 3
# 27 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/cookie_io_functions_t.h" 3
typedef __ssize_t cookie_read_function_t (void *__cookie, char *__buf,
                                          size_t __nbytes);







typedef __ssize_t cookie_write_function_t (void *__cookie, const char *__buf,
                                           size_t __nbytes);







typedef int cookie_seek_function_t (void *__cookie, __off64_t *__pos, int __w);


typedef int cookie_close_function_t (void *__cookie);






typedef struct _IO_cookie_io_functions_t
{
  cookie_read_function_t *read;
  cookie_write_function_t *write;
  cookie_seek_function_t *seek;
  cookie_close_function_t *close;
} cookie_io_functions_t;
# 47 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdio.h" 2 3





typedef __gnuc_va_list va_list;
# 84 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdio.h" 3
typedef __fpos_t fpos_t;




typedef __fpos64_t fpos64_t;
# 133 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdio.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/stdio_lim.h" 1 3
# 134 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdio.h" 2 3



extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;






extern int remove (const char *__filename) __attribute__ ((__nothrow__ , __leaf__));

extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ , __leaf__));



extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) __attribute__ ((__nothrow__ , __leaf__));
# 164 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdio.h" 3
extern int renameat2 (int __oldfd, const char *__old, int __newfd,
        const char *__new, unsigned int __flags) __attribute__ ((__nothrow__ , __leaf__));







extern FILE *tmpfile (void) ;
# 183 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdio.h" 3
extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;




extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;
# 204 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdio.h" 3
extern char *tempnam (const char *__dir, const char *__pfx)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;







extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);
# 227 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdio.h" 3
extern int fflush_unlocked (FILE *__stream);
# 237 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdio.h" 3
extern int fcloseall (void);
# 246 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdio.h" 3
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 270 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdio.h" 3
extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ , __leaf__)) ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     cookie_io_functions_t __io_funcs) __attribute__ ((__nothrow__ , __leaf__)) ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  __attribute__ ((__nothrow__ , __leaf__)) ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ , __leaf__)) ;





extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ , __leaf__));




extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__ , __leaf__));


extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));







extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));





extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));







extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));
# 410 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdio.h" 3
extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf")

                               ;
extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf")
                              ;
extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) __asm__ ("" "__isoc99_sscanf") __attribute__ ((__nothrow__ , __leaf__))

                      ;
# 435 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdio.h" 3
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__scanf__, 2, 0)));





extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) ;
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vsscanf") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 489 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdio.h" 3
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);






extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 514 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdio.h" 3
extern int fgetc_unlocked (FILE *__stream);
# 525 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdio.h" 3
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 541 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdio.h" 3
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);







extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     __attribute__ ((__access__ (__write_only__, 1, 2)));
# 591 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdio.h" 3
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream)
    __attribute__ ((__access__ (__write_only__, 1, 2)));
# 608 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdio.h" 3
extern __ssize_t __getdelim (char **__restrict __lineptr,
                             size_t *__restrict __n, int __delimiter,
                             FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
                           size_t *__restrict __n, int __delimiter,
                           FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
                          size_t *__restrict __n,
                          FILE *__restrict __stream) ;







extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 667 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdio.h" 3
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
# 678 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdio.h" 3
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);







extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);
# 712 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdio.h" 3
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 736 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdio.h" 3
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 755 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdio.h" 3
extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);



extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;



extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;







extern void perror (const char *__s);




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
# 799 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdio.h" 3
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) __attribute__ ((__nothrow__ , __leaf__));





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
# 857 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdio.h" 3
extern int __uflow (FILE *);
extern int __overflow (FILE *, int);




# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/stdio.h" 1 3
# 38 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/stdio.h" 3
extern __inline __attribute__ ((__gnu_inline__)) int
vprintf (const char *__restrict __fmt, __gnuc_va_list __arg)
{
  return vfprintf (stdout, __fmt, __arg);
}



extern __inline __attribute__ ((__gnu_inline__)) int
getchar (void)
{
  return getc (stdin);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fgetc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}





extern __inline __attribute__ ((__gnu_inline__)) int
getc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}


extern __inline __attribute__ ((__gnu_inline__)) int
getchar_unlocked (void)
{
  return (__builtin_expect (((stdin)->_IO_read_ptr >= (stdin)->_IO_read_end), 0) ? __uflow (stdin) : *(unsigned char *) (stdin)->_IO_read_ptr++);
}




extern __inline __attribute__ ((__gnu_inline__)) int
putchar (int __c)
{
  return putc (__c, stdout);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fputc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}





extern __inline __attribute__ ((__gnu_inline__)) int
putc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}


extern __inline __attribute__ ((__gnu_inline__)) int
putchar_unlocked (int __c)
{
  return (__builtin_expect (((stdout)->_IO_write_ptr >= (stdout)->_IO_write_end), 0) ? __overflow (stdout, (unsigned char) (__c)) : (unsigned char) (*(stdout)->_IO_write_ptr++ = (__c)));
}





extern __inline __attribute__ ((__gnu_inline__)) __ssize_t
getline (char **__lineptr, size_t *__n, FILE *__stream)
{
  return __getdelim (__lineptr, __n, '\n', __stream);
}





extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) feof_unlocked (FILE *__stream)
{
  return (((__stream)->_flags & 0x0010) != 0);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) ferror_unlocked (FILE *__stream)
{
  return (((__stream)->_flags & 0x0020) != 0);
}
# 864 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdio.h" 2 3
# 874 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/stdio.h" 3

# 2 "/root/mnt/basilisk/src/ast/std/stdio.h" 2
# 3 "/root/mnt/basilisk/src/common.h"
# 1 "/root/mnt/basilisk/src/ast/std/stddef.h"
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/lib/gcc/x86_64-mk-linux/11.2.0/include/stddef.h" 1 3 4
# 143 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/lib/gcc/x86_64-mk-linux/11.2.0/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 2 "/root/mnt/basilisk/src/ast/std/stddef.h" 2
# 4 "/root/mnt/basilisk/src/common.h"
# 1 "/root/mnt/basilisk/src/ast/std/stdbool.h"
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/lib/gcc/x86_64-mk-linux/11.2.0/include/stdbool.h" 1 3 4
# 2 "/root/mnt/basilisk/src/ast/std/stdbool.h" 2
# 5 "/root/mnt/basilisk/src/common.h"
# 1 "/root/mnt/basilisk/src/ast/std/stdarg.h"
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/lib/gcc/x86_64-mk-linux/11.2.0/include/stdarg.h" 1 3 4
# 2 "/root/mnt/basilisk/src/ast/std/stdarg.h" 2
# 6 "/root/mnt/basilisk/src/common.h"
# 1 "/root/mnt/basilisk/src/ast/std/string.h"
# 7 "/root/mnt/basilisk/src/common.h"
# 1 "/root/mnt/basilisk/src/ast/std/float.h"
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/lib/gcc/x86_64-mk-linux/11.2.0/include/float.h" 1 3 4
# 2 "/root/mnt/basilisk/src/ast/std/float.h" 2
# 8 "/root/mnt/basilisk/src/common.h"
# 1 "/root/mnt/basilisk/src/ast/std/limits.h"
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/limits.h" 1 3
# 26 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/limits.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/libc-header-start.h" 1 3
# 27 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/limits.h" 2 3
# 124 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/limits.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/lib/gcc/x86_64-mk-linux/11.2.0/include-fixed/limits.h" 1 3 4
# 125 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/limits.h" 2 3
# 195 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/limits.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/posix1_lim.h" 1 3
# 27 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/posix1_lim.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/wordsize.h" 1 3
# 28 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/posix1_lim.h" 2 3
# 161 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/posix1_lim.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/local_lim.h" 1 3
# 38 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/local_lim.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/linux/limits.h" 1 3
# 39 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/local_lim.h" 2 3
# 162 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/posix1_lim.h" 2 3
# 196 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/limits.h" 2 3



# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/posix2_lim.h" 1 3
# 200 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/limits.h" 2 3



# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/xopen_lim.h" 1 3
# 64 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/xopen_lim.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/uio_lim.h" 1 3
# 65 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/xopen_lim.h" 2 3
# 204 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/limits.h" 2 3
# 2 "/root/mnt/basilisk/src/ast/std/limits.h" 2
# 9 "/root/mnt/basilisk/src/common.h"
# 1 "/root/mnt/basilisk/src/ast/std/math.h"
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 1 3
# 27 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/libc-header-start.h" 1 3
# 28 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 2 3












# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/math-vector.h" 1 3
# 25 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/math-vector.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/libm-simd-decl-stubs.h" 1 3
# 26 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/math-vector.h" 2 3
# 41 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 2 3
# 138 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/flt-eval-method.h" 1 3
# 139 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 2 3
# 149 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 3
typedef float float_t;
typedef double double_t;
# 190 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/fp-logb.h" 1 3
# 191 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 2 3
# 233 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/fp-fast.h" 1 3
# 234 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 2 3



enum
  {
    FP_INT_UPWARD =

      0,
    FP_INT_DOWNWARD =

      1,
    FP_INT_TOWARDZERO =

      2,
    FP_INT_TONEARESTFROMZERO =

      3,
    FP_INT_TONEAREST =

      4,
  };
# 298 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls-helper-functions.h" 1 3
# 20 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls-helper-functions.h" 3
extern int __fpclassify (double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));


extern int __signbit (double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));



extern int __isinf (double __value) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__const__));


extern int __finite (double __value) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__const__));


extern int __isnan (double __value) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__const__));


extern int __iseqsig (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));


extern int __issignaling (double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));
# 299 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 2 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls.h" 1 3
# 53 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls.h" 3
extern double acos (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __acos (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double asin (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __asin (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double atan (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __atan (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double atan2 (double __y, double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __atan2 (double __y, double __x) __attribute__ ((__nothrow__ , __leaf__));


 extern double cos (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __cos (double __x) __attribute__ ((__nothrow__ , __leaf__));

 extern double sin (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __sin (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double tan (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __tan (double __x) __attribute__ ((__nothrow__ , __leaf__));




extern double cosh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __cosh (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double sinh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __sinh (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double tanh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __tanh (double __x) __attribute__ ((__nothrow__ , __leaf__));



 extern void sincos (double __x, double *__sinx, double *__cosx) __attribute__ ((__nothrow__ , __leaf__)); extern void __sincos (double __x, double *__sinx, double *__cosx) __attribute__ ((__nothrow__ , __leaf__))
                                                        ;




extern double acosh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __acosh (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double asinh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __asinh (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double atanh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __atanh (double __x) __attribute__ ((__nothrow__ , __leaf__));





 extern double exp (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __exp (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double frexp (double __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern double __frexp (double __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));


extern double ldexp (double __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern double __ldexp (double __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));


 extern double log (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __log (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double log10 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __log10 (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double modf (double __x, double *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern double __modf (double __x, double *__iptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern double exp10 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __exp10 (double __x) __attribute__ ((__nothrow__ , __leaf__));




extern double expm1 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __expm1 (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double log1p (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __log1p (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double logb (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __logb (double __x) __attribute__ ((__nothrow__ , __leaf__));




extern double exp2 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __exp2 (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double log2 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __log2 (double __x) __attribute__ ((__nothrow__ , __leaf__));






 extern double pow (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __pow (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));


extern double sqrt (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __sqrt (double __x) __attribute__ ((__nothrow__ , __leaf__));



extern double hypot (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __hypot (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));




extern double cbrt (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __cbrt (double __x) __attribute__ ((__nothrow__ , __leaf__));






extern double ceil (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __ceil (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double fabs (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fabs (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double floor (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __floor (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double fmod (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __fmod (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));
# 177 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls.h" 3
extern int isinf (double __value) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__const__));




extern int finite (double __value) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__const__));


extern double drem (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __drem (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));



extern double significand (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __significand (double __x) __attribute__ ((__nothrow__ , __leaf__));






extern double copysign (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __copysign (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern double nan (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)); extern double __nan (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__));
# 213 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls.h" 3
extern int isnan (double __value) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__const__));





extern double j0 (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __j0 (double) __attribute__ ((__nothrow__ , __leaf__));
extern double j1 (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __j1 (double) __attribute__ ((__nothrow__ , __leaf__));
extern double jn (int, double) __attribute__ ((__nothrow__ , __leaf__)); extern double __jn (int, double) __attribute__ ((__nothrow__ , __leaf__));
extern double y0 (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __y0 (double) __attribute__ ((__nothrow__ , __leaf__));
extern double y1 (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __y1 (double) __attribute__ ((__nothrow__ , __leaf__));
extern double yn (int, double) __attribute__ ((__nothrow__ , __leaf__)); extern double __yn (int, double) __attribute__ ((__nothrow__ , __leaf__));





extern double erf (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __erf (double) __attribute__ ((__nothrow__ , __leaf__));
extern double erfc (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __erfc (double) __attribute__ ((__nothrow__ , __leaf__));
extern double lgamma (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __lgamma (double) __attribute__ ((__nothrow__ , __leaf__));




extern double tgamma (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __tgamma (double) __attribute__ ((__nothrow__ , __leaf__));





extern double gamma (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __gamma (double) __attribute__ ((__nothrow__ , __leaf__));







extern double lgamma_r (double, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern double __lgamma_r (double, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));






extern double rint (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __rint (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double nextafter (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __nextafter (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));

extern double nexttoward (double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __nexttoward (double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));




extern double nextdown (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __nextdown (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double nextup (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __nextup (double __x) __attribute__ ((__nothrow__ , __leaf__));



extern double remainder (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __remainder (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));



extern double scalbn (double __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern double __scalbn (double __x, int __n) __attribute__ ((__nothrow__ , __leaf__));



extern int ilogb (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogb (double __x) __attribute__ ((__nothrow__ , __leaf__));




extern long int llogb (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __llogb (double __x) __attribute__ ((__nothrow__ , __leaf__));




extern double scalbln (double __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern double __scalbln (double __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));



extern double nearbyint (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __nearbyint (double __x) __attribute__ ((__nothrow__ , __leaf__));



extern double round (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __round (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern double trunc (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __trunc (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern double __remquo (double __x, double __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));






extern long int lrint (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrint (double __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llrint (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrint (double __x) __attribute__ ((__nothrow__ , __leaf__));



extern long int lround (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lround (double __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llround (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llround (double __x) __attribute__ ((__nothrow__ , __leaf__));



extern double fdim (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __fdim (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));


extern double fmax (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fmax (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double fmin (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fmin (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double fma (double __x, double __y, double __z) __attribute__ ((__nothrow__ , __leaf__)); extern double __fma (double __x, double __y, double __z) __attribute__ ((__nothrow__ , __leaf__));




extern double roundeven (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __roundeven (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern __intmax_t fromfp (double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfp (double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                            ;



extern __uintmax_t ufromfp (double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfp (double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                              ;




extern __intmax_t fromfpx (double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfpx (double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                             ;




extern __uintmax_t ufromfpx (double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfpx (double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                               ;


extern double fmaxmag (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fmaxmag (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double fminmag (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fminmag (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int canonicalize (double *__cx, const double *__x) __attribute__ ((__nothrow__ , __leaf__));




extern int totalorder (const double *__x, const double *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern int totalordermag (const double *__x, const double *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern double getpayload (const double *__x) __attribute__ ((__nothrow__ , __leaf__)); extern double __getpayload (const double *__x) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayload (double *__x, double __payload) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayloadsig (double *__x, double __payload) __attribute__ ((__nothrow__ , __leaf__));







extern double scalb (double __x, double __n) __attribute__ ((__nothrow__ , __leaf__)); extern double __scalb (double __x, double __n) __attribute__ ((__nothrow__ , __leaf__));
# 300 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 2 3
# 315 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls-helper-functions.h" 1 3
# 20 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls-helper-functions.h" 3
extern int __fpclassifyf (float __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));


extern int __signbitf (float __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));



extern int __isinff (float __value) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__const__));


extern int __finitef (float __value) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__const__));


extern int __isnanf (float __value) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__const__));


extern int __iseqsigf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));


extern int __issignalingf (float __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));
# 316 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 2 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls.h" 1 3
# 53 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls.h" 3
extern float acosf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __acosf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float asinf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __asinf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float atanf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __atanf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float atan2f (float __y, float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __atan2f (float __y, float __x) __attribute__ ((__nothrow__ , __leaf__));


 extern float cosf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __cosf (float __x) __attribute__ ((__nothrow__ , __leaf__));

 extern float sinf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __sinf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float tanf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __tanf (float __x) __attribute__ ((__nothrow__ , __leaf__));




extern float coshf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __coshf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float sinhf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __sinhf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float tanhf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __tanhf (float __x) __attribute__ ((__nothrow__ , __leaf__));



 extern void sincosf (float __x, float *__sinx, float *__cosx) __attribute__ ((__nothrow__ , __leaf__)); extern void __sincosf (float __x, float *__sinx, float *__cosx) __attribute__ ((__nothrow__ , __leaf__))
                                                        ;




extern float acoshf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __acoshf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float asinhf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __asinhf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float atanhf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __atanhf (float __x) __attribute__ ((__nothrow__ , __leaf__));





 extern float expf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __expf (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float frexpf (float __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern float __frexpf (float __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));


extern float ldexpf (float __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern float __ldexpf (float __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));


 extern float logf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __logf (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float log10f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __log10f (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float modff (float __x, float *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern float __modff (float __x, float *__iptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern float exp10f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __exp10f (float __x) __attribute__ ((__nothrow__ , __leaf__));




extern float expm1f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __expm1f (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float log1pf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __log1pf (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float logbf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __logbf (float __x) __attribute__ ((__nothrow__ , __leaf__));




extern float exp2f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __exp2f (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float log2f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __log2f (float __x) __attribute__ ((__nothrow__ , __leaf__));






 extern float powf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __powf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));


extern float sqrtf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __sqrtf (float __x) __attribute__ ((__nothrow__ , __leaf__));



extern float hypotf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __hypotf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));




extern float cbrtf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __cbrtf (float __x) __attribute__ ((__nothrow__ , __leaf__));






extern float ceilf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __ceilf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float fabsf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fabsf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float floorf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __floorf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float fmodf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __fmodf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));
# 177 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls.h" 3
extern int isinff (float __value) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__const__));




extern int finitef (float __value) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__const__));


extern float dremf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __dremf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));



extern float significandf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __significandf (float __x) __attribute__ ((__nothrow__ , __leaf__));






extern float copysignf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern float nanf (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)); extern float __nanf (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__));
# 213 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls.h" 3
extern int isnanf (float __value) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__const__));





extern float j0f (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __j0f (float) __attribute__ ((__nothrow__ , __leaf__));
extern float j1f (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __j1f (float) __attribute__ ((__nothrow__ , __leaf__));
extern float jnf (int, float) __attribute__ ((__nothrow__ , __leaf__)); extern float __jnf (int, float) __attribute__ ((__nothrow__ , __leaf__));
extern float y0f (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __y0f (float) __attribute__ ((__nothrow__ , __leaf__));
extern float y1f (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __y1f (float) __attribute__ ((__nothrow__ , __leaf__));
extern float ynf (int, float) __attribute__ ((__nothrow__ , __leaf__)); extern float __ynf (int, float) __attribute__ ((__nothrow__ , __leaf__));





extern float erff (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __erff (float) __attribute__ ((__nothrow__ , __leaf__));
extern float erfcf (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __erfcf (float) __attribute__ ((__nothrow__ , __leaf__));
extern float lgammaf (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __lgammaf (float) __attribute__ ((__nothrow__ , __leaf__));




extern float tgammaf (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __tgammaf (float) __attribute__ ((__nothrow__ , __leaf__));





extern float gammaf (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __gammaf (float) __attribute__ ((__nothrow__ , __leaf__));







extern float lgammaf_r (float, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern float __lgammaf_r (float, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));






extern float rintf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __rintf (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float nextafterf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __nextafterf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));

extern float nexttowardf (float __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __nexttowardf (float __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));




extern float nextdownf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __nextdownf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float nextupf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __nextupf (float __x) __attribute__ ((__nothrow__ , __leaf__));



extern float remainderf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __remainderf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));



extern float scalbnf (float __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern float __scalbnf (float __x, int __n) __attribute__ ((__nothrow__ , __leaf__));



extern int ilogbf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogbf (float __x) __attribute__ ((__nothrow__ , __leaf__));




extern long int llogbf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __llogbf (float __x) __attribute__ ((__nothrow__ , __leaf__));




extern float scalblnf (float __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern float __scalblnf (float __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));



extern float nearbyintf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __nearbyintf (float __x) __attribute__ ((__nothrow__ , __leaf__));



extern float roundf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __roundf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern float truncf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __truncf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern float __remquof (float __x, float __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));






extern long int lrintf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrintf (float __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llrintf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrintf (float __x) __attribute__ ((__nothrow__ , __leaf__));



extern long int lroundf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lroundf (float __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llroundf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llroundf (float __x) __attribute__ ((__nothrow__ , __leaf__));



extern float fdimf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __fdimf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));


extern float fmaxf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fmaxf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float fminf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fminf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float fmaf (float __x, float __y, float __z) __attribute__ ((__nothrow__ , __leaf__)); extern float __fmaf (float __x, float __y, float __z) __attribute__ ((__nothrow__ , __leaf__));




extern float roundevenf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __roundevenf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern __intmax_t fromfpf (float __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfpf (float __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                            ;



extern __uintmax_t ufromfpf (float __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfpf (float __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                              ;




extern __intmax_t fromfpxf (float __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfpxf (float __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                             ;




extern __uintmax_t ufromfpxf (float __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfpxf (float __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                               ;


extern float fmaxmagf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fmaxmagf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float fminmagf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fminmagf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int canonicalizef (float *__cx, const float *__x) __attribute__ ((__nothrow__ , __leaf__));




extern int totalorderf (const float *__x, const float *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern int totalordermagf (const float *__x, const float *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern float getpayloadf (const float *__x) __attribute__ ((__nothrow__ , __leaf__)); extern float __getpayloadf (const float *__x) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayloadf (float *__x, float __payload) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayloadsigf (float *__x, float __payload) __attribute__ ((__nothrow__ , __leaf__));







extern float scalbf (float __x, float __n) __attribute__ ((__nothrow__ , __leaf__)); extern float __scalbf (float __x, float __n) __attribute__ ((__nothrow__ , __leaf__));
# 317 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 2 3
# 384 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls-helper-functions.h" 1 3
# 20 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls-helper-functions.h" 3
extern int __fpclassifyl (long double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));


extern int __signbitl (long double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));



extern int __isinfl (long double __value) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__const__));


extern int __finitel (long double __value) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__const__));


extern int __isnanl (long double __value) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__const__));


extern int __iseqsigl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));


extern int __issignalingl (long double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));
# 385 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 2 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls.h" 1 3
# 53 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls.h" 3
extern long double acosl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __acosl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double asinl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __asinl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double atanl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __atanl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double atan2l (long double __y, long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __atan2l (long double __y, long double __x) __attribute__ ((__nothrow__ , __leaf__));


 extern long double cosl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __cosl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

 extern long double sinl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __sinl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double tanl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __tanl (long double __x) __attribute__ ((__nothrow__ , __leaf__));




extern long double coshl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __coshl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double sinhl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __sinhl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double tanhl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __tanhl (long double __x) __attribute__ ((__nothrow__ , __leaf__));



 extern void sincosl (long double __x, long double *__sinx, long double *__cosx) __attribute__ ((__nothrow__ , __leaf__)); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) __attribute__ ((__nothrow__ , __leaf__))
                                                        ;




extern long double acoshl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __acoshl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double asinhl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __asinhl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double atanhl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __atanhl (long double __x) __attribute__ ((__nothrow__ , __leaf__));





 extern long double expl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __expl (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double frexpl (long double __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern long double __frexpl (long double __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));


extern long double ldexpl (long double __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern long double __ldexpl (long double __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));


 extern long double logl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __logl (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double log10l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __log10l (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double modfl (long double __x, long double *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern long double __modfl (long double __x, long double *__iptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern long double exp10l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __exp10l (long double __x) __attribute__ ((__nothrow__ , __leaf__));




extern long double expm1l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __expm1l (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double log1pl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __log1pl (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double logbl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __logbl (long double __x) __attribute__ ((__nothrow__ , __leaf__));




extern long double exp2l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __exp2l (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double log2l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __log2l (long double __x) __attribute__ ((__nothrow__ , __leaf__));






 extern long double powl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __powl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));


extern long double sqrtl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __sqrtl (long double __x) __attribute__ ((__nothrow__ , __leaf__));



extern long double hypotl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __hypotl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));




extern long double cbrtl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __cbrtl (long double __x) __attribute__ ((__nothrow__ , __leaf__));






extern long double ceill (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __ceill (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double fabsl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fabsl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double floorl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __floorl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __fmodl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));
# 177 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls.h" 3
extern int isinfl (long double __value) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__const__));




extern int finitel (long double __value) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __dreml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));



extern long double significandl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __significandl (long double __x) __attribute__ ((__nothrow__ , __leaf__));






extern long double copysignl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern long double nanl (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)); extern long double __nanl (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__));
# 213 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls.h" 3
extern int isnanl (long double __value) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__const__));





extern long double j0l (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __j0l (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double j1l (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __j1l (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double jnl (int, long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __jnl (int, long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double y0l (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __y0l (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double y1l (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __y1l (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double ynl (int, long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __ynl (int, long double) __attribute__ ((__nothrow__ , __leaf__));





extern long double erfl (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __erfl (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double erfcl (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __erfcl (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double lgammal (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __lgammal (long double) __attribute__ ((__nothrow__ , __leaf__));




extern long double tgammal (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __tgammal (long double) __attribute__ ((__nothrow__ , __leaf__));





extern long double gammal (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __gammal (long double) __attribute__ ((__nothrow__ , __leaf__));







extern long double lgammal_r (long double, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern long double __lgammal_r (long double, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));






extern long double rintl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __rintl (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double nextafterl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __nextafterl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));

extern long double nexttowardl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __nexttowardl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));




extern long double nextdownl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __nextdownl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double nextupl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __nextupl (long double __x) __attribute__ ((__nothrow__ , __leaf__));



extern long double remainderl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __remainderl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));



extern long double scalbnl (long double __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern long double __scalbnl (long double __x, int __n) __attribute__ ((__nothrow__ , __leaf__));



extern int ilogbl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogbl (long double __x) __attribute__ ((__nothrow__ , __leaf__));




extern long int llogbl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __llogbl (long double __x) __attribute__ ((__nothrow__ , __leaf__));




extern long double scalblnl (long double __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern long double __scalblnl (long double __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));



extern long double nearbyintl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __nearbyintl (long double __x) __attribute__ ((__nothrow__ , __leaf__));



extern long double roundl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __roundl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern long double truncl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __truncl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern long double __remquol (long double __x, long double __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));






extern long int lrintl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrintl (long double __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llrintl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrintl (long double __x) __attribute__ ((__nothrow__ , __leaf__));



extern long int lroundl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lroundl (long double __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llroundl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llroundl (long double __x) __attribute__ ((__nothrow__ , __leaf__));



extern long double fdiml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __fdiml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));


extern long double fmaxl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fmaxl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double fminl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fminl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double fmal (long double __x, long double __y, long double __z) __attribute__ ((__nothrow__ , __leaf__)); extern long double __fmal (long double __x, long double __y, long double __z) __attribute__ ((__nothrow__ , __leaf__));




extern long double roundevenl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __roundevenl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern __intmax_t fromfpl (long double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfpl (long double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                            ;



extern __uintmax_t ufromfpl (long double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfpl (long double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                              ;




extern __intmax_t fromfpxl (long double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfpxl (long double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                             ;




extern __uintmax_t ufromfpxl (long double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfpxl (long double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                               ;


extern long double fmaxmagl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fmaxmagl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double fminmagl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fminmagl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int canonicalizel (long double *__cx, const long double *__x) __attribute__ ((__nothrow__ , __leaf__));




extern int totalorderl (const long double *__x, const long double *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern int totalordermagl (const long double *__x, const long double *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern long double getpayloadl (const long double *__x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __getpayloadl (const long double *__x) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayloadl (long double *__x, long double __payload) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayloadsigl (long double *__x, long double __payload) __attribute__ ((__nothrow__ , __leaf__));







extern long double scalbl (long double __x, long double __n) __attribute__ ((__nothrow__ , __leaf__)); extern long double __scalbl (long double __x, long double __n) __attribute__ ((__nothrow__ , __leaf__));
# 386 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 2 3
# 436 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls.h" 1 3
# 53 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls.h" 3
extern _Float32 acosf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __acosf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float32 asinf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __asinf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float32 atanf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __atanf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float32 atan2f32 (_Float32 __y, _Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __atan2f32 (_Float32 __y, _Float32 __x) __attribute__ ((__nothrow__ , __leaf__));


 extern _Float32 cosf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __cosf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float32 sinf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __sinf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float32 tanf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __tanf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float32 coshf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __coshf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float32 sinhf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __sinhf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float32 tanhf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __tanhf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));



 extern void sincosf32 (_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) __attribute__ ((__nothrow__ , __leaf__)); extern void __sincosf32 (_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) __attribute__ ((__nothrow__ , __leaf__))
                                                        ;




extern _Float32 acoshf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __acoshf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float32 asinhf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __asinhf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float32 atanhf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __atanhf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));





 extern _Float32 expf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __expf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 frexpf32 (_Float32 __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __frexpf32 (_Float32 __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 ldexpf32 (_Float32 __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __ldexpf32 (_Float32 __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));


 extern _Float32 logf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __logf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 log10f32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __log10f32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 modff32 (_Float32 __x, _Float32 *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __modff32 (_Float32 __x, _Float32 *__iptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern _Float32 exp10f32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __exp10f32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float32 expm1f32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __expm1f32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 log1pf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __log1pf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 logbf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __logbf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float32 exp2f32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __exp2f32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 log2f32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __log2f32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));






 extern _Float32 powf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __powf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 sqrtf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __sqrtf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float32 hypotf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __hypotf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__));




extern _Float32 cbrtf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __cbrtf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));






extern _Float32 ceilf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32 __ceilf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32 fabsf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32 __fabsf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32 floorf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32 __floorf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32 fmodf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __fmodf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__));
# 198 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls.h" 3
extern _Float32 copysignf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32 __copysignf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern _Float32 nanf32 (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __nanf32 (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__));
# 220 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls.h" 3
extern _Float32 j0f32 (_Float32) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __j0f32 (_Float32) __attribute__ ((__nothrow__ , __leaf__));
extern _Float32 j1f32 (_Float32) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __j1f32 (_Float32) __attribute__ ((__nothrow__ , __leaf__));
extern _Float32 jnf32 (int, _Float32) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __jnf32 (int, _Float32) __attribute__ ((__nothrow__ , __leaf__));
extern _Float32 y0f32 (_Float32) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __y0f32 (_Float32) __attribute__ ((__nothrow__ , __leaf__));
extern _Float32 y1f32 (_Float32) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __y1f32 (_Float32) __attribute__ ((__nothrow__ , __leaf__));
extern _Float32 ynf32 (int, _Float32) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __ynf32 (int, _Float32) __attribute__ ((__nothrow__ , __leaf__));





extern _Float32 erff32 (_Float32) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __erff32 (_Float32) __attribute__ ((__nothrow__ , __leaf__));
extern _Float32 erfcf32 (_Float32) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __erfcf32 (_Float32) __attribute__ ((__nothrow__ , __leaf__));
extern _Float32 lgammaf32 (_Float32) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __lgammaf32 (_Float32) __attribute__ ((__nothrow__ , __leaf__));




extern _Float32 tgammaf32 (_Float32) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __tgammaf32 (_Float32) __attribute__ ((__nothrow__ , __leaf__));
# 252 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls.h" 3
extern _Float32 lgammaf32_r (_Float32, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __lgammaf32_r (_Float32, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));






extern _Float32 rintf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __rintf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 nextafterf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __nextafterf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__));






extern _Float32 nextdownf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __nextdownf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float32 nextupf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __nextupf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float32 remainderf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __remainderf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__));



extern _Float32 scalbnf32 (_Float32 __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __scalbnf32 (_Float32 __x, int __n) __attribute__ ((__nothrow__ , __leaf__));



extern int ilogbf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogbf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));




extern long int llogbf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __llogbf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float32 scalblnf32 (_Float32 __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __scalblnf32 (_Float32 __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));



extern _Float32 nearbyintf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __nearbyintf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float32 roundf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32 __roundf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern _Float32 truncf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32 __truncf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern _Float32 remquof32 (_Float32 __x, _Float32 __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __remquof32 (_Float32 __x, _Float32 __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));






extern long int lrintf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrintf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llrintf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrintf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));



extern long int lroundf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lroundf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llroundf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llroundf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float32 fdimf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __fdimf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 fmaxf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32 __fmaxf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32 fminf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32 __fminf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32 fmaf32 (_Float32 __x, _Float32 __y, _Float32 __z) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __fmaf32 (_Float32 __x, _Float32 __y, _Float32 __z) __attribute__ ((__nothrow__ , __leaf__));




extern _Float32 roundevenf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32 __roundevenf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern __intmax_t fromfpf32 (_Float32 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfpf32 (_Float32 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                            ;



extern __uintmax_t ufromfpf32 (_Float32 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfpf32 (_Float32 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                              ;




extern __intmax_t fromfpxf32 (_Float32 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfpxf32 (_Float32 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                             ;




extern __uintmax_t ufromfpxf32 (_Float32 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfpxf32 (_Float32 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                               ;


extern _Float32 fmaxmagf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32 __fmaxmagf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32 fminmagf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32 __fminmagf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int canonicalizef32 (_Float32 *__cx, const _Float32 *__x) __attribute__ ((__nothrow__ , __leaf__));




extern int totalorderf32 (const _Float32 *__x, const _Float32 *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern int totalordermagf32 (const _Float32 *__x, const _Float32 *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern _Float32 getpayloadf32 (const _Float32 *__x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __getpayloadf32 (const _Float32 *__x) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayloadf32 (_Float32 *__x, _Float32 __payload) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayloadsigf32 (_Float32 *__x, _Float32 __payload) __attribute__ ((__nothrow__ , __leaf__));
# 437 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 2 3
# 453 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls.h" 1 3
# 53 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls.h" 3
extern _Float64 acosf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __acosf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float64 asinf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __asinf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float64 atanf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __atanf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float64 atan2f64 (_Float64 __y, _Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __atan2f64 (_Float64 __y, _Float64 __x) __attribute__ ((__nothrow__ , __leaf__));


 extern _Float64 cosf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __cosf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float64 sinf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __sinf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float64 tanf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __tanf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float64 coshf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __coshf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float64 sinhf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __sinhf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float64 tanhf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __tanhf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));



 extern void sincosf64 (_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) __attribute__ ((__nothrow__ , __leaf__)); extern void __sincosf64 (_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) __attribute__ ((__nothrow__ , __leaf__))
                                                        ;




extern _Float64 acoshf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __acoshf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float64 asinhf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __asinhf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float64 atanhf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __atanhf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));





 extern _Float64 expf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __expf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 frexpf64 (_Float64 __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __frexpf64 (_Float64 __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 ldexpf64 (_Float64 __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __ldexpf64 (_Float64 __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));


 extern _Float64 logf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __logf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 log10f64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __log10f64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 modff64 (_Float64 __x, _Float64 *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __modff64 (_Float64 __x, _Float64 *__iptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern _Float64 exp10f64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __exp10f64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float64 expm1f64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __expm1f64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 log1pf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __log1pf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 logbf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __logbf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float64 exp2f64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __exp2f64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 log2f64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __log2f64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));






 extern _Float64 powf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __powf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 sqrtf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __sqrtf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float64 hypotf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __hypotf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__));




extern _Float64 cbrtf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __cbrtf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));






extern _Float64 ceilf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64 __ceilf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64 fabsf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64 __fabsf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64 floorf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64 __floorf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64 fmodf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __fmodf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__));
# 198 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls.h" 3
extern _Float64 copysignf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64 __copysignf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern _Float64 nanf64 (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __nanf64 (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__));
# 220 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls.h" 3
extern _Float64 j0f64 (_Float64) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __j0f64 (_Float64) __attribute__ ((__nothrow__ , __leaf__));
extern _Float64 j1f64 (_Float64) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __j1f64 (_Float64) __attribute__ ((__nothrow__ , __leaf__));
extern _Float64 jnf64 (int, _Float64) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __jnf64 (int, _Float64) __attribute__ ((__nothrow__ , __leaf__));
extern _Float64 y0f64 (_Float64) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __y0f64 (_Float64) __attribute__ ((__nothrow__ , __leaf__));
extern _Float64 y1f64 (_Float64) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __y1f64 (_Float64) __attribute__ ((__nothrow__ , __leaf__));
extern _Float64 ynf64 (int, _Float64) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __ynf64 (int, _Float64) __attribute__ ((__nothrow__ , __leaf__));





extern _Float64 erff64 (_Float64) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __erff64 (_Float64) __attribute__ ((__nothrow__ , __leaf__));
extern _Float64 erfcf64 (_Float64) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __erfcf64 (_Float64) __attribute__ ((__nothrow__ , __leaf__));
extern _Float64 lgammaf64 (_Float64) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __lgammaf64 (_Float64) __attribute__ ((__nothrow__ , __leaf__));




extern _Float64 tgammaf64 (_Float64) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __tgammaf64 (_Float64) __attribute__ ((__nothrow__ , __leaf__));
# 252 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls.h" 3
extern _Float64 lgammaf64_r (_Float64, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __lgammaf64_r (_Float64, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));






extern _Float64 rintf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __rintf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 nextafterf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __nextafterf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__));






extern _Float64 nextdownf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __nextdownf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float64 nextupf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __nextupf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float64 remainderf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __remainderf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__));



extern _Float64 scalbnf64 (_Float64 __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __scalbnf64 (_Float64 __x, int __n) __attribute__ ((__nothrow__ , __leaf__));



extern int ilogbf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogbf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));




extern long int llogbf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __llogbf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float64 scalblnf64 (_Float64 __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __scalblnf64 (_Float64 __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));



extern _Float64 nearbyintf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __nearbyintf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float64 roundf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64 __roundf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern _Float64 truncf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64 __truncf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern _Float64 remquof64 (_Float64 __x, _Float64 __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __remquof64 (_Float64 __x, _Float64 __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));






extern long int lrintf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrintf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llrintf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrintf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));



extern long int lroundf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lroundf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llroundf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llroundf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float64 fdimf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __fdimf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 fmaxf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64 __fmaxf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64 fminf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64 __fminf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64 fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) __attribute__ ((__nothrow__ , __leaf__));




extern _Float64 roundevenf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64 __roundevenf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern __intmax_t fromfpf64 (_Float64 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfpf64 (_Float64 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                            ;



extern __uintmax_t ufromfpf64 (_Float64 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfpf64 (_Float64 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                              ;




extern __intmax_t fromfpxf64 (_Float64 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfpxf64 (_Float64 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                             ;




extern __uintmax_t ufromfpxf64 (_Float64 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfpxf64 (_Float64 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                               ;


extern _Float64 fmaxmagf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64 __fmaxmagf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64 fminmagf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64 __fminmagf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int canonicalizef64 (_Float64 *__cx, const _Float64 *__x) __attribute__ ((__nothrow__ , __leaf__));




extern int totalorderf64 (const _Float64 *__x, const _Float64 *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern int totalordermagf64 (const _Float64 *__x, const _Float64 *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern _Float64 getpayloadf64 (const _Float64 *__x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __getpayloadf64 (const _Float64 *__x) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayloadf64 (_Float64 *__x, _Float64 __payload) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayloadsigf64 (_Float64 *__x, _Float64 __payload) __attribute__ ((__nothrow__ , __leaf__));
# 454 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 2 3
# 467 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls-helper-functions.h" 1 3
# 20 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls-helper-functions.h" 3
extern int __fpclassifyf128 (_Float128 __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));


extern int __signbitf128 (_Float128 __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));



extern int __isinff128 (_Float128 __value) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__const__));


extern int __finitef128 (_Float128 __value) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__const__));


extern int __isnanf128 (_Float128 __value) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__const__));


extern int __iseqsigf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));


extern int __issignalingf128 (_Float128 __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));
# 468 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 2 3


# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls.h" 1 3
# 53 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls.h" 3
extern _Float128 acosf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __acosf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float128 asinf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __asinf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float128 atanf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __atanf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float128 atan2f128 (_Float128 __y, _Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __atan2f128 (_Float128 __y, _Float128 __x) __attribute__ ((__nothrow__ , __leaf__));


 extern _Float128 cosf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __cosf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float128 sinf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __sinf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float128 tanf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __tanf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float128 coshf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __coshf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float128 sinhf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __sinhf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float128 tanhf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __tanhf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));



 extern void sincosf128 (_Float128 __x, _Float128 *__sinx, _Float128 *__cosx) __attribute__ ((__nothrow__ , __leaf__)); extern void __sincosf128 (_Float128 __x, _Float128 *__sinx, _Float128 *__cosx) __attribute__ ((__nothrow__ , __leaf__))
                                                        ;




extern _Float128 acoshf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __acoshf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float128 asinhf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __asinhf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float128 atanhf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __atanhf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));





 extern _Float128 expf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __expf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float128 frexpf128 (_Float128 __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __frexpf128 (_Float128 __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));


extern _Float128 ldexpf128 (_Float128 __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __ldexpf128 (_Float128 __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));


 extern _Float128 logf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __logf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float128 log10f128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __log10f128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float128 modff128 (_Float128 __x, _Float128 *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __modff128 (_Float128 __x, _Float128 *__iptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern _Float128 exp10f128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __exp10f128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float128 expm1f128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __expm1f128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float128 log1pf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __log1pf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float128 logbf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __logbf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float128 exp2f128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __exp2f128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float128 log2f128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __log2f128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));






 extern _Float128 powf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __powf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float128 sqrtf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __sqrtf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float128 hypotf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __hypotf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));




extern _Float128 cbrtf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __cbrtf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));






extern _Float128 ceilf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float128 __ceilf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float128 fabsf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float128 __fabsf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float128 floorf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float128 __floorf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float128 fmodf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __fmodf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));
# 198 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls.h" 3
extern _Float128 copysignf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float128 __copysignf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern _Float128 nanf128 (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __nanf128 (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__));
# 220 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls.h" 3
extern _Float128 j0f128 (_Float128) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __j0f128 (_Float128) __attribute__ ((__nothrow__ , __leaf__));
extern _Float128 j1f128 (_Float128) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __j1f128 (_Float128) __attribute__ ((__nothrow__ , __leaf__));
extern _Float128 jnf128 (int, _Float128) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __jnf128 (int, _Float128) __attribute__ ((__nothrow__ , __leaf__));
extern _Float128 y0f128 (_Float128) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __y0f128 (_Float128) __attribute__ ((__nothrow__ , __leaf__));
extern _Float128 y1f128 (_Float128) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __y1f128 (_Float128) __attribute__ ((__nothrow__ , __leaf__));
extern _Float128 ynf128 (int, _Float128) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __ynf128 (int, _Float128) __attribute__ ((__nothrow__ , __leaf__));





extern _Float128 erff128 (_Float128) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __erff128 (_Float128) __attribute__ ((__nothrow__ , __leaf__));
extern _Float128 erfcf128 (_Float128) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __erfcf128 (_Float128) __attribute__ ((__nothrow__ , __leaf__));
extern _Float128 lgammaf128 (_Float128) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __lgammaf128 (_Float128) __attribute__ ((__nothrow__ , __leaf__));




extern _Float128 tgammaf128 (_Float128) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __tgammaf128 (_Float128) __attribute__ ((__nothrow__ , __leaf__));
# 252 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls.h" 3
extern _Float128 lgammaf128_r (_Float128, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __lgammaf128_r (_Float128, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));






extern _Float128 rintf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __rintf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float128 nextafterf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __nextafterf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));






extern _Float128 nextdownf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __nextdownf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float128 nextupf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __nextupf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float128 remainderf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __remainderf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));



extern _Float128 scalbnf128 (_Float128 __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __scalbnf128 (_Float128 __x, int __n) __attribute__ ((__nothrow__ , __leaf__));



extern int ilogbf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogbf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));




extern long int llogbf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __llogbf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float128 scalblnf128 (_Float128 __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __scalblnf128 (_Float128 __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));



extern _Float128 nearbyintf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __nearbyintf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float128 roundf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float128 __roundf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern _Float128 truncf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float128 __truncf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern _Float128 remquof128 (_Float128 __x, _Float128 __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __remquof128 (_Float128 __x, _Float128 __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));






extern long int lrintf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrintf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llrintf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrintf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));



extern long int lroundf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lroundf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llroundf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llroundf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float128 fdimf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __fdimf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float128 fmaxf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float128 __fmaxf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float128 fminf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float128 __fminf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float128 fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) __attribute__ ((__nothrow__ , __leaf__));




extern _Float128 roundevenf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float128 __roundevenf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern __intmax_t fromfpf128 (_Float128 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfpf128 (_Float128 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                            ;



extern __uintmax_t ufromfpf128 (_Float128 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfpf128 (_Float128 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                              ;




extern __intmax_t fromfpxf128 (_Float128 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfpxf128 (_Float128 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                             ;




extern __uintmax_t ufromfpxf128 (_Float128 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfpxf128 (_Float128 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                               ;


extern _Float128 fmaxmagf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float128 __fmaxmagf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float128 fminmagf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float128 __fminmagf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int canonicalizef128 (_Float128 *__cx, const _Float128 *__x) __attribute__ ((__nothrow__ , __leaf__));




extern int totalorderf128 (const _Float128 *__x, const _Float128 *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern int totalordermagf128 (const _Float128 *__x, const _Float128 *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern _Float128 getpayloadf128 (const _Float128 *__x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __getpayloadf128 (const _Float128 *__x) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayloadf128 (_Float128 *__x, _Float128 __payload) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayloadsigf128 (_Float128 *__x, _Float128 __payload) __attribute__ ((__nothrow__ , __leaf__));
# 471 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 2 3
# 487 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls.h" 1 3
# 53 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls.h" 3
extern _Float32x acosf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __acosf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float32x asinf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __asinf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float32x atanf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __atanf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float32x atan2f32x (_Float32x __y, _Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __atan2f32x (_Float32x __y, _Float32x __x) __attribute__ ((__nothrow__ , __leaf__));


 extern _Float32x cosf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __cosf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float32x sinf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __sinf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float32x tanf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __tanf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float32x coshf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __coshf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float32x sinhf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __sinhf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float32x tanhf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __tanhf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));



 extern void sincosf32x (_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) __attribute__ ((__nothrow__ , __leaf__)); extern void __sincosf32x (_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) __attribute__ ((__nothrow__ , __leaf__))
                                                        ;




extern _Float32x acoshf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __acoshf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float32x asinhf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __asinhf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float32x atanhf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __atanhf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));





 extern _Float32x expf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __expf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x frexpf32x (_Float32x __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __frexpf32x (_Float32x __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x ldexpf32x (_Float32x __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __ldexpf32x (_Float32x __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));


 extern _Float32x logf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __logf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x log10f32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __log10f32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x modff32x (_Float32x __x, _Float32x *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __modff32x (_Float32x __x, _Float32x *__iptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern _Float32x exp10f32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __exp10f32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float32x expm1f32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __expm1f32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x log1pf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __log1pf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x logbf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __logbf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float32x exp2f32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __exp2f32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x log2f32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __log2f32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));






 extern _Float32x powf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __powf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x sqrtf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __sqrtf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float32x hypotf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __hypotf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__));




extern _Float32x cbrtf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __cbrtf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));






extern _Float32x ceilf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32x __ceilf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32x fabsf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32x __fabsf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32x floorf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32x __floorf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32x fmodf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __fmodf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__));
# 198 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls.h" 3
extern _Float32x copysignf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32x __copysignf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern _Float32x nanf32x (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __nanf32x (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__));
# 220 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls.h" 3
extern _Float32x j0f32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __j0f32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__));
extern _Float32x j1f32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __j1f32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__));
extern _Float32x jnf32x (int, _Float32x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __jnf32x (int, _Float32x) __attribute__ ((__nothrow__ , __leaf__));
extern _Float32x y0f32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __y0f32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__));
extern _Float32x y1f32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __y1f32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__));
extern _Float32x ynf32x (int, _Float32x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __ynf32x (int, _Float32x) __attribute__ ((__nothrow__ , __leaf__));





extern _Float32x erff32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __erff32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__));
extern _Float32x erfcf32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __erfcf32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__));
extern _Float32x lgammaf32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __lgammaf32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float32x tgammaf32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __tgammaf32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__));
# 252 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls.h" 3
extern _Float32x lgammaf32x_r (_Float32x, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __lgammaf32x_r (_Float32x, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));






extern _Float32x rintf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __rintf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x nextafterf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __nextafterf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__));






extern _Float32x nextdownf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __nextdownf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float32x nextupf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __nextupf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float32x remainderf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __remainderf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__));



extern _Float32x scalbnf32x (_Float32x __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __scalbnf32x (_Float32x __x, int __n) __attribute__ ((__nothrow__ , __leaf__));



extern int ilogbf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogbf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));




extern long int llogbf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __llogbf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float32x scalblnf32x (_Float32x __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __scalblnf32x (_Float32x __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));



extern _Float32x nearbyintf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __nearbyintf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float32x roundf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32x __roundf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern _Float32x truncf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32x __truncf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern _Float32x remquof32x (_Float32x __x, _Float32x __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __remquof32x (_Float32x __x, _Float32x __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));






extern long int lrintf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrintf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llrintf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrintf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));



extern long int lroundf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lroundf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llroundf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llroundf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float32x fdimf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __fdimf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x fmaxf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32x __fmaxf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32x fminf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32x __fminf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32x fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) __attribute__ ((__nothrow__ , __leaf__));




extern _Float32x roundevenf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32x __roundevenf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern __intmax_t fromfpf32x (_Float32x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfpf32x (_Float32x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                            ;



extern __uintmax_t ufromfpf32x (_Float32x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfpf32x (_Float32x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                              ;




extern __intmax_t fromfpxf32x (_Float32x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfpxf32x (_Float32x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                             ;




extern __uintmax_t ufromfpxf32x (_Float32x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfpxf32x (_Float32x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                               ;


extern _Float32x fmaxmagf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32x __fmaxmagf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32x fminmagf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32x __fminmagf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int canonicalizef32x (_Float32x *__cx, const _Float32x *__x) __attribute__ ((__nothrow__ , __leaf__));




extern int totalorderf32x (const _Float32x *__x, const _Float32x *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern int totalordermagf32x (const _Float32x *__x, const _Float32x *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern _Float32x getpayloadf32x (const _Float32x *__x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __getpayloadf32x (const _Float32x *__x) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayloadf32x (_Float32x *__x, _Float32x __payload) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayloadsigf32x (_Float32x *__x, _Float32x __payload) __attribute__ ((__nothrow__ , __leaf__));
# 488 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 2 3
# 504 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls.h" 1 3
# 53 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls.h" 3
extern _Float64x acosf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __acosf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float64x asinf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __asinf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float64x atanf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __atanf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float64x atan2f64x (_Float64x __y, _Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __atan2f64x (_Float64x __y, _Float64x __x) __attribute__ ((__nothrow__ , __leaf__));


 extern _Float64x cosf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __cosf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float64x sinf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __sinf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float64x tanf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __tanf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float64x coshf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __coshf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float64x sinhf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __sinhf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float64x tanhf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __tanhf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));



 extern void sincosf64x (_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) __attribute__ ((__nothrow__ , __leaf__)); extern void __sincosf64x (_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) __attribute__ ((__nothrow__ , __leaf__))
                                                        ;




extern _Float64x acoshf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __acoshf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float64x asinhf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __asinhf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float64x atanhf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __atanhf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));





 extern _Float64x expf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __expf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64x frexpf64x (_Float64x __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __frexpf64x (_Float64x __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64x ldexpf64x (_Float64x __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __ldexpf64x (_Float64x __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));


 extern _Float64x logf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __logf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64x log10f64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __log10f64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64x modff64x (_Float64x __x, _Float64x *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __modff64x (_Float64x __x, _Float64x *__iptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern _Float64x exp10f64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __exp10f64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float64x expm1f64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __expm1f64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64x log1pf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __log1pf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64x logbf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __logbf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float64x exp2f64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __exp2f64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64x log2f64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __log2f64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));






 extern _Float64x powf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __powf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64x sqrtf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __sqrtf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float64x hypotf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __hypotf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));




extern _Float64x cbrtf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __cbrtf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));






extern _Float64x ceilf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64x __ceilf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64x fabsf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64x __fabsf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64x floorf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64x __floorf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64x fmodf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __fmodf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));
# 198 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls.h" 3
extern _Float64x copysignf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64x __copysignf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern _Float64x nanf64x (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __nanf64x (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__));
# 220 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls.h" 3
extern _Float64x j0f64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __j0f64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__));
extern _Float64x j1f64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __j1f64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__));
extern _Float64x jnf64x (int, _Float64x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __jnf64x (int, _Float64x) __attribute__ ((__nothrow__ , __leaf__));
extern _Float64x y0f64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __y0f64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__));
extern _Float64x y1f64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __y1f64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__));
extern _Float64x ynf64x (int, _Float64x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __ynf64x (int, _Float64x) __attribute__ ((__nothrow__ , __leaf__));





extern _Float64x erff64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __erff64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__));
extern _Float64x erfcf64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __erfcf64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__));
extern _Float64x lgammaf64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __lgammaf64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float64x tgammaf64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __tgammaf64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__));
# 252 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls.h" 3
extern _Float64x lgammaf64x_r (_Float64x, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __lgammaf64x_r (_Float64x, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));






extern _Float64x rintf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __rintf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64x nextafterf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __nextafterf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));






extern _Float64x nextdownf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __nextdownf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float64x nextupf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __nextupf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float64x remainderf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __remainderf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));



extern _Float64x scalbnf64x (_Float64x __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __scalbnf64x (_Float64x __x, int __n) __attribute__ ((__nothrow__ , __leaf__));



extern int ilogbf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogbf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));




extern long int llogbf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __llogbf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float64x scalblnf64x (_Float64x __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __scalblnf64x (_Float64x __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));



extern _Float64x nearbyintf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __nearbyintf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float64x roundf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64x __roundf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern _Float64x truncf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64x __truncf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern _Float64x remquof64x (_Float64x __x, _Float64x __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __remquof64x (_Float64x __x, _Float64x __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));






extern long int lrintf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrintf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llrintf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrintf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));



extern long int lroundf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lroundf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llroundf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llroundf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float64x fdimf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __fdimf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64x fmaxf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64x __fmaxf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64x fminf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64x __fminf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64x fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) __attribute__ ((__nothrow__ , __leaf__));




extern _Float64x roundevenf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64x __roundevenf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern __intmax_t fromfpf64x (_Float64x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfpf64x (_Float64x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                            ;



extern __uintmax_t ufromfpf64x (_Float64x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfpf64x (_Float64x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                              ;




extern __intmax_t fromfpxf64x (_Float64x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfpxf64x (_Float64x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                             ;




extern __uintmax_t ufromfpxf64x (_Float64x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfpxf64x (_Float64x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                               ;


extern _Float64x fmaxmagf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64x __fmaxmagf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64x fminmagf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64x __fminmagf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int canonicalizef64x (_Float64x *__cx, const _Float64x *__x) __attribute__ ((__nothrow__ , __leaf__));




extern int totalorderf64x (const _Float64x *__x, const _Float64x *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern int totalordermagf64x (const _Float64x *__x, const _Float64x *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern _Float64x getpayloadf64x (const _Float64x *__x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __getpayloadf64x (const _Float64x *__x) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayloadf64x (_Float64x *__x, _Float64x __payload) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayloadsigf64x (_Float64x *__x, _Float64x __payload) __attribute__ ((__nothrow__ , __leaf__));
# 505 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 2 3
# 552 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls-narrow.h" 1 3
# 24 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls-narrow.h" 3
extern float fadd (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));


extern float fdiv (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));


extern float fmul (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));


extern float fsub (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));
# 553 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 2 3
# 571 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls-narrow.h" 1 3
# 24 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls-narrow.h" 3
extern float faddl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));


extern float fdivl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));


extern float fmull (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));


extern float fsubl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));
# 572 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 2 3
# 597 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls-narrow.h" 1 3
# 24 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls-narrow.h" 3
extern double daddl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));


extern double ddivl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));


extern double dmull (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));


extern double dsubl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));
# 598 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 2 3
# 677 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls-narrow.h" 1 3
# 24 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls-narrow.h" 3
extern _Float32 f32addf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 f32divf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 f32mulf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 f32subf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__));
# 678 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 2 3
# 687 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls-narrow.h" 1 3
# 24 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls-narrow.h" 3
extern _Float32 f32addf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 f32divf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 f32mulf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 f32subf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__));
# 688 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 2 3
# 697 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls-narrow.h" 1 3
# 24 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls-narrow.h" 3
extern _Float32 f32addf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 f32divf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 f32mulf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 f32subf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));
# 698 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 2 3
# 707 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls-narrow.h" 1 3
# 24 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls-narrow.h" 3
extern _Float32 f32addf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 f32divf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 f32mulf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 f32subf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));
# 708 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 2 3
# 727 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls-narrow.h" 1 3
# 24 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls-narrow.h" 3
extern _Float32x f32xaddf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x f32xdivf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x f32xmulf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x f32xsubf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__));
# 728 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 2 3
# 737 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls-narrow.h" 1 3
# 24 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls-narrow.h" 3
extern _Float32x f32xaddf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x f32xdivf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x f32xmulf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x f32xsubf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));
# 738 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 2 3
# 747 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls-narrow.h" 1 3
# 24 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls-narrow.h" 3
extern _Float32x f32xaddf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x f32xdivf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x f32xmulf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x f32xsubf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));
# 748 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 2 3
# 767 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls-narrow.h" 1 3
# 24 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls-narrow.h" 3
extern _Float64 f64addf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 f64divf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 f64mulf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 f64subf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));
# 768 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 2 3
# 777 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls-narrow.h" 1 3
# 24 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls-narrow.h" 3
extern _Float64 f64addf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 f64divf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 f64mulf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 f64subf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));
# 778 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 2 3
# 797 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls-narrow.h" 1 3
# 24 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/mathcalls-narrow.h" 3
extern _Float64x f64xaddf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64x f64xdivf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64x f64xmulf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64x f64xsubf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));
# 798 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 2 3
# 834 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 3
extern int signgam;
# 914 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 3
enum
  {
    FP_NAN =

      0,
    FP_INFINITE =

      1,
    FP_ZERO =

      2,
    FP_SUBNORMAL =

      3,
    FP_NORMAL =

      4
  };
# 1034 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/iscanonical.h" 1 3
# 23 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/iscanonical.h" 3
extern int __iscanonicall (long double __x)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 1035 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 2 3
# 1386 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/math.h" 3

# 2 "/root/mnt/basilisk/src/ast/std/math.h" 2
# 10 "/root/mnt/basilisk/src/common.h"
# 1 "/root/mnt/basilisk/src/ast/std/time.h"
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/time.h" 1 3
# 29 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/time.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/lib/gcc/x86_64-mk-linux/11.2.0/include/stddef.h" 1 3 4
# 30 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/time.h" 2 3



# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/time.h" 1 3
# 73 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/time.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/timex.h" 1 3
# 26 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/timex.h" 3
struct timex
{
  unsigned int modes;
  __syscall_slong_t offset;
  __syscall_slong_t freq;
  __syscall_slong_t maxerror;
  __syscall_slong_t esterror;
  int status;
  __syscall_slong_t constant;
  __syscall_slong_t precision;
  __syscall_slong_t tolerance;
  struct timeval time;
  __syscall_slong_t tick;
  __syscall_slong_t ppsfreq;
  __syscall_slong_t jitter;
  int shift;
  __syscall_slong_t stabil;
  __syscall_slong_t jitcnt;
  __syscall_slong_t calcnt;
  __syscall_slong_t errcnt;
  __syscall_slong_t stbcnt;

  int tai;


  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;
};
# 74 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/time.h" 2 3




extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) __attribute__ ((__nothrow__ , __leaf__));


# 34 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/time.h" 2 3





# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/struct_tm.h" 1 3






struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};
# 40 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/time.h" 2 3
# 48 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/time.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/struct_itimerspec.h" 1 3







struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };
# 49 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/time.h" 2 3
struct sigevent;
# 68 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/time.h" 3




extern clock_t clock (void) __attribute__ ((__nothrow__ , __leaf__));


extern time_t time (time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));


extern double difftime (time_t __time1, time_t __time0)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));




extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     __attribute__ ((__nothrow__ , __leaf__));






extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));



extern char *strptime_l (const char *__restrict __s,
    const char *__restrict __fmt, struct tm *__tp,
    locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));





extern struct tm *gmtime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));



extern struct tm *localtime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));




extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));




extern char *asctime (const struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern char *ctime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));






extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));


extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) __attribute__ ((__nothrow__ , __leaf__));



extern int daylight;
extern long int timezone;
# 190 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/time.h" 3
extern time_t timegm (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern time_t timelocal (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern int dysize (int __year) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 205 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/time.h" 3
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) __attribute__ ((__nothrow__ , __leaf__));


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     __attribute__ ((__nothrow__ , __leaf__));






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) __attribute__ ((__nothrow__ , __leaf__));




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_delete (timer_t __timerid) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     __attribute__ ((__nothrow__ , __leaf__));


extern int timer_getoverrun (timer_t __timerid) __attribute__ ((__nothrow__ , __leaf__));





extern int timespec_get (struct timespec *__ts, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 274 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/time.h" 3
extern int getdate_err;
# 283 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/time.h" 3
extern struct tm *getdate (const char *__string);
# 297 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/time.h" 3
extern int getdate_r (const char *__restrict __string,
        struct tm *__restrict __resbufp);



# 2 "/root/mnt/basilisk/src/ast/std/time.h" 2
# 11 "/root/mnt/basilisk/src/common.h"
# 1 "/root/mnt/basilisk/src/ast/std/sys/time.h"
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/sys/time.h" 1 3
# 34 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/sys/time.h" 3

# 52 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/sys/time.h" 3
struct timezone
  {
    int tz_minuteswest;
    int tz_dsttime;
  };
# 66 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/sys/time.h" 3
extern int gettimeofday (struct timeval *__restrict __tv,
    void *__restrict __tz) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int settimeofday (const struct timeval *__tv,
    const struct timezone *__tz)
     __attribute__ ((__nothrow__ , __leaf__));





extern int adjtime (const struct timeval *__delta,
      struct timeval *__olddelta) __attribute__ ((__nothrow__ , __leaf__));




enum __itimer_which
  {

    ITIMER_REAL = 0,


    ITIMER_VIRTUAL = 1,



    ITIMER_PROF = 2

  };



struct itimerval
  {

    struct timeval it_interval;

    struct timeval it_value;
  };




typedef enum __itimer_which __itimer_which_t;






extern int getitimer (__itimer_which_t __which,
        struct itimerval *__value) __attribute__ ((__nothrow__ , __leaf__));




extern int setitimer (__itimer_which_t __which,
        const struct itimerval *__restrict __new,
        struct itimerval *__restrict __old) __attribute__ ((__nothrow__ , __leaf__));




extern int utimes (const char *__file, const struct timeval __tvp[2])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int lutimes (const char *__file, const struct timeval __tvp[2])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int futimes (int __fd, const struct timeval __tvp[2]) __attribute__ ((__nothrow__ , __leaf__));






extern int futimesat (int __fd, const char *__file,
        const struct timeval __tvp[2]) __attribute__ ((__nothrow__ , __leaf__));
# 187 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/sys/time.h" 3

# 2 "/root/mnt/basilisk/src/ast/std/sys/time.h" 2
# 12 "/root/mnt/basilisk/src/common.h"
# 1 "/root/mnt/basilisk/src/ast/std/sys/resource.h"
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/sys/resource.h" 1 3
# 24 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/sys/resource.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/resource.h" 1 3
# 31 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/resource.h" 3
enum __rlimit_resource
{

  RLIMIT_CPU = 0,



  RLIMIT_FSIZE = 1,



  RLIMIT_DATA = 2,



  RLIMIT_STACK = 3,



  RLIMIT_CORE = 4,






  __RLIMIT_RSS = 5,



  RLIMIT_NOFILE = 7,
  __RLIMIT_OFILE = RLIMIT_NOFILE,




  RLIMIT_AS = 9,



  __RLIMIT_NPROC = 6,



  __RLIMIT_MEMLOCK = 8,



  __RLIMIT_LOCKS = 10,



  __RLIMIT_SIGPENDING = 11,



  __RLIMIT_MSGQUEUE = 12,





  __RLIMIT_NICE = 13,




  __RLIMIT_RTPRIO = 14,





  __RLIMIT_RTTIME = 15,


  __RLIMIT_NLIMITS = 16,
  __RLIM_NLIMITS = __RLIMIT_NLIMITS


};
# 131 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/resource.h" 3
typedef __rlim_t rlim_t;




typedef __rlim64_t rlim64_t;


struct rlimit
  {

    rlim_t rlim_cur;

    rlim_t rlim_max;
  };


struct rlimit64
  {

    rlim64_t rlim_cur;

    rlim64_t rlim_max;
 };



enum __rusage_who
{

  RUSAGE_SELF = 0,



  RUSAGE_CHILDREN = -1



  ,

  RUSAGE_THREAD = 1




};


# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/struct_rusage.h" 1 3
# 33 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/struct_rusage.h" 3
struct rusage
  {

    struct timeval ru_utime;

    struct timeval ru_stime;

    __extension__ union
      {
 long int ru_maxrss;
 __syscall_slong_t __ru_maxrss_word;
      };


    __extension__ union
      {
 long int ru_ixrss;
 __syscall_slong_t __ru_ixrss_word;
      };

    __extension__ union
      {
 long int ru_idrss;
 __syscall_slong_t __ru_idrss_word;
      };

    __extension__ union
      {
 long int ru_isrss;
  __syscall_slong_t __ru_isrss_word;
      };


    __extension__ union
      {
 long int ru_minflt;
 __syscall_slong_t __ru_minflt_word;
      };

    __extension__ union
      {
 long int ru_majflt;
 __syscall_slong_t __ru_majflt_word;
      };

    __extension__ union
      {
 long int ru_nswap;
 __syscall_slong_t __ru_nswap_word;
      };


    __extension__ union
      {
 long int ru_inblock;
 __syscall_slong_t __ru_inblock_word;
      };

    __extension__ union
      {
 long int ru_oublock;
 __syscall_slong_t __ru_oublock_word;
      };

    __extension__ union
      {
 long int ru_msgsnd;
 __syscall_slong_t __ru_msgsnd_word;
      };

    __extension__ union
      {
 long int ru_msgrcv;
 __syscall_slong_t __ru_msgrcv_word;
      };

    __extension__ union
      {
 long int ru_nsignals;
 __syscall_slong_t __ru_nsignals_word;
      };



    __extension__ union
      {
 long int ru_nvcsw;
 __syscall_slong_t __ru_nvcsw_word;
      };


    __extension__ union
      {
 long int ru_nivcsw;
 __syscall_slong_t __ru_nivcsw_word;
      };
  };
# 180 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/resource.h" 2 3







enum __priority_which
{
  PRIO_PROCESS = 0,

  PRIO_PGRP = 1,

  PRIO_USER = 2

};







extern int prlimit (__pid_t __pid, enum __rlimit_resource __resource,
      const struct rlimit *__new_limit,
      struct rlimit *__old_limit) __attribute__ ((__nothrow__ , __leaf__));
# 217 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/resource.h" 3
extern int prlimit64 (__pid_t __pid, enum __rlimit_resource __resource,
        const struct rlimit64 *__new_limit,
        struct rlimit64 *__old_limit) __attribute__ ((__nothrow__ , __leaf__));




# 25 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/sys/resource.h" 2 3













typedef enum __rlimit_resource __rlimit_resource_t;
typedef enum __rusage_who __rusage_who_t;
typedef enum __priority_which __priority_which_t;
# 50 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/sys/resource.h" 3
extern int getrlimit (__rlimit_resource_t __resource,
        struct rlimit *__rlimits) __attribute__ ((__nothrow__ , __leaf__));
# 61 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/sys/resource.h" 3
extern int getrlimit64 (__rlimit_resource_t __resource,
   struct rlimit64 *__rlimits) __attribute__ ((__nothrow__ , __leaf__));






extern int setrlimit (__rlimit_resource_t __resource,
        const struct rlimit *__rlimits) __attribute__ ((__nothrow__ , __leaf__));
# 81 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/sys/resource.h" 3
extern int setrlimit64 (__rlimit_resource_t __resource,
   const struct rlimit64 *__rlimits) __attribute__ ((__nothrow__ , __leaf__));




extern int getrusage (__rusage_who_t __who, struct rusage *__usage) __attribute__ ((__nothrow__ , __leaf__));





extern int getpriority (__priority_which_t __which, id_t __who) __attribute__ ((__nothrow__ , __leaf__));



extern int setpriority (__priority_which_t __which, id_t __who, int __prio)
     __attribute__ ((__nothrow__ , __leaf__));


# 2 "/root/mnt/basilisk/src/ast/std/sys/resource.h" 2
# 13 "/root/mnt/basilisk/src/common.h"
# 46 "/root/mnt/basilisk/src/common.h"
# 94 "/root/mnt/basilisk/src/common.h"

# 94 "/root/mnt/basilisk/src/common.h"
static inline void qassert (const char * file, int line, const char * cond) {
  fprintf (
# 95 "/root/mnt/basilisk/src/common.h" 3
          stderr
# 95 "/root/mnt/basilisk/src/common.h"
              , "%s:%d: Assertion `%s' failed.\n", file, line, cond);
  abort();
}
# 104 "/root/mnt/basilisk/src/common.h"
# 374 "/root/mnt/basilisk/src/common.h"
typedef struct {
  void * p;
  long max, len;
} Array;

Array * array_new()
{
  Array * a = ((Array *) malloc((1)*sizeof(Array)));
  a->p = 
# 382 "/root/mnt/basilisk/src/common.h" 3 4
        ((void *)0)
# 382 "/root/mnt/basilisk/src/common.h"
            ;
  a->max = a->len = 0;
  return a;
}

void array_free (Array * a)
{
  free(a->p);
  free(a);
}

void array_append (Array * a, void * elem, size_t size)
{
  if (a->len + size >= a->max) {
    a->max += ((size) > (4096) ? (size) : (4096));
    a->p = realloc(a->p,a->max);
  }
  memcpy (((char *)a->p) + a->len, elem, size);
  a->len += size;
}

void * array_shrink (Array * a)
{
  void * p = realloc(a->p,a->len);
  free(a);
  return p;
}
# 822 "/root/mnt/basilisk/src/common.h"
double _val_higher_dimension = 0.;
# 823 "/root/mnt/basilisk/src/common.h"

double undefined;






static void set_fpe (void) {
  int64_t lnan = 0x7ff0000000000001;
  if (!(sizeof (int64_t) == sizeof (double))) qassert ("/root/mnt/basilisk/src/common.h", 833, "sizeof (int64_t) == sizeof (double)");
  memcpy (&undefined, &lnan, sizeof (double));
  feenableexcept (
# 835 "/root/mnt/basilisk/src/common.h" 3
 0x04
# 835 "/root/mnt/basilisk/src/common.h"
 |
# 835 "/root/mnt/basilisk/src/common.h" 3
 0x01
# 835 "/root/mnt/basilisk/src/common.h"
 );
}
# 845 "/root/mnt/basilisk/src/common.h"
typedef struct {
  long n;
  long tn;
  int depth;
  int maxdepth;
} Grid;
Grid * grid = 
# 851 "/root/mnt/basilisk/src/common.h" 3 4
             ((void *)0)
# 851 "/root/mnt/basilisk/src/common.h"
                 ;

double X0 = 0., Y0 = 0., Z0 = 0.;

double L0 = 1.;


int N = 64;




typedef struct { int i; } scalar;

typedef struct {
  scalar x;

  scalar y;




} vector;

typedef struct {
  scalar * x;

  scalar * y;




} vectorl;

typedef struct {
  vector x;

  vector y;




} tensor;

struct { int x, y, z; } Period = {
# 895 "/root/mnt/basilisk/src/common.h" 3 4
                                 0
# 895 "/root/mnt/basilisk/src/common.h"
                                      , 
# 895 "/root/mnt/basilisk/src/common.h" 3 4
                                        0
# 895 "/root/mnt/basilisk/src/common.h"
                                             , 
# 895 "/root/mnt/basilisk/src/common.h" 3 4
                                               0
# 895 "/root/mnt/basilisk/src/common.h"
                                                    };

typedef struct {
  double x, y, z;
} coord;


# 917 "/root/mnt/basilisk/src/common.h"
void normalize (coord * n)
{
  double norm = 0.;

    norm += ((n->x)*(n->x));
# 921 "/root/mnt/basilisk/src/common.h"
norm += ((n->y)*(n->y));
  norm = sqrt(norm);

    n->x /= norm;
# 924 "/root/mnt/basilisk/src/common.h"
n->y /= norm;
}

struct _origin { double x, y, z; };

void origin (struct _origin p) {
  X0 = p.x; Y0 = p.y; Z0 = p.z;
}

void size (double L) {
  L0 = L;
}

double zero (double s0, double s1, double s2) { return 0.; }






  enum { right, left, top, bottom };



int nboundary = 2*2;
# 959 "/root/mnt/basilisk/src/common.h"
double * _constant = 
# 959 "/root/mnt/basilisk/src/common.h" 3 4
                    ((void *)0)
# 959 "/root/mnt/basilisk/src/common.h"
                        ;
size_t datasize = 0;
typedef struct _Point Point;
# 1 "/root/mnt/basilisk/src/grid/boundaries.h"


typedef struct _Boundary Boundary;

struct _Boundary {
  void (* destroy) (Boundary * b);
  void (* level) (const Boundary * b, scalar * list, int l);

  void (* restriction) (const Boundary * b, scalar * list, int l);
};

static Boundary ** boundaries = 
# 12 "/root/mnt/basilisk/src/grid/boundaries.h" 3 4
                               ((void *)0)
# 12 "/root/mnt/basilisk/src/grid/boundaries.h"
                                   ;

void add_boundary (Boundary * b) {
  int len = 0;
  if (boundaries) {
    Boundary ** i = boundaries;
    while (*i++) len++;
  }
  boundaries = (Boundary * *) realloc(boundaries,(len + 2)*sizeof(Boundary *));
  boundaries[len] = b;
  boundaries[len+1] = 
# 22 "/root/mnt/basilisk/src/grid/boundaries.h" 3 4
                     ((void *)0)
# 22 "/root/mnt/basilisk/src/grid/boundaries.h"
                         ;
}

void free_boundaries() {
  if (!boundaries)
    return;
  Boundary ** i = boundaries, * b;
  while ((b = *i++))
    if (b->destroy)
      b->destroy (b);
    else
      free(b);
  free(boundaries);
  boundaries = 
# 35 "/root/mnt/basilisk/src/grid/boundaries.h" 3 4
              ((void *)0)
# 35 "/root/mnt/basilisk/src/grid/boundaries.h"
                  ;
}
# 47 "/root/mnt/basilisk/src/grid/boundaries.h"
typedef struct {
  Boundary parent;
  int d;
} BoxBoundary;
# 964 "/root/mnt/basilisk/src/common.h"



typedef struct {
  double (** boundary) (Point, Point, scalar, void *);
  double (** boundary_homogeneous) (Point, Point, scalar, void *);
  double (* gradient) (double, double, double);
  void (* delete) (scalar);
  char * name;
  struct {
    int x;

    int y;




  } d;
  vector v;
  int face;
  
# 984 "/root/mnt/basilisk/src/common.h" 3 4
 _Bool 
# 984 "/root/mnt/basilisk/src/common.h"
      nodump, freed;
  int block;
  scalar * depends;
# 19 "/root/mnt/basilisk/src/grid/stencils.h"

# 19 "/root/mnt/basilisk/src/grid/stencils.h" 3 4
_Bool 
# 19 "/root/mnt/basilisk/src/grid/stencils.h"
    input, output;
  int width;
  int dirty;
# 18 "/root/mnt/basilisk/src/grid/multigrid-common.h"
void (* prolongation) (Point, scalar);
  void (* restriction) (Point, scalar);
# 9 "/root/mnt/basilisk/src/grid/tree-common.h"
void (* refine) (Point, scalar);
# 97 "/root/mnt/basilisk/src/grid/tree-common.h"
void (* coarsen) (Point, scalar);
# 28 "/root/mnt/basilisk/src/vof.h"
scalar * tracers, c;
  
# 29 "/root/mnt/basilisk/src/vof.h" 3 4
 _Bool 
# 29 "/root/mnt/basilisk/src/vof.h"
      inverse;
# 82 "/root/mnt/basilisk/src/fractions.h"
vector n;
# 21 "/root/mnt/basilisk/src/iforce.h"
scalar phi;
# 456 "/root/mnt/basilisk/src/heights.h"
vector height;
# 22 "/root/mnt/basilisk/src/tension.h"
double sigma;
# 987 "/root/mnt/basilisk/src/common.h"
} _Attributes;

static _Attributes * _attribute = 
# 989 "/root/mnt/basilisk/src/common.h" 3 4
                                 ((void *)0)
# 989 "/root/mnt/basilisk/src/common.h"
                                     ;






int list_len (scalar * list)
{
  if (!list) return 0;
  int ns = 0;
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ ns++;}}
  return ns;
}

scalar * list_append (scalar * list, scalar s)
{
  int len = list_len (list);
  list = (scalar *) realloc(list,(len + 2)*sizeof(scalar));
  list[len] = s;
  list[len + 1].i = -1;
  return list;
}

scalar * list_prepend (scalar * list, scalar s)
{
  int len = list_len (list);
  list = (scalar *) realloc(list,(len + 2)*sizeof(scalar));
  for (int i = len; i >= 1; i--)
    list[i] = list[i-1];
  list[0] = s;
  list[len + 1].i = -1;
  return list;
}

scalar * list_add (scalar * list, scalar s)
{
  {scalar*_i=(scalar*)( list);if(_i)for(scalar t=*_i;(&t)->i>=0;t=*++_i){
    if (t.i == s.i)
      return list;}}
  return list_append (list, s);
}

int list_lookup (scalar * l, scalar s)
{
  if (l != 
# 1034 "/root/mnt/basilisk/src/common.h" 3 4
          ((void *)0)
# 1034 "/root/mnt/basilisk/src/common.h"
              )
    {scalar*_i=(scalar*)( l);if(_i)for(scalar s1=*_i;(&s1)->i>=0;s1=*++_i){
      if (s1.i == s.i)
 return 
# 1037 "/root/mnt/basilisk/src/common.h" 3 4
       1
# 1037 "/root/mnt/basilisk/src/common.h"
           ;}}
  return 
# 1038 "/root/mnt/basilisk/src/common.h" 3 4
        0
# 1038 "/root/mnt/basilisk/src/common.h"
             ;
}

scalar * list_copy (scalar * l)
{
  scalar * list = 
# 1043 "/root/mnt/basilisk/src/common.h" 3 4
                 ((void *)0)
# 1043 "/root/mnt/basilisk/src/common.h"
                     ;
  if (l != 
# 1044 "/root/mnt/basilisk/src/common.h" 3 4
          ((void *)0)
# 1044 "/root/mnt/basilisk/src/common.h"
              )
    {scalar*_i=(scalar*)( l);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      list = list_append (list, s);}}
  return list;
}

scalar * list_concat (scalar * l1, scalar * l2)
{
  scalar * l3 = list_copy (l1);
  {scalar*_i=(scalar*)( l2);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    l3 = list_append (l3, s);}}
  return l3;
}

void list_print (scalar * l, FILE * fp)
{
  int i = 0;
  {scalar*_i=(scalar*)( l);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    fprintf (fp, "%s%s", i++ == 0 ? "{" : ",", _attribute[s.i].name);}}
  fputs (i > 0 ? "}\n" : "{}\n", fp);
}

int vectors_len (vector * list)
{
  if (!list) return 0;
  int nv = 0;
  {vector*_i=(vector*)( list);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){ nv++;}}
  return nv;
}

vector * vectors_append (vector * list, vector v)
{
  int len = vectors_len (list);
  list = (vector *) realloc(list,(len + 2)*sizeof(vector));
  list[len] = v;
  list[len + 1] = (vector){{-1}};
  return list;
}

vector * vectors_add (vector * list, vector v)
{
  {vector*_i=(vector*)( list);if(_i)for(vector w=*_i;(&w)->x.i>=0;w=*++_i){ {
    
# 1086 "/root/mnt/basilisk/src/common.h" 3 4
   _Bool 
# 1086 "/root/mnt/basilisk/src/common.h"
        id = 
# 1086 "/root/mnt/basilisk/src/common.h" 3 4
             1
# 1086 "/root/mnt/basilisk/src/common.h"
                 ;

      if (w.x.i != v.x.i)
 id = 
# 1089 "/root/mnt/basilisk/src/common.h" 3 4
     0
# 1089 "/root/mnt/basilisk/src/common.h"
          ;
# 1088 "/root/mnt/basilisk/src/common.h"
if (w.y.i != v.y.i)
 id = 
# 1089 "/root/mnt/basilisk/src/common.h" 3 4
     0
# 1089 "/root/mnt/basilisk/src/common.h"
          ;
    if (id)
      return list;
  }}}
  return vectors_append (list, v);
}

vector * vectors_copy (vector * l)
{
  vector * list = 
# 1098 "/root/mnt/basilisk/src/common.h" 3 4
                 ((void *)0)
# 1098 "/root/mnt/basilisk/src/common.h"
                     ;
  if (l != 
# 1099 "/root/mnt/basilisk/src/common.h" 3 4
          ((void *)0)
# 1099 "/root/mnt/basilisk/src/common.h"
              )
    {vector*_i=(vector*)( l);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){
      list = vectors_append (list, v);}}
  return list;
}

vector * vectors_from_scalars (scalar * s)
{
  vector * list = 
# 1107 "/root/mnt/basilisk/src/common.h" 3 4
                 ((void *)0)
# 1107 "/root/mnt/basilisk/src/common.h"
                     ;
  while (s->i >= 0) {
    vector v;
     {
      if (!(s->i >= 0)) qassert ("/root/mnt/basilisk/src/common.h", 1111, "s->i >= 0");
      v.x = *s++;
    }
# 1110 "/root/mnt/basilisk/src/common.h"
{
      if (!(s->i >= 0)) qassert ("/root/mnt/basilisk/src/common.h", 1111, "s->i >= 0");
      v.y = *s++;
    }
    list = vectors_append (list, v);
  }
  return list;
}

int tensors_len (tensor * list)
{
  if (!list) return 0;
  int nt = 0;
  {tensor*_i=(tensor*)( list);if(_i)for(tensor t=*_i;(&t)->x.x.i>=0;t=*++_i){ nt++;}}
  return nt;
}

tensor * tensors_append (tensor * list, tensor t)
{
  int len = tensors_len (list);
  list = (tensor *) realloc(list,(len + 2)*sizeof(tensor));
  list[len] = t;
  list[len + 1] = (tensor){{{-1}}};
  return list;
}

tensor * tensors_from_vectors (vector * v)
{
  tensor * list = 
# 1138 "/root/mnt/basilisk/src/common.h" 3 4
                 ((void *)0)
# 1138 "/root/mnt/basilisk/src/common.h"
                     ;
  while (v->x.i >= 0) {
    tensor t;
     {
      if (!(v->x.i >= 0)) qassert ("/root/mnt/basilisk/src/common.h", 1142, "v->x.i >= 0");
      t.x = *v++;
    }
# 1141 "/root/mnt/basilisk/src/common.h"
{
      if (!(v->y.i >= 0)) qassert ("/root/mnt/basilisk/src/common.h", 1142, "v->x.i >= 0");
      t.y = *v++;
    }
    list = tensors_append (list, t);
  }
  return list;
}

scalar * all = 
# 1150 "/root/mnt/basilisk/src/common.h" 3 4
              ((void *)0)
# 1150 "/root/mnt/basilisk/src/common.h"
                  ;
scalar * baseblock = 
# 1151 "/root/mnt/basilisk/src/common.h" 3 4
                    ((void *)0)
# 1151 "/root/mnt/basilisk/src/common.h"
                        ;



scalar (* init_scalar) (scalar, const char *);
scalar (* init_vertex_scalar) (scalar, const char *);
vector (* init_vector) (vector, const char *);
tensor (* init_tensor) (tensor, const char *);
vector (* init_face_vector) (vector, const char *);





typedef struct _Event Event;
typedef int (* Expr) (int *, double *, Event *);

struct _Event {
  int last, nexpr;
  int (* action) (const int, const double, Event *);
  Expr expr[3];
  int * arrayi;
  double * arrayt;
  char * file;
  int line;
  char * name;
  double t;
  int i, a;
  void * data;
  Event * next;
};

static Event * Events = 
# 1183 "/root/mnt/basilisk/src/common.h" 3 4
                       ((void *)0)
# 1183 "/root/mnt/basilisk/src/common.h"
                           ;

int iter = 0, inext = 0;
double t = 0, tnext = 0;
void init_events (void);
void event_register (Event event);
static void _init_solver (void);

void init_solver()
{
  Events = malloc(sizeof (Event));
  Events[0].last = 1;
  _attribute = calloc(datasize/sizeof(double),sizeof (_Attributes));
  int n = datasize/sizeof(double);
  all = (scalar *) malloc(sizeof (scalar)*(n + 1));
  baseblock = (scalar *) malloc(sizeof (scalar)*(n + 1));
  for (int i = 0; i < n; i++)
    baseblock[i].i = all[i].i = i;
  baseblock[n].i = all[n].i = -1;
# 1212 "/root/mnt/basilisk/src/common.h"
}







typedef struct {
  clock_t c;
  struct timeval tv;
  double tm;
} timer;

timer timer_start (void)
{
  timer t;
  t.c = clock();
  gettimeofday (&t.tv, 
# 1230 "/root/mnt/basilisk/src/common.h" 3 4
                      ((void *)0)
# 1230 "/root/mnt/basilisk/src/common.h"
                          );



  return t;
}

double timer_elapsed (timer t)
{
  struct timeval tvend;
  gettimeofday (&tvend, 
# 1240 "/root/mnt/basilisk/src/common.h" 3 4
                       ((void *)0)
# 1240 "/root/mnt/basilisk/src/common.h"
                           );
  return ((tvend.tv_sec - t.tv.tv_sec) +
   (tvend.tv_usec - t.tv.tv_usec)/1e6);
}



const vector zerof = {{65536 +0},{65536 +1}};
const vector unityf = {{65536 +2},{65536 +3}};
const scalar unity = {65536 +4};
const scalar zeroc = {65536 +5};



        vector fm = {{65536 +2},{65536 +3}};
        scalar cm = {65536 +4};
# 1269 "/root/mnt/basilisk/src/common.h"
static FILE ** qpopen_pipes = 
# 1269 "/root/mnt/basilisk/src/common.h" 3 4
                             ((void *)0)
# 1269 "/root/mnt/basilisk/src/common.h"
                                 ;

FILE * qpopen (const char * command, const char * type)
{
  if (0 > 0)
    return fopen ("/dev/null", type);
  FILE * fp = popen (command, type);
  if (fp) {
    FILE ** i = qpopen_pipes;
    int n = 0;
    while (i && *i) { n++; i++; }
    qpopen_pipes = (FILE * *) realloc(qpopen_pipes,(n + 2)*sizeof(FILE *));
    qpopen_pipes[n] = fp;
    qpopen_pipes[n+1] = 
# 1282 "/root/mnt/basilisk/src/common.h" 3 4
                       ((void *)0)
# 1282 "/root/mnt/basilisk/src/common.h"
                           ;
  }
  return fp;
}

int qpclose (FILE * fp)
{
  if (0 > 0)
    return fclose (fp);
  FILE ** i = qpopen_pipes;
  while (i && *i) {
    if (*i == fp)
      *i = (FILE *) 1;
    i++;
  }
  return pclose (fp);
}

static void qpclose_all()
{
  FILE ** i = qpopen_pipes;
  while (i && *i) {
    if (*i != (FILE *) 1)
      pclose (*i);
    i++;
  }
  free(qpopen_pipes);
  qpopen_pipes = 
# 1309 "/root/mnt/basilisk/src/common.h" 3 4
                ((void *)0)
# 1309 "/root/mnt/basilisk/src/common.h"
                    ;
}






FILE * lfopen (const char * name, const char * mode)
{
  char fname[80];
  sprintf (fname, "%s-%d", name, 0);
  return fopen (fname, mode);
}



void * matrix_new (int n, int p, size_t size)
{
  void ** m = ((void * *) malloc((n)*sizeof(void *)));
  char * a = ((char *) malloc((n*p*size)*sizeof(char)));
  for (int i = 0; i < n; i++)
    m[i] = a + i*p*size;
  return m;
}

double matrix_inverse (double ** m, int n, double pivmin)
{
  int indxc[n], indxr[n], ipiv[n];
  int i, icol = 0, irow = 0, j, k, l, ll;
  double big, dum, pivinv, minpiv = ((double)1e30);

  for (j = 0; j < n; j++)
    ipiv[j] = -1;

  for (i = 0; i < n; i++) {
    big = 0.0;
    for (j = 0; j < n; j++)
      if (ipiv[j] != 0)
 for (k = 0; k < n; k++) {
   if (ipiv[k] == -1) {
     if (fabs (m[j][k]) >= big) {
       big = fabs (m[j][k]);
       irow = j;
       icol = k;
     }
   }
 }
    ipiv[icol]++;
    if (irow != icol)
      for (l = 0; l < n; l++)
 do { double __tmp = m[irow][l]; m[irow][l] = m[icol][l]; m[icol][l] = __tmp; } while(0);
    indxr[i] = irow;
    indxc[i] = icol;
    if (fabs (m[icol][icol]) <= pivmin)
      return 0.;
    if (fabs (m[icol][icol]) < minpiv)
      minpiv = fabs (m[icol][icol]);
    pivinv = 1.0/m[icol][icol];
    m[icol][icol] = 1.0;
    for (l = 0; l < n; l++) m[icol][l] *= pivinv;
    for (ll = 0; ll < n; ll++)
      if (ll != icol) {
 dum = m[ll][icol];
 m[ll][icol] = 0.0;
 for (l = 0; l < n; l++)
   m[ll][l] -= m[icol][l]*dum;
      }
  }
  for (l = n - 1; l >= 0; l--) {
    if (indxr[l] != indxc[l])
      for (k = 0; k < n; k++)
 do { double __tmp = m[k][indxr[l]]; m[k][indxr[l]] = m[k][indxc[l]]; m[k][indxc[l]] = __tmp; } while(0);
  }
  return minpiv;
}

void matrix_free (void * m)
{
  free(((void **) m)[0]);
  free(m);
}



typedef void (* free_solver_func) (void);

static Array * free_solver_funcs = 
# 1396 "/root/mnt/basilisk/src/common.h" 3 4
                                  ((void *)0)
# 1396 "/root/mnt/basilisk/src/common.h"
                                      ;

void free_solver_func_add (free_solver_func func)
{
  if (!free_solver_funcs)
    free_solver_funcs = array_new();
  array_append (free_solver_funcs, &func, sizeof(free_solver_func));
}



static char * display_defaults = 
# 1407 "/root/mnt/basilisk/src/common.h" 3 4
                                ((void *)0)
# 1407 "/root/mnt/basilisk/src/common.h"
                                    ;

struct _display {
  const char * commands;
  
# 1411 "/root/mnt/basilisk/src/common.h" 3 4
 _Bool 
# 1411 "/root/mnt/basilisk/src/common.h"
      overwrite;
};

static void free_display_defaults() {
  free(display_defaults);
}

void display (struct _display p)
{
  if (display_defaults == 
# 1420 "/root/mnt/basilisk/src/common.h" 3 4
                         ((void *)0)
# 1420 "/root/mnt/basilisk/src/common.h"
                             )
    free_solver_func_add (free_display_defaults);
  if (p.overwrite) {
    free(display_defaults);
    display_defaults = malloc(strlen(p.commands) + 2);
    strcpy (display_defaults, "@");
    strcat (display_defaults, p.commands);
  }
  else {
    if (!display_defaults)
      display_defaults = strdup("@");
    display_defaults =
      realloc(display_defaults,strlen(display_defaults) + strlen(p.commands) + 1)
                                                                                     ;
    strcat (display_defaults, p.commands);
  }
}
# 1 "/root/mnt/basilisk/src/grid/stencils.h"
# 17 "/root/mnt/basilisk/src/grid/stencils.h"
# 27 "/root/mnt/basilisk/src/grid/stencils.h"
typedef struct {
  const char * fname;
  int line;
  int first;
  int face;
  
# 32 "/root/mnt/basilisk/src/grid/stencils.h" 3 4
 _Bool 
# 32 "/root/mnt/basilisk/src/grid/stencils.h"
      vertex;
} ForeachData;
# 48 "/root/mnt/basilisk/src/grid/stencils.h"
# 54 "/root/mnt/basilisk/src/grid/stencils.h"
# 72 "/root/mnt/basilisk/src/grid/stencils.h"
void stencil_val (Point p, scalar s, int i, int j, int k,
    const char * file, int line, 
# 73 "/root/mnt/basilisk/src/grid/stencils.h" 3 4
                                _Bool 
# 73 "/root/mnt/basilisk/src/grid/stencils.h"
                                     overflow);
void stencil_val_a (Point p, scalar s, int i, int j, int k, 
# 74 "/root/mnt/basilisk/src/grid/stencils.h" 3 4
                                                           _Bool 
# 74 "/root/mnt/basilisk/src/grid/stencils.h"
                                                                input,
      const char * file, int line);
# 79 "/root/mnt/basilisk/src/grid/stencils.h"
# 82 "/root/mnt/basilisk/src/grid/stencils.h"
# 85 "/root/mnt/basilisk/src/grid/stencils.h"
# 88 "/root/mnt/basilisk/src/grid/stencils.h"
# 109 "/root/mnt/basilisk/src/grid/stencils.h"
int _stencil_nop;



typedef void _stencil_undefined;
# 123 "/root/mnt/basilisk/src/grid/stencils.h"
static inline 
# 123 "/root/mnt/basilisk/src/grid/stencils.h" 3 4
             _Bool 
# 123 "/root/mnt/basilisk/src/grid/stencils.h"
                  scalar_is_dirty (scalar s)
{
  if (_attribute[s.i].dirty)
    return 
# 126 "/root/mnt/basilisk/src/grid/stencils.h" 3 4
          1
# 126 "/root/mnt/basilisk/src/grid/stencils.h"
              ;
  scalar * depends = _attribute[s.i].depends;
  {scalar*_i=(scalar*)( depends);if(_i)for(scalar d=*_i;(&d)->i>=0;d=*++_i){
    if (_attribute[d.i].dirty)
      return 
# 130 "/root/mnt/basilisk/src/grid/stencils.h" 3 4
            1
# 130 "/root/mnt/basilisk/src/grid/stencils.h"
                ;}}
  return 
# 131 "/root/mnt/basilisk/src/grid/stencils.h" 3 4
        0
# 131 "/root/mnt/basilisk/src/grid/stencils.h"
             ;
}




static inline 
# 137 "/root/mnt/basilisk/src/grid/stencils.h" 3 4
             _Bool 
# 137 "/root/mnt/basilisk/src/grid/stencils.h"
                  scalar_depends_from (scalar a, scalar b)
{
  scalar * depends = _attribute[a.i].depends;
  {scalar*_i=(scalar*)( depends);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (s.i == b.i)
      return 
# 142 "/root/mnt/basilisk/src/grid/stencils.h" 3 4
            1
# 142 "/root/mnt/basilisk/src/grid/stencils.h"
                ;}}
  return 
# 143 "/root/mnt/basilisk/src/grid/stencils.h" 3 4
        0
# 143 "/root/mnt/basilisk/src/grid/stencils.h"
             ;
}







void boundary_internal (scalar * list, const char * fname, int line);
void (* boundary_face) (vectorl);







void end_stencil (ForeachData * loop)
{
  scalar * listc = 
# 163 "/root/mnt/basilisk/src/grid/stencils.h" 3 4
                  ((void *)0)
# 163 "/root/mnt/basilisk/src/grid/stencils.h"
                      , * dirty = 
# 163 "/root/mnt/basilisk/src/grid/stencils.h" 3 4
                                  ((void *)0)
# 163 "/root/mnt/basilisk/src/grid/stencils.h"
                                      ;
  vectorl listf = {
# 164 "/root/mnt/basilisk/src/grid/stencils.h" 3 4
                  ((void *)0)
# 164 "/root/mnt/basilisk/src/grid/stencils.h"
                      };
  
# 165 "/root/mnt/basilisk/src/grid/stencils.h" 3 4
 _Bool 
# 165 "/root/mnt/basilisk/src/grid/stencils.h"
      flux = 
# 165 "/root/mnt/basilisk/src/grid/stencils.h" 3 4
             0
# 165 "/root/mnt/basilisk/src/grid/stencils.h"
                  ;




  {scalar*_i=(scalar*)( baseblock);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
    
# 171 "/root/mnt/basilisk/src/grid/stencils.h" 3 4
   _Bool 
# 171 "/root/mnt/basilisk/src/grid/stencils.h"
        write = _attribute[s.i].output, read = _attribute[s.i].input;




    {





      if (read && scalar_is_dirty (s)) {





 if (_attribute[s.i].face) {
   if (_attribute[s.i].width > 0)
     listc = list_append (listc, s);
   else if (!write) {
     scalar sn = _attribute[s.i].v.x.i >= 0 ? _attribute[s.i].v.x : s;

       if (_attribute[s.i].v.x.i == s.i) {




  if (_attribute[sn.i].boundary[left] || _attribute[sn.i].boundary[right])
    listc = list_append (listc, s);
  else if (_attribute[s.i].dirty != 2) {
    listf.x = list_append (listf.x, s);
    flux = 
# 203 "/root/mnt/basilisk/src/grid/stencils.h" 3 4
          1
# 203 "/root/mnt/basilisk/src/grid/stencils.h"
              ;
  }
       }
# 194 "/root/mnt/basilisk/src/grid/stencils.h"
if (_attribute[s.i].v.y.i == s.i) {




  if (_attribute[sn.i].boundary[bottom] || _attribute[sn.i].boundary[top])
    listc = list_append (listc, s);
  else if (_attribute[s.i].dirty != 2) {
    listf.y = list_append (listf.y, s);
    flux = 
# 203 "/root/mnt/basilisk/src/grid/stencils.h" 3 4
          1
# 203 "/root/mnt/basilisk/src/grid/stencils.h"
              ;
  }
       }
   }
 }





 else if (_attribute[s.i].width > 0)
   listc = list_append (listc, s);
      }





      if (write) {
 if (2 > 1 && !loop->vertex && loop->first) {
   
# 223 "/root/mnt/basilisk/src/grid/stencils.h" 3 4
  _Bool 
# 223 "/root/mnt/basilisk/src/grid/stencils.h"
       vertex = 
# 223 "/root/mnt/basilisk/src/grid/stencils.h" 3 4
                1
# 223 "/root/mnt/basilisk/src/grid/stencils.h"
                    ;

     if (_attribute[s.i].d.x != -1)
       vertex = 
# 226 "/root/mnt/basilisk/src/grid/stencils.h" 3 4
               0
# 226 "/root/mnt/basilisk/src/grid/stencils.h"
                    ;
# 225 "/root/mnt/basilisk/src/grid/stencils.h"
if (_attribute[s.i].d.y != -1)
       vertex = 
# 226 "/root/mnt/basilisk/src/grid/stencils.h" 3 4
               0
# 226 "/root/mnt/basilisk/src/grid/stencils.h"
                    ;
   if (vertex)
     fprintf (
# 228 "/root/mnt/basilisk/src/grid/stencils.h" 3
             stderr
# 228 "/root/mnt/basilisk/src/grid/stencils.h"
                 ,
       "%s:%d: warning: vertex scalar '%s' should be assigned with"
       " a foreach_vertex() loop\n",
       loop->fname, loop->line, _attribute[s.i].name);
 }
 if (_attribute[s.i].face) {
   if (loop->face == 0 && loop->first)
     fprintf (
# 235 "/root/mnt/basilisk/src/grid/stencils.h" 3
             stderr
# 235 "/root/mnt/basilisk/src/grid/stencils.h"
                 ,
       "%s:%d: warning: face vector '%s' should be assigned with"
       " a foreach_face() loop\n",
       loop->fname, loop->line, _attribute[s.i].name);
 }
 else if (loop->face) {
   if (_attribute[s.i].v.x.i < 0) {
     int d = 1, i = 0;
      {
       if (loop->face == d) {
  _attribute[s.i].face = 2, _attribute[s.i].v.x.i = s.i;
  _attribute[s.i].boundary[left] = _attribute[s.i].boundary[right] = 
# 246 "/root/mnt/basilisk/src/grid/stencils.h" 3 4
                                                                    ((void *)0)
# 246 "/root/mnt/basilisk/src/grid/stencils.h"
                                                                        ;





       }
       d *= 2, i++;
     }
# 243 "/root/mnt/basilisk/src/grid/stencils.h"
{
       if (loop->face == d) {
  _attribute[s.i].face = 2, _attribute[s.i].v.y.i = s.i;
  _attribute[s.i].boundary[bottom] = _attribute[s.i].boundary[top] = 
# 246 "/root/mnt/basilisk/src/grid/stencils.h" 3 4
                                                                    ((void *)0)
# 246 "/root/mnt/basilisk/src/grid/stencils.h"
                                                                        ;





       }
       d *= 2, i++;
     }
     if (!_attribute[s.i].face && loop->first)
       fprintf (
# 256 "/root/mnt/basilisk/src/grid/stencils.h" 3
               stderr
# 256 "/root/mnt/basilisk/src/grid/stencils.h"
                   ,
         "%s:%d: warning: scalar '%s' should be assigned with "
         "a foreach_face(x|y|z) loop\n",
         loop->fname, loop->line, _attribute[s.i].name);
   }
   else {
     char * name = 
# 262 "/root/mnt/basilisk/src/grid/stencils.h" 3 4
                  ((void *)0)
# 262 "/root/mnt/basilisk/src/grid/stencils.h"
                      ;
     if (_attribute[s.i].name) {
       name = strdup(_attribute[s.i].name);
       char * s = name + strlen(name) - 1;
       while (s != name && *s != '.') s--;
       if (s != name) *s = '\0';
     }
     struct { int x, y, z; } input, output;
     vector v = _attribute[s.i].v;


       input.x = _attribute[v.x.i].input, output.x = _attribute[v.x.i].output;
# 273 "/root/mnt/basilisk/src/grid/stencils.h"
input.y = _attribute[v.y.i].input, output.y = _attribute[v.y.i].output;

     init_face_vector (v, name);



       _attribute[v.x.i].input = input.x, _attribute[v.x.i].output = output.x;
# 279 "/root/mnt/basilisk/src/grid/stencils.h"
_attribute[v.y.i].input = input.y, _attribute[v.y.i].output = output.y;





     free(name);
   }
 }
 else if (loop->vertex) {
   
# 289 "/root/mnt/basilisk/src/grid/stencils.h" 3 4
  _Bool 
# 289 "/root/mnt/basilisk/src/grid/stencils.h"
       vertex = 
# 289 "/root/mnt/basilisk/src/grid/stencils.h" 3 4
                1
# 289 "/root/mnt/basilisk/src/grid/stencils.h"
                    ;

     if (_attribute[s.i].d.x != -1)
       vertex = 
# 292 "/root/mnt/basilisk/src/grid/stencils.h" 3 4
               0
# 292 "/root/mnt/basilisk/src/grid/stencils.h"
                    ;
# 291 "/root/mnt/basilisk/src/grid/stencils.h"
if (_attribute[s.i].d.y != -1)
       vertex = 
# 292 "/root/mnt/basilisk/src/grid/stencils.h" 3 4
               0
# 292 "/root/mnt/basilisk/src/grid/stencils.h"
                    ;
   if (!vertex) {
     char * name = 
# 294 "/root/mnt/basilisk/src/grid/stencils.h" 3 4
                  ((void *)0)
# 294 "/root/mnt/basilisk/src/grid/stencils.h"
                      ;
     if (_attribute[s.i].name) name = strdup(_attribute[s.i].name);
     init_vertex_scalar (s, name);

       _attribute[s.i].v.x.i = -1;
# 298 "/root/mnt/basilisk/src/grid/stencils.h"
_attribute[s.i].v.y.i = -1;




     free(name);
   }
 }





 dirty = list_append (dirty, s);
 {scalar*_i=(scalar*)( baseblock);if(_i)for(scalar d=*_i;(&d)->i>=0;d=*++_i){
   if (scalar_depends_from (d, s))
     dirty = list_append (dirty, d);}}
      }
    }
  }}}




  if (flux) {
# 335 "/root/mnt/basilisk/src/grid/stencils.h"
    boundary_face (listf);

      free(listf.x);
# 337 "/root/mnt/basilisk/src/grid/stencils.h"
free(listf.y);
  }




  if (listc) {






    boundary_internal (listc, loop->fname, loop->line);
    free(listc);
  }





  if (dirty) {






    {scalar*_i=(scalar*)( dirty);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      _attribute[s.i].dirty = 
# 366 "/root/mnt/basilisk/src/grid/stencils.h" 3 4
                             1
# 366 "/root/mnt/basilisk/src/grid/stencils.h"
                                 ;}}
    free(dirty);
  }
}
# 1445 "/root/mnt/basilisk/src/common.h"
# 14 "rising-cpp.c"
# 1 "grid/quadtree.h"
# 1 "/root/mnt/basilisk/src/grid/quadtree.h"
# 1 "grid/tree.h"
# 1 "/root/mnt/basilisk/src/grid/tree.h"
# 1 "grid/mempool.h"
# 1 "/root/mnt/basilisk/src/grid/mempool.h"





typedef struct _Pool Pool;

struct _Pool {
  Pool * next;
};

typedef struct {
  char * first, * lastb;
  size_t size;
  size_t poolsize;
  Pool * pool, * last;
} Mempool;

typedef struct {
  char * next;
} FreeBlock;

Mempool * mempool_new (size_t poolsize, size_t size)
{

  if (!(poolsize % 8 == 0)) qassert ("/root/mnt/basilisk/src/grid/mempool.h", 26, "poolsize % 8 == 0");
  if (!(size >= sizeof(FreeBlock))) qassert ("/root/mnt/basilisk/src/grid/mempool.h", 27, "size >= sizeof(FreeBlock)");


  poolsize = ((1 << 20) < (poolsize + sizeof(Pool)) ? (1 << 20) : (poolsize + sizeof(Pool)));
  Mempool * m = ((Mempool *) calloc(1,sizeof(Mempool)));
  m->poolsize = poolsize;
  m->size = size;
  return m;
}

void mempool_destroy (Mempool * m)
{
  Pool * p = m->pool;
  while (p) {
    Pool * next = p->next;
    free(p);
    p = next;
  }
  free(m);
}

void * mempool_alloc (Mempool * m)
{
  if (!m->first) {

    Pool * p = (Pool *) malloc(m->poolsize);
    p->next = 
# 53 "/root/mnt/basilisk/src/grid/mempool.h" 3 4
             ((void *)0)
# 53 "/root/mnt/basilisk/src/grid/mempool.h"
                 ;
    if (m->last)
      m->last->next = p;
    else
      m->pool = p;
    m->last = p;
    m->first = m->lastb = ((char *)m->last) + sizeof(Pool);
    FreeBlock * b = (FreeBlock *) m->first;
    b->next = 
# 61 "/root/mnt/basilisk/src/grid/mempool.h" 3 4
             ((void *)0)
# 61 "/root/mnt/basilisk/src/grid/mempool.h"
                 ;
  }
  void * ret = m->first;
  FreeBlock * b = (FreeBlock *) ret;
  char * next = b->next;
  if (!next) {
    m->lastb += m->size;
    next = m->lastb;
    if (next + m->size > ((char *) m->last) + m->poolsize)
      next = 
# 70 "/root/mnt/basilisk/src/grid/mempool.h" 3 4
            ((void *)0)
# 70 "/root/mnt/basilisk/src/grid/mempool.h"
                ;
    else {
      FreeBlock * b = (FreeBlock *) next;
      b->next = 
# 73 "/root/mnt/basilisk/src/grid/mempool.h" 3 4
               ((void *)0)
# 73 "/root/mnt/basilisk/src/grid/mempool.h"
                   ;
    }
  }
  m->first = next;





  return ret;
}

void * mempool_alloc0 (Mempool * m)
{
  void * ret = mempool_alloc (m);
  memset (ret, 0, m->size);
  return ret;
}

void mempool_free (Mempool * m, void * p)
{





  FreeBlock * b = (FreeBlock *) p;
  b->next = m->first;
  m->first = (char *) p;
}
# 2 "/root/mnt/basilisk/src/grid/tree.h"
# 1 "grid/memindex/range.h"
# 1 "/root/mnt/basilisk/src/grid/memindex/range.h"
# 15 "/root/mnt/basilisk/src/grid/memindex/range.h"
typedef struct {
  void ** p;
  int size;
} Memalloc;

typedef struct {
  int start, end;
} Memrange;
# 34 "/root/mnt/basilisk/src/grid/memindex/range.h"
void memrange_alloc (Memrange * r, Memalloc * mem, int i)
{
  if (r->start == r->end) {
    r->start = i;
    r->end = i + 1;
    for (Memalloc * m = mem; m->p; m++) {
      *m->p = calloc(1,m->size);
      *m->p = (char *)(*m->p) - i*m->size;
    }
  }
  else if (i >= r->end) {
    for (Memalloc * m = mem; m->p; m++) {
      *m->p = realloc((char *)(*m->p) + r->start*m->size,m->size*(i + 1 - r->start))
                                                               ;
      *m->p = (char *)(*m->p) - r->start*m->size;
      memset ((char *)(*m->p) + r->end*m->size, 0, (i - r->end + 1)*m->size);
    }
    r->end = i + 1;
  }
  else if (i < r->start) {
    for (Memalloc * m = mem; m->p; m++) {
      *m->p = realloc((char *)(*m->p) + r->start*m->size,m->size*(r->end - i));
      memmove ((char *)(*m->p) + (r->start - i)*m->size, *m->p,
        m->size*(r->end - r->start));
      memset ((char *)(*m->p), 0, (r->start - i)*m->size);
      *m->p = (char *)(*m->p) - i*m->size;
    }
    r->start = i;
  }
}
# 73 "/root/mnt/basilisk/src/grid/memindex/range.h"

# 73 "/root/mnt/basilisk/src/grid/memindex/range.h" 3 4
_Bool 
# 73 "/root/mnt/basilisk/src/grid/memindex/range.h"
    memrange_free (Memrange * r, Memalloc * mem, int i)
{
  if (i == r->start) {
    if (i == r->end - 1) {
      for (Memalloc * m = mem; m->p; m++) {
 free((char *)(*m->p) + r->start*m->size);
 *m->p = 
# 79 "/root/mnt/basilisk/src/grid/memindex/range.h" 3 4
        ((void *)0)
# 79 "/root/mnt/basilisk/src/grid/memindex/range.h"
            ;
      }
      r->start = r->end = 0;
      return 
# 82 "/root/mnt/basilisk/src/grid/memindex/range.h" 3 4
            1
# 82 "/root/mnt/basilisk/src/grid/memindex/range.h"
                ;
    }
    else {
      for (i = i + 1; i < r->end &&
      !*(void **)((char *)(*mem->p) + i*mem->size); i++);
      for (Memalloc * m = mem; m->p; m++) {
 memmove ((char *)(*m->p) + r->start*m->size,
   (char *)(*m->p) + i*m->size, m->size*(r->end - i));
 *m->p = realloc((char *)(*m->p) + r->start*m->size,m->size*(r->end - i))
                                                    ;
 *m->p = (char *)(*m->p) - i*m->size;
      }
      r->start = i;
    }
  }
  else if (i == r->end - 1) {
    for (i = i - 1; i >= r->start &&
    !*(void **)((char *)(*mem->p) + i*mem->size); i--);
    r->end = i + 1;
    for (Memalloc * m = mem; m->p; m++) {
      *m->p = realloc((char *)(*m->p) + r->start*m->size,m->size*(r->end - r->start))
                                                                ;
      *m->p = (char *)(*m->p) - r->start*m->size;
    }
  }
  else {
    if (!(i > r->start && i < r->end)) qassert ("/root/mnt/basilisk/src/grid/memindex/range.h", 108, "i > r->start && i < r->end");
    for (Memalloc * m = mem; m->p; m++)
      memset ((char *)(*m->p) + i*m->size, 0, m->size);
  }
  return 
# 112 "/root/mnt/basilisk/src/grid/memindex/range.h" 3 4
        0
# 112 "/root/mnt/basilisk/src/grid/memindex/range.h"
             ;
}







struct _Memindex {
  Memrange r1;

  Memrange * r2;







  char *** b;



};
# 171 "/root/mnt/basilisk/src/grid/memindex/range.h"
struct _Memindex * mem_new (int len)
{
  struct _Memindex * m = calloc(1,sizeof (struct _Memindex));
  return m;
}





void mem_destroy (struct _Memindex * m, int len)
{

  for (int i = m->r1.start; i < m->r1.end; i++)
    if (m->b[i]) {






      free(m->b[i] + m->r2[i].start);
    }
  if (m->b) {
    free(m->r2 + m->r1.start);



  }

  if (m->b)
    free(m->b + m->r1.start);
  free(m);
}
# 218 "/root/mnt/basilisk/src/grid/memindex/range.h"
void mem_assign (struct _Memindex * m, int i, int j, int len, void * b)
{
  Memalloc mem[] = {{(void **)&m->b, sizeof(char **)},
      {(void **)&m->r2, sizeof(Memrange)},
      {
# 222 "/root/mnt/basilisk/src/grid/memindex/range.h" 3 4
      ((void *)0)
# 222 "/root/mnt/basilisk/src/grid/memindex/range.h"
          }};
  memrange_alloc (&m->r1, mem, i);
  Memalloc mem1[] = {{(void **)&m->b[i], sizeof(char *)},
       {
# 225 "/root/mnt/basilisk/src/grid/memindex/range.h" 3 4
       ((void *)0)
# 225 "/root/mnt/basilisk/src/grid/memindex/range.h"
           }};
  memrange_alloc (&m->r2[i], mem1, j);
  ((m)->b[i][j]) = b;
}
# 259 "/root/mnt/basilisk/src/grid/memindex/range.h"
void mem_free (struct _Memindex * m, int i, int j, int len)
{
  Memalloc mem[] = {{(void **)&m->b[i], sizeof(char *)},
      {
# 262 "/root/mnt/basilisk/src/grid/memindex/range.h" 3 4
      ((void *)0)
# 262 "/root/mnt/basilisk/src/grid/memindex/range.h"
          }};
  if (memrange_free (&m->r2[i], mem, j)) {
    Memalloc mem[] = {{(void **)&m->b, sizeof(char **)},
        {(void **)&m->r2, sizeof(Memrange)},
        {
# 266 "/root/mnt/basilisk/src/grid/memindex/range.h" 3 4
        ((void *)0)
# 266 "/root/mnt/basilisk/src/grid/memindex/range.h"
            }};
    memrange_free (&m->r1, mem, i);
  }
}
# 305 "/root/mnt/basilisk/src/grid/memindex/range.h"
# 315 "/root/mnt/basilisk/src/grid/memindex/range.h"
# 7 "/root/mnt/basilisk/src/grid/tree.h"
# 24 "/root/mnt/basilisk/src/grid/tree.h"
typedef struct {
  unsigned short flags;

  unsigned short neighbors;
  int pid;
} Cell;

enum {
  active = 1 << 0,
  leaf = 1 << 1,
  border = 1 << 2,
  vertex = 1 << 3,
  user = 4,

  face_x = 1 << 0

  , face_y = 1 << 1




};
# 56 "/root/mnt/basilisk/src/grid/tree.h"
typedef struct {
  int i;

  int j;




} IndexLevel;

typedef struct {
  IndexLevel * p;
  int n, nm;
} CacheLevel;

typedef struct {
  int i;

  int j;




  int level, flags;
} Index;

typedef struct {
  Index * p;
  int n, nm;
} Cache;



typedef struct {
  struct _Memindex * m;
  Mempool * pool;
  long nc;
  int len;
} Layer;

static size_t _size (size_t depth)
{
  return (1 << depth) + 2*2;
}

static size_t poolsize (size_t depth, size_t size)
{




  return ((_size(depth))*(_size(depth)))*size;



}

static Layer * new_layer (int depth)
{
  Layer * l = ((Layer *) malloc((1)*sizeof(Layer)));
  l->len = _size (depth);
  if (depth == 0)
    l->pool = 
# 118 "/root/mnt/basilisk/src/grid/tree.h" 3 4
             ((void *)0)
# 118 "/root/mnt/basilisk/src/grid/tree.h"
                 ;
  else {
    size_t size = sizeof(Cell) + datasize;


    l->pool = mempool_new (poolsize (depth, size), (1 << 2)*size);
  }
  l->m = mem_new (l->len);
  l->nc = 0;
  return l;
}

static void destroy_layer (Layer * l)
{
  if (l->pool)
    mempool_destroy (l->pool);
  mem_destroy (l->m, l->len);
  free(l);
}



typedef struct {
  Grid g;
  Layer ** L;

  Cache leaves;
  Cache faces;
  Cache vertices;
  Cache refined;
  CacheLevel * active;
  CacheLevel * prolongation;
  CacheLevel * boundary;

  CacheLevel * restriction;

  
# 154 "/root/mnt/basilisk/src/grid/tree.h" 3 4
 _Bool 
# 154 "/root/mnt/basilisk/src/grid/tree.h"
      dirty;
} Tree;



struct _Point {

  int i;

  int j;




  int level;






};
static Point last_point;



static void cache_level_append (CacheLevel * c, Point p)
{
  if (c->n >= c->nm) {
    c->nm += 128;
    c->p = (IndexLevel *) realloc(c->p,(c->nm)*sizeof(IndexLevel));
  }
  c->p[c->n].i = p.i;

  c->p[c->n].j = p.j;




  c->n++;
}

static void cache_level_shrink (CacheLevel * c)
{
  if (c->nm > (c->n/128 + 1)*128) {
    c->nm = (c->n/128 + 1)*128;
    if (!(c->nm > c->n)) qassert ("/root/mnt/basilisk/src/grid/tree.h", 200, "c->nm > c->n");
    c->p = (IndexLevel *) realloc(c->p,sizeof (Index)*c->nm);
  }
}

static void cache_append (Cache * c, Point p, unsigned short flags)
{
  if (c->n >= c->nm) {
    c->nm += 128;
    c->p = (Index *) realloc(c->p,(c->nm)*sizeof(Index));
  }
  c->p[c->n].i = p.i;

  c->p[c->n].j = p.j;




  c->p[c->n].level = p.level;
  c->p[c->n].flags = flags;
  c->n++;
}

void cache_shrink (Cache * c)
{
  cache_level_shrink ((CacheLevel *)c);
}
# 243 "/root/mnt/basilisk/src/grid/tree.h"
# 245 "/root/mnt/basilisk/src/grid/tree.h"
# 248 "/root/mnt/basilisk/src/grid/tree.h"
# 251 "/root/mnt/basilisk/src/grid/tree.h"
# 256 "/root/mnt/basilisk/src/grid/tree.h"
# 259 "/root/mnt/basilisk/src/grid/tree.h"
# 284 "/root/mnt/basilisk/src/grid/tree.h"
# 305 "/root/mnt/basilisk/src/grid/tree.h"
# 341 "/root/mnt/basilisk/src/grid/tree.h"
# 1 "grid/foreach_cell.h"
# 1 "/root/mnt/basilisk/src/grid/foreach_cell.h"
# 66 "/root/mnt/basilisk/src/grid/foreach_cell.h"
# 89 "/root/mnt/basilisk/src/grid/foreach_cell.h"
# 123 "/root/mnt/basilisk/src/grid/foreach_cell.h"
# 134 "/root/mnt/basilisk/src/grid/foreach_cell.h"
# 147 "/root/mnt/basilisk/src/grid/foreach_cell.h"
# 244 "/root/mnt/basilisk/src/grid/foreach_cell.h"
# 250 "/root/mnt/basilisk/src/grid/foreach_cell.h"
# 262 "/root/mnt/basilisk/src/grid/foreach_cell.h"
# 275 "/root/mnt/basilisk/src/grid/foreach_cell.h"
# 281 "/root/mnt/basilisk/src/grid/foreach_cell.h"
# 344 "/root/mnt/basilisk/src/grid/tree.h"
# 361 "/root/mnt/basilisk/src/grid/tree.h"
# 369 "/root/mnt/basilisk/src/grid/tree.h"
# 376 "/root/mnt/basilisk/src/grid/tree.h"
# 407 "/root/mnt/basilisk/src/grid/tree.h"
# 416 "/root/mnt/basilisk/src/grid/tree.h"
# 442 "/root/mnt/basilisk/src/grid/tree.h"
# 468 "/root/mnt/basilisk/src/grid/tree.h"
# 476 "/root/mnt/basilisk/src/grid/tree.h"
# 499 "/root/mnt/basilisk/src/grid/tree.h"
# 513 "/root/mnt/basilisk/src/grid/tree.h"
# 520 "/root/mnt/basilisk/src/grid/tree.h"
# 1 "grid/neighbors.h"
# 1 "/root/mnt/basilisk/src/grid/neighbors.h"
# 17 "/root/mnt/basilisk/src/grid/neighbors.h"
# 25 "/root/mnt/basilisk/src/grid/neighbors.h"
# 31 "/root/mnt/basilisk/src/grid/neighbors.h"
# 524 "/root/mnt/basilisk/src/grid/tree.h"

static inline 
# 525 "/root/mnt/basilisk/src/grid/tree.h" 3 4
             _Bool 
# 525 "/root/mnt/basilisk/src/grid/tree.h"
                  has_local_children (Point point)
{int ig=0;(void)(ig);int jg=0;(void)(jg);; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  {{ int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    if ((((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).pid == 0))
      return 
# 529 "/root/mnt/basilisk/src/grid/tree.h" 3 4
            1
# 529 "/root/mnt/basilisk/src/grid/tree.h"
                ;} } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}}
  return 
# 530 "/root/mnt/basilisk/src/grid/tree.h" 3 4
        0
# 530 "/root/mnt/basilisk/src/grid/tree.h"
             ;
}

static inline void cache_append_face (Point point, unsigned short flags)
{int ig=0;(void)(ig);int jg=0;(void)(jg);; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  Tree * q = ((Tree *)grid);
  cache_append (&q->faces, point, flags);

  if (!(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & vertex)) {
    cache_append (&q->vertices, point, 0);
    (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).flags |= vertex;
  }

    if ((flags & face_y) && !(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ))))).flags & vertex)) {
      cache_append (&q->vertices, (Point) { point.i + 1, point.j + 0, point.level }, 0);
      (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) )))).flags |= vertex;
    }
# 543 "/root/mnt/basilisk/src/grid/tree.h"
if ((flags & face_x) && !(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ))))).flags & vertex)) {
      cache_append (&q->vertices, (Point) { point.i + 0, point.j + 1, point.level }, 0);
      (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) )))).flags |= vertex;
    }
# 557 "/root/mnt/basilisk/src/grid/tree.h"
}



static void update_cache_f (void)
{
  Tree * q = ((Tree *)grid);

  {{ { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < q->vertices.n; _k++) { point.i = q->vertices.p[_k].i; point.j = q->vertices.p[_k].j; point.level = q->vertices.p[_k].level; _flags = q->vertices.p[_k].flags; ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    if (level <= (grid->depth) && (((point.i+0) >= (((Tree *)grid)->L[point.level]->m)->r1.start && (point.i+0) < (((Tree *)grid)->L[point.level]->m->r1.end) && (((Tree *)grid)->L[point.level]->m)->b[point.i+0] && (point.j+0) >= (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].start && (point.j+0) < (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].end && (((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))
      (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).flags &= ~vertex;} } };}


  q->leaves.n = q->faces.n = q->vertices.n = 0;
  for (int l = 0; l <= (grid->depth); l++)
    q->active[l].n = q->prolongation[l].n =
      q->boundary[l].n = q->restriction[l].n = 0;

  const unsigned short fboundary = 1 << user;
  {{ Point root = {2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point = {0}; struct { int l, i, j, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; }; if (!(((point.i+0) >= (((Tree *)grid)->L[point.level]->m)->r1.start && (point.i+0) < (((Tree *)grid)->L[point.level]->m->r1.end) && (((Tree *)grid)->L[point.level]->m)->b[point.i+0] && (point.j+0) >= (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].start && (point.j+0) < (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].end && (((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )) continue; switch (stage) { case 0: { ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {



    if ((((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).pid == 0) && (((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & active)) {


      cache_level_append (&q->active[level], point);
    }
# 601 "/root/mnt/basilisk/src/grid/tree.h"
    if (!((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).pid < 0)) {

      {{ int _nn = 2 + 0 ? 2 + 0 : 2; int _i = point.i, _j = point.j; for (int _k = - _nn; _k <= _nn; _k++) { point.i = _i + _k; for (int _l = - _nn; _l <= _nn; _l++) { point.j = _j + _l; ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
 if ((((point.i+0) >= (((Tree *)grid)->L[point.level]->m)->r1.start && (point.i+0) < (((Tree *)grid)->L[point.level]->m->r1.end) && (((Tree *)grid)->L[point.level]->m)->b[point.i+0] && (point.j+0) >= (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].start && (point.j+0) < (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].end && (((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) && ((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).pid < 0) && !((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).flags & fboundary)) {
   cache_level_append (&q->boundary[level], point);
   (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).flags |= fboundary;
 }} } point.i = _i; point.j = _j;}}
    }

    else if (level > 0 && (((*((Cell *)((((((Tree *)grid)->L[point.level-1]->m)->b[(point.i+2)/2+0][(point.j+2)/2+0]) ))))).pid == 0))
      cache_level_append (&q->restriction[level], point);

    if ((((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & leaf)) {
      if ((((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).pid == 0)) {
 cache_append (&q->leaves, point, 0);

 unsigned short flags = 0;

   if (((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) )))).pid < 0) || (!(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ))))).flags & leaf) && !(*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) )))).neighbors && (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) )))).pid >= 0) ||
       (((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ))))).flags & leaf))
     flags |= face_x;
# 619 "/root/mnt/basilisk/src/grid/tree.h"
if (((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) )))).pid < 0) || (!(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ))))).flags & leaf) && !(*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) )))).neighbors && (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) )))).pid >= 0) ||
       (((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ))))).flags & leaf))
     flags |= face_y;
 if (flags)
   cache_append (&q->faces, point, flags);

   if (((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) )))).pid < 0) || (!(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ))))).flags & leaf) && !(*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) )))).neighbors && (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) )))).pid >= 0) ||
       (!(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ))))).pid == 0) && (((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ))))).flags & leaf)))
     cache_append (&q->faces, (Point) { point.i + 1, point.j + 0, point.level }, face_x);
# 625 "/root/mnt/basilisk/src/grid/tree.h"
if (((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) )))).pid < 0) || (!(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ))))).flags & leaf) && !(*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) )))).neighbors && (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) )))).pid >= 0) ||
       (!(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ))))).pid == 0) && (((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ))))).flags & leaf)))
     cache_append (&q->faces, (Point) { point.i + 0, point.j + 1, point.level }, face_y);

 for (int i = 0; i <= 1; i++)

   for (int j = 0; j <= 1; j++)




       if (!(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+j]) ))))).flags & vertex)) {
  cache_append (&q->vertices, (Point) { point.i + i, point.j + j, point.level }, 0);
  (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+j]) )))).flags |= vertex;
       }

        if ((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).neighbors > 0)
   cache_level_append (&q->prolongation[level], point);
      }
      else if (!((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).pid < 0) || (((*((Cell *)((((((Tree *)grid)->L[point.level-1]->m)->b[(point.i+2)/2+0][(point.j+2)/2+0]) ))))).pid == 0)) {

 unsigned short flags = 0;

   if ((((point.i+-1) >= (((Tree *)grid)->L[point.level]->m)->r1.start && (point.i+-1) < (((Tree *)grid)->L[point.level]->m->r1.end) && (((Tree *)grid)->L[point.level]->m)->b[point.i+-1] && (point.j+0) >= (((Tree *)grid)->L[point.level]->m)->r2[point.i+-1].start && (point.j+0) < (((Tree *)grid)->L[point.level]->m)->r2[point.i+-1].end && (((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) &&
       (((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ))))).pid == 0) && (!(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ))))).flags & leaf) && !(*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) )))).neighbors && (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) )))).pid >= 0))
     flags |= face_x;
# 648 "/root/mnt/basilisk/src/grid/tree.h"
if ((((point.i+0) >= (((Tree *)grid)->L[point.level]->m)->r1.start && (point.i+0) < (((Tree *)grid)->L[point.level]->m->r1.end) && (((Tree *)grid)->L[point.level]->m)->b[point.i+0] && (point.j+-1) >= (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].start && (point.j+-1) < (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].end && (((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) &&
       (((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ))))).pid == 0) && (!(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ))))).flags & leaf) && !(*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) )))).neighbors && (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) )))).pid >= 0))
     flags |= face_y;
 if (flags)
   cache_append_face (point, flags);

   if ((((point.i+1) >= (((Tree *)grid)->L[point.level]->m)->r1.start && (point.i+1) < (((Tree *)grid)->L[point.level]->m->r1.end) && (((Tree *)grid)->L[point.level]->m)->b[point.i+1] && (point.j+0) >= (((Tree *)grid)->L[point.level]->m)->r2[point.i+1].start && (point.j+0) < (((Tree *)grid)->L[point.level]->m)->r2[point.i+1].end && (((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) && (((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ))))).pid == 0) &&
       (!(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ))))).flags & leaf) && !(*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) )))).neighbors && (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) )))).pid >= 0))
     cache_append_face ((Point) { point.i + 1, point.j + 0, point.level }, face_x);
# 654 "/root/mnt/basilisk/src/grid/tree.h"
if ((((point.i+0) >= (((Tree *)grid)->L[point.level]->m)->r1.start && (point.i+0) < (((Tree *)grid)->L[point.level]->m->r1.end) && (((Tree *)grid)->L[point.level]->m)->b[point.i+0] && (point.j+1) >= (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].start && (point.j+1) < (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].end && (((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) && (((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ))))).pid == 0) &&
       (!(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ))))).flags & leaf) && !(*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) )))).neighbors && (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) )))).pid >= 0))
     cache_append_face ((Point) { point.i + 0, point.j + 1, point.level }, face_y);
      }

      continue;

    }
  }if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; } } } };}


  cache_shrink (&q->leaves);
  cache_shrink (&q->faces);
  cache_shrink (&q->vertices);
  for (int l = 0; l <= (grid->depth); l++) {
    cache_level_shrink (&q->active[l]);
    cache_level_shrink (&q->prolongation[l]);
    cache_level_shrink (&q->boundary[l]);
    cache_level_shrink (&q->restriction[l]);
}

  q->dirty = 
# 675 "/root/mnt/basilisk/src/grid/tree.h" 3 4
            0
# 675 "/root/mnt/basilisk/src/grid/tree.h"
                 ;


  for (int l = (grid->depth); l >= 0; l--)
    {{ if (l <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _boundary = ((Tree *)grid)->boundary[l]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.level = l; int _k; for (_k = 0; _k < _boundary.n; _k++) { point.i = _boundary.p[_k].i; point.j = _boundary.p[_k].j; ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
      (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).flags &= ~fboundary;} } }; }};}



  grid->n = q->leaves.n;


  grid->tn = grid->n;
  grid->maxdepth = grid->depth;

}
# 716 "/root/mnt/basilisk/src/grid/tree.h"
# 742 "/root/mnt/basilisk/src/grid/tree.h"
# 734 "/root/mnt/basilisk/src/grid/tree.h"
# 739 "/root/mnt/basilisk/src/grid/tree.h"
# 749 "/root/mnt/basilisk/src/grid/tree.h"
# 757 "/root/mnt/basilisk/src/grid/tree.h"
void reset (void * alist, double val)
{
  scalar * list = (scalar *) alist;
  Tree * q = ((Tree *)grid);

  for (int l = 0; l <= (grid->depth); l++) {
    Layer * L = q->L[l];
    {{ Point point = {0}; for (point.i = ((Period.x*2) > ((L->m)->r1.start) ? (Period.x*2) : ((L->m)->r1.start)); point.i < ((L->len - Period.x*2) < ((L->m)->r1.end) ? (L->len - Period.x*2) : ((L->m)->r1.end)); point.i += 1) if ((L->m)->b[point.i]) for (point.j = ((Period.y*2) > ((L->m)->r2[point.i].start) ? (Period.y*2) : ((L->m)->r2[point.i].start)); point.j < ((L->len - Period.y*2) < ((L->m)->r2[point.i].end) ? (L->len - Period.y*2) : ((L->m)->r2[point.i].end)); point.j += 1) if ((L->m)->b[point.i][point.j]) { {
      point.level = l;
      {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
 if (!((s).i >= 65536))
   for (int b = 0; b < _attribute[s.i].block; b++)
     ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[s.i + b] = val;
      }}}
    }}};}
  }
}

static CacheLevel * cache_level_resize (CacheLevel * name, int a)
{
  for (int i = 0; i <= (grid->depth) - a; i++)
    free(name[i].p);
  free(name);
  return ((CacheLevel *) calloc((grid->depth) + 1,sizeof(CacheLevel)));
}

static void update_depth (int inc)
{
  Tree * q = ((Tree *)grid);
  grid->depth += inc;
  q->L = &(q->L[-1]);
  q->L = (Layer * *) realloc(q->L,(grid->depth + 2)*sizeof(Layer *));
  q->L = &(q->L[1]);
  if (inc > 0)
    q->L[grid->depth] = new_layer (grid->depth);
  q->active = cache_level_resize (q->active, inc);
  q->prolongation = cache_level_resize (q->prolongation, inc);
  q->boundary = cache_level_resize (q->boundary, inc);
  q->restriction = cache_level_resize (q->restriction, inc);
}
# 823 "/root/mnt/basilisk/src/grid/tree.h"
typedef void (* PeriodicFunction) (struct _Memindex *, int, int, int, void *);

static void periodic_function (struct _Memindex * m, int i, int j, int len, void * b,
          PeriodicFunction f)
{
  f(m, i, j, len, b);
  if (Period.x) {
    int nl = len - 2*2;
    for (int l = - 1; l <= 1; l += 2)
      for (int n = i + l*nl; n >= 0 && n < len; n += l*nl)
 f(m, n, j, len, b);
    if (Period.y)
      for (int l = - 1; l <= 1; l += 2)
 for (int n = j + l*nl; n >= 0 && n < len; n += l*nl) {
   f(m, i, n, len, b);
   for (int o = - 1; o <= 1; o += 2)
     for (int p = i + o*nl; p >= 0 && p < len; p += o*nl)
       f(m, p, n, len, b);
 }
  }
  else if (Period.y) {
    int nl = len - 2*2;
    for (int l = - 1; l <= 1; l += 2)
      for (int n = j + l*nl; n >= 0 && n < len; n += l*nl)
 f(m, i, n, len, b);
  }
}

static void assign_periodic (struct _Memindex * m, int i, int j, int len, void * b)
{
  periodic_function (m, i, j, len, b, mem_assign);
}

static void free_periodic (struct _Memindex * m, int i, int j, int len)
{
  periodic_function (m, i, j, len, 
# 858 "/root/mnt/basilisk/src/grid/tree.h" 3 4
                                  ((void *)0)
# 858 "/root/mnt/basilisk/src/grid/tree.h"
                                      , (PeriodicFunction) mem_free);
}
# 938 "/root/mnt/basilisk/src/grid/tree.h"
static void alloc_children (Point point)
{int ig=0;(void)(ig);int jg=0;(void)(jg);; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  if (point.level == grid->depth)
    update_depth (+1);
  else if ((level < (grid->depth) && ((2*point.i-2 +0) >= (((Tree *)grid)->L[point.level+1]->m)->r1.start && (2*point.i-2 +0) < (((Tree *)grid)->L[point.level+1]->m->r1.end) && (((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +0] && (2*point.j-2 +0) >= (((Tree *)grid)->L[point.level+1]->m)->r2[2*point.i-2 +0].start && (2*point.j-2 +0) < (((Tree *)grid)->L[point.level+1]->m)->r2[2*point.i-2 +0].end && (((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +0][2*point.j-2 +0]) ))
    return;


  Layer * L = ((Tree *)grid)->L[point.level + 1];
  L->nc++;
  size_t len = sizeof(Cell) + datasize;
  char * b = (char *) mempool_alloc0 (L->pool);
  int i = 2*point.i - 2;
  for (int k = 0; k < 2; k++, i++) {




    int j = 2*point.j - 2;
    for (int l = 0; l < 2; l++, j++) {
      assign_periodic (L->m, i, j, L->len, b);
      b += len;
    }
# 971 "/root/mnt/basilisk/src/grid/tree.h"
  }

  int pid = (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).pid;
  {{ int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
    (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).pid = pid;




  }} } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}}
}
# 1000 "/root/mnt/basilisk/src/grid/tree.h"
static void free_children (Point point)
{int ig=0;(void)(ig);int jg=0;(void)(jg);; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;

  Layer * L = ((Tree *)grid)->L[point.level + 1];
  int i = 2*point.i - 2, j = 2*point.j - 2;
  if (!(((L->m)->b[i][j]))) qassert ("/root/mnt/basilisk/src/grid/tree.h", 1005, "mem_data (L->m,i,j)");
  mempool_free (L->pool, ((L->m)->b[i][j]));
  for (int k = 0; k < 2; k++)
    for (int l = 0; l < 2; l++)
      free_periodic (L->m, i + k, j + l, L->len);
  if (--L->nc == 0) {
    destroy_layer (L);
    if (!(point.level + 1 == grid->depth)) qassert ("/root/mnt/basilisk/src/grid/tree.h", 1012, "point.level + 1 == grid->depth");
    update_depth (-1);
  }
}
# 1041 "/root/mnt/basilisk/src/grid/tree.h"
void increment_neighbors (Point point)
{int ig=0;(void)(ig);int jg=0;(void)(jg);; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  ((Tree *)grid)->dirty = 
# 1043 "/root/mnt/basilisk/src/grid/tree.h" 3 4
                         1
# 1043 "/root/mnt/basilisk/src/grid/tree.h"
                             ;
  if ((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).neighbors++ == 0)
    alloc_children (point);
  {{ int _nn = 2/2 + 0 ? 2/2 + 0 : 2; int _i = point.i, _j = point.j; for (int _k = - _nn; _k <= _nn; _k++) { point.i = _i + _k; for (int _l = - _nn; _l <= _nn; _l++) { point.j = _j + _l; ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    if ((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).neighbors++ == 0)
      alloc_children (point);} } point.i = _i; point.j = _j;}}
  (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).neighbors--;
}

void decrement_neighbors (Point point)
{int ig=0;(void)(ig);int jg=0;(void)(jg);; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  ((Tree *)grid)->dirty = 
# 1054 "/root/mnt/basilisk/src/grid/tree.h" 3 4
                         1
# 1054 "/root/mnt/basilisk/src/grid/tree.h"
                             ;
  {{ int _nn = 2/2 + 0 ? 2/2 + 0 : 2; int _i = point.i, _j = point.j; for (int _k = - _nn; _k <= _nn; _k++) { point.i = _i + _k; for (int _l = - _nn; _l <= _nn; _l++) { point.j = _j + _l; ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    if ((((point.i+0) >= (((Tree *)grid)->L[point.level]->m)->r1.start && (point.i+0) < (((Tree *)grid)->L[point.level]->m->r1.end) && (((Tree *)grid)->L[point.level]->m)->b[point.i+0] && (point.j+0) >= (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].start && (point.j+0) < (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].end && (((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )) {
      (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).neighbors--;
      if ((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).neighbors == 0)
 free_children (point);
    }} } point.i = _i; point.j = _j;}}
  if ((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).neighbors) {
    int pid = (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).pid;
    {{ int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
      (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).flags = 0;
      (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).pid = pid;
    }} } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}}
  }
}

void realloc_scalar (int size)
{

  Tree * q = ((Tree *)grid);
  size_t oldlen = sizeof(Cell) + datasize;
  size_t newlen = oldlen + size;
  datasize += size;

  Layer * L = q->L[0];
  {{ Point point = {0}; for (point.i = ((Period.x*2) > ((L->m)->r1.start) ? (Period.x*2) : ((L->m)->r1.start)); point.i < ((L->len - Period.x*2) < ((L->m)->r1.end) ? (L->len - Period.x*2) : ((L->m)->r1.end)); point.i += 1) if ((L->m)->b[point.i]) for (point.j = ((Period.y*2) > ((L->m)->r2[point.i].start) ? (Period.y*2) : ((L->m)->r2[point.i].start)); point.j < ((L->len - Period.y*2) < ((L->m)->r2[point.i].end) ? (L->len - Period.y*2) : ((L->m)->r2[point.i].end)); point.j += 1) if ((L->m)->b[point.i][point.j]) { {




    char * p = (char *) realloc(((L->m)->b[point.i][point.j]),newlen*sizeof(char))
                                                    ;
    assign_periodic (L->m, point.i, point.j, L->len, p);





  }}};}

  for (int l = 1; l <= (grid->depth); l++) {
    Layer * L = q->L[l];
    Mempool * oldpool = L->pool;
    L->pool = mempool_new (poolsize (l, newlen), (1 << 2)*newlen);
    {{ Point point = {0}; for (point.i = ((Period.x*2) > ((L->m)->r1.start) ? (Period.x*2) : ((L->m)->r1.start)); point.i < ((L->len - Period.x*2) < ((L->m)->r1.end) ? (L->len - Period.x*2) : ((L->m)->r1.end)); point.i += 2) if ((L->m)->b[point.i]) for (point.j = ((Period.y*2) > ((L->m)->r2[point.i].start) ? (Period.y*2) : ((L->m)->r2[point.i].start)); point.j < ((L->len - Period.y*2) < ((L->m)->r2[point.i].end) ? (L->len - Period.y*2) : ((L->m)->r2[point.i].end)); point.j += 2) if ((L->m)->b[point.i][point.j]) { {
      char * new = (char *) mempool_alloc (L->pool);







      for (int k = 0; k < 2; k++)
 for (int o = 0; o < 2; o++) {
   memcpy (new, ((L->m)->b[point.i + k][point.j + o]), oldlen);
   assign_periodic (L->m, point.i + k, point.j + o, L->len, new);
   new += newlen;
 }
# 1124 "/root/mnt/basilisk/src/grid/tree.h"
    }}};}
    mempool_destroy (oldpool);
  }
}
# 1146 "/root/mnt/basilisk/src/grid/tree.h"
static inline void no_restriction (Point point, scalar s);

static 
# 1148 "/root/mnt/basilisk/src/grid/tree.h" 3 4
      _Bool 
# 1148 "/root/mnt/basilisk/src/grid/tree.h"
           normal_neighbor (Point point, scalar * scalars, vector * vectors)
{int ig=0;(void)(ig);int jg=0;(void)(jg);; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  for (int k = 1; k <= 2; k++)
    {
      for (int i = -k; i <= k; i += 2*k)
 if (((((point.i+i) >= (((Tree *)grid)->L[point.level]->m)->r1.start && (point.i+i) < (((Tree *)grid)->L[point.level]->m->r1.end) && (((Tree *)grid)->L[point.level]->m)->b[point.i+i] && (point.j+0) >= (((Tree *)grid)->L[point.level]->m)->r2[point.i+i].start && (point.j+0) < (((Tree *)grid)->L[point.level]->m)->r2[point.i+i].end && (((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) && !((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) )))).pid < 0))) {
   Point neighbor = (Point) { point.i + i, point.j + 0, point.level };
   int id = (- (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).pid - 1);
   {scalar*_i=(scalar*)( scalars);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){

       ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] = _attribute[s.i].boundary[id](neighbor, point, s, 
# 1158 "/root/mnt/basilisk/src/grid/tree.h" 3 4
                                                                      ((void *)0)
# 1158 "/root/mnt/basilisk/src/grid/tree.h"
                                                                          );}}
   {vector*_i=(vector*)( vectors);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){
     {
       scalar vn = v.x;
       ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(v.x.i)] = _attribute[vn.i].boundary[id](neighbor, point, v.x, 
# 1162 "/root/mnt/basilisk/src/grid/tree.h" 3 4
                                                                           ((void *)0)
# 1162 "/root/mnt/basilisk/src/grid/tree.h"
                                                                               );

       scalar vt = v.y;
       ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(v.y.i)] = _attribute[vt.i].boundary[id](neighbor, point, v.y, 
# 1165 "/root/mnt/basilisk/src/grid/tree.h" 3 4
                                                                           ((void *)0)
# 1165 "/root/mnt/basilisk/src/grid/tree.h"
                                                                               );





     }}}
   return 
# 1172 "/root/mnt/basilisk/src/grid/tree.h" 3 4
         1
# 1172 "/root/mnt/basilisk/src/grid/tree.h"
             ;
 }
# 1152 "/root/mnt/basilisk/src/grid/tree.h"
for (int i = -k; i <= k; i += 2*k)
 if (((((point.i+0) >= (((Tree *)grid)->L[point.level]->m)->r1.start && (point.i+0) < (((Tree *)grid)->L[point.level]->m->r1.end) && (((Tree *)grid)->L[point.level]->m)->b[point.i+0] && (point.j+i) >= (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].start && (point.j+i) < (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].end && (((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) && !((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) )))).pid < 0))) {
   Point neighbor = (Point) { point.i + 0, point.j + i, point.level };
   int id = (- (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).pid - 1);
   {scalar*_i=(scalar*)( scalars);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){

       ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] = _attribute[s.i].boundary[id](neighbor, point, s, 
# 1158 "/root/mnt/basilisk/src/grid/tree.h" 3 4
                                                                      ((void *)0)
# 1158 "/root/mnt/basilisk/src/grid/tree.h"
                                                                          );}}
   {vector*_i=(vector*)( vectors);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){
     {
       scalar vn = v.x;
       ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(v.y.i)] = _attribute[vn.i].boundary[id](neighbor, point, v.y, 
# 1162 "/root/mnt/basilisk/src/grid/tree.h" 3 4
                                                                           ((void *)0)
# 1162 "/root/mnt/basilisk/src/grid/tree.h"
                                                                               );

       scalar vt = v.y;
       ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(v.x.i)] = _attribute[vt.i].boundary[id](neighbor, point, v.x, 
# 1165 "/root/mnt/basilisk/src/grid/tree.h" 3 4
                                                                           ((void *)0)
# 1165 "/root/mnt/basilisk/src/grid/tree.h"
                                                                               );





     }}}
   return 
# 1172 "/root/mnt/basilisk/src/grid/tree.h" 3 4
         1
# 1172 "/root/mnt/basilisk/src/grid/tree.h"
             ;
 }}
  return 
# 1174 "/root/mnt/basilisk/src/grid/tree.h" 3 4
        0
# 1174 "/root/mnt/basilisk/src/grid/tree.h"
             ;
}

static 
# 1177 "/root/mnt/basilisk/src/grid/tree.h" 3 4
      _Bool 
# 1177 "/root/mnt/basilisk/src/grid/tree.h"
           diagonal_neighbor_2D (Point point,
      scalar * scalars, vector * vectors)
{int ig=0;(void)(ig);int jg=0;(void)(jg);; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;

  for (int k = 1; k <= 2; k++)



      for (int i = -k; i <= k; i += 2*k)
 for (int j = -k; j <= k; j += 2*k)
   if ((((point.i+i) >= (((Tree *)grid)->L[point.level]->m)->r1.start && (point.i+i) < (((Tree *)grid)->L[point.level]->m->r1.end) && (((Tree *)grid)->L[point.level]->m)->b[point.i+i] && (point.j+j) >= (((Tree *)grid)->L[point.level]->m)->r2[point.i+i].start && (point.j+j) < (((Tree *)grid)->L[point.level]->m)->r2[point.i+i].end && (((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+j]) ) && ((((point.i+i) >= (((Tree *)grid)->L[point.level]->m)->r1.start && (point.i+i) < (((Tree *)grid)->L[point.level]->m->r1.end) && (((Tree *)grid)->L[point.level]->m)->b[point.i+i] && (point.j+j) >= (((Tree *)grid)->L[point.level]->m)->r2[point.i+i].start && (point.j+j) < (((Tree *)grid)->L[point.level]->m)->r2[point.i+i].end && (((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+j]) ) && !((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+j]) )))).pid < 0)) &&
       (((point.i+i) >= (((Tree *)grid)->L[point.level]->m)->r1.start && (point.i+i) < (((Tree *)grid)->L[point.level]->m->r1.end) && (((Tree *)grid)->L[point.level]->m)->b[point.i+i] && (point.j+0) >= (((Tree *)grid)->L[point.level]->m)->r2[point.i+i].start && (point.j+0) < (((Tree *)grid)->L[point.level]->m)->r2[point.i+i].end && (((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) && ((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) )))).pid < 0) &&
       (((point.i+0) >= (((Tree *)grid)->L[point.level]->m)->r1.start && (point.i+0) < (((Tree *)grid)->L[point.level]->m->r1.end) && (((Tree *)grid)->L[point.level]->m)->b[point.i+0] && (point.j+j) >= (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].start && (point.j+j) < (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].end && (((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+j]) ) && ((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+j]) )))).pid < 0)) {
     Point n = (Point) { point.i + i, point.j + j, point.level },
       n1 = (Point) { point.i + i, point.j + 0, point.level }, n2 = (Point) { point.i + 0, point.j + j, point.level };
     int id1 = (- (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) )))).pid - 1), id2 = (- (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+j]) )))).pid - 1);
     {scalar*_i=(scalar*)( scalars);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){

  ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] = (_attribute[s.i].boundary[id1](n,n1,s,
# 1195 "/root/mnt/basilisk/src/grid/tree.h" 3 4
                                                      ((void *)0)
# 1195 "/root/mnt/basilisk/src/grid/tree.h"
                                                          ) +
         _attribute[s.i].boundary[id2](n,n2,s,
# 1196 "/root/mnt/basilisk/src/grid/tree.h" 3 4
                                             ((void *)0)
# 1196 "/root/mnt/basilisk/src/grid/tree.h"
                                                 ) -
         ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+j]) ) + sizeof(Cell)))[(s.i)]);}}
     {vector*_i=(vector*)( vectors);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){
       {
  scalar vt = v.y, vn = v.x;
  ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(v.x.i)] = (_attribute[vt.i].boundary[id1](n,n1,v.x,
# 1201 "/root/mnt/basilisk/src/grid/tree.h" 3 4
                                                           ((void *)0)
# 1201 "/root/mnt/basilisk/src/grid/tree.h"
                                                               ) +
    _attribute[vn.i].boundary[id2](n,n2,v.x,
# 1202 "/root/mnt/basilisk/src/grid/tree.h" 3 4
                                           ((void *)0)
# 1202 "/root/mnt/basilisk/src/grid/tree.h"
                                               ) -
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+j]) ) + sizeof(Cell)))[(v.x.i)]);
  ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(v.y.i)] = (_attribute[vn.i].boundary[id1](n,n1,v.y,
# 1204 "/root/mnt/basilisk/src/grid/tree.h" 3 4
                                                           ((void *)0)
# 1204 "/root/mnt/basilisk/src/grid/tree.h"
                                                               ) +
    _attribute[vt.i].boundary[id2](n,n2,v.y,
# 1205 "/root/mnt/basilisk/src/grid/tree.h" 3 4
                                           ((void *)0)
# 1205 "/root/mnt/basilisk/src/grid/tree.h"
                                               ) -
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+j]) ) + sizeof(Cell)))[(v.y.i)]);






       }}}
     return 
# 1214 "/root/mnt/basilisk/src/grid/tree.h" 3 4
           1
# 1214 "/root/mnt/basilisk/src/grid/tree.h"
               ;
   }

  return 
# 1217 "/root/mnt/basilisk/src/grid/tree.h" 3 4
        0
# 1217 "/root/mnt/basilisk/src/grid/tree.h"
             ;
}

static 
# 1220 "/root/mnt/basilisk/src/grid/tree.h" 3 4
      _Bool 
# 1220 "/root/mnt/basilisk/src/grid/tree.h"
           diagonal_neighbor_3D (Point point,
      scalar * scalars, vector * vectors)
{int ig=0;(void)(ig);int jg=0;(void)(jg);; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 1266 "/root/mnt/basilisk/src/grid/tree.h"
  return 
# 1266 "/root/mnt/basilisk/src/grid/tree.h" 3 4
        0
# 1266 "/root/mnt/basilisk/src/grid/tree.h"
             ;
}



static Point tangential_neighbor_x (Point point, 
# 1271 "/root/mnt/basilisk/src/grid/tree.h" 3 4
                                                _Bool 
# 1271 "/root/mnt/basilisk/src/grid/tree.h"
                                                     * zn)
{int ig=0;(void)(ig);int jg=0;(void)(jg);; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  for (int k = 1; k <= 2; k++)
    for (int j = -k; j <= k; j += 2*k) {
      if (((((point.i+0) >= (((Tree *)grid)->L[point.level]->m)->r1.start && (point.i+0) < (((Tree *)grid)->L[point.level]->m->r1.end) && (((Tree *)grid)->L[point.level]->m)->b[point.i+0] && (point.j+j) >= (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].start && (point.j+j) < (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].end && (((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+j]) ) && !((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+j]) )))).pid < 0)) || ((((point.i+-1) >= (((Tree *)grid)->L[point.level]->m)->r1.start && (point.i+-1) < (((Tree *)grid)->L[point.level]->m->r1.end) && (((Tree *)grid)->L[point.level]->m)->b[point.i+-1] && (point.j+j) >= (((Tree *)grid)->L[point.level]->m)->r2[point.i+-1].start && (point.j+j) < (((Tree *)grid)->L[point.level]->m)->r2[point.i+-1].end && (((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+j]) ) && !((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+j]) )))).pid < 0))) {
 *zn = 
# 1276 "/root/mnt/basilisk/src/grid/tree.h" 3 4
      0
# 1276 "/root/mnt/basilisk/src/grid/tree.h"
           ;
 return (Point) { point.i + 0, point.j + j, point.level };
      }







    }
  return (Point){.level = -1};
}
# 1271 "/root/mnt/basilisk/src/grid/tree.h"
static Point tangential_neighbor_y (Point point, 
# 1271 "/root/mnt/basilisk/src/grid/tree.h" 3 4
                                                _Bool 
# 1271 "/root/mnt/basilisk/src/grid/tree.h"
                                                     * zn)
{int ig=0;(void)(ig);int jg=0;(void)(jg);; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  for (int k = 1; k <= 2; k++)
    for (int j = -k; j <= k; j += 2*k) {
      if (((((point.i+j) >= (((Tree *)grid)->L[point.level]->m)->r1.start && (point.i+j) < (((Tree *)grid)->L[point.level]->m->r1.end) && (((Tree *)grid)->L[point.level]->m)->b[point.i+j] && (point.j+0) >= (((Tree *)grid)->L[point.level]->m)->r2[point.i+j].start && (point.j+0) < (((Tree *)grid)->L[point.level]->m)->r2[point.i+j].end && (((Tree *)grid)->L[point.level]->m)->b[point.i+j][point.j+0]) ) && !((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+j][point.j+0]) )))).pid < 0)) || ((((point.i+j) >= (((Tree *)grid)->L[point.level]->m)->r1.start && (point.i+j) < (((Tree *)grid)->L[point.level]->m->r1.end) && (((Tree *)grid)->L[point.level]->m)->b[point.i+j] && (point.j+-1) >= (((Tree *)grid)->L[point.level]->m)->r2[point.i+j].start && (point.j+-1) < (((Tree *)grid)->L[point.level]->m)->r2[point.i+j].end && (((Tree *)grid)->L[point.level]->m)->b[point.i+j][point.j+-1]) ) && !((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+j][point.j+-1]) )))).pid < 0))) {
 *zn = 
# 1276 "/root/mnt/basilisk/src/grid/tree.h" 3 4
      0
# 1276 "/root/mnt/basilisk/src/grid/tree.h"
           ;
 return (Point) { point.i + j, point.j + 0, point.level };
      }







    }
  return (Point){.level = -1};
}


static inline 
# 1291 "/root/mnt/basilisk/src/grid/tree.h" 3 4
             _Bool 
# 1291 "/root/mnt/basilisk/src/grid/tree.h"
                  is_boundary_point (Point point) {int ig=0;(void)(ig);int jg=0;(void)(jg);; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  return ((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).pid < 0);
}

static void box_boundary_level (const Boundary * b, scalar * list, int l)
{
  ;
  scalar * scalars = 
# 1298 "/root/mnt/basilisk/src/grid/tree.h" 3 4
                    ((void *)0)
# 1298 "/root/mnt/basilisk/src/grid/tree.h"
                        ;
  vector * vectors = 
# 1299 "/root/mnt/basilisk/src/grid/tree.h" 3 4
                    ((void *)0)
# 1299 "/root/mnt/basilisk/src/grid/tree.h"
                        , * faces = 
# 1299 "/root/mnt/basilisk/src/grid/tree.h" 3 4
                                    ((void *)0)
# 1299 "/root/mnt/basilisk/src/grid/tree.h"
                                        ;
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (!((s).i >= 65536) && _attribute[s.i].refine != no_restriction) {
      if (_attribute[s.i].v.x.i == s.i) {
 if (_attribute[s.i].face)
   faces = vectors_add (faces, _attribute[s.i].v);
 else
   vectors = vectors_add (vectors, _attribute[s.i].v);
      }
      else if (_attribute[s.i].v.x.i < 0 && _attribute[s.i].boundary[0])
 scalars = list_add (scalars, s);
    }}}

  {{ if (l <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _boundary = ((Tree *)grid)->boundary[l]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.level = l; int _k; for (_k = 0; _k < _boundary.n; _k++) { point.i = _boundary.p[_k].i; point.j = _boundary.p[_k].j; ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
    if (!normal_neighbor (point, scalars, vectors) &&
 !diagonal_neighbor_2D (point, scalars, vectors) &&
 !diagonal_neighbor_3D (point, scalars, vectors)) {

      {scalar*_i=(scalar*)( scalars);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){

   ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] = undefined;}}
      {vector*_i=(vector*)( vectors);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){

   {
     ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(v.x.i)] = undefined;
# 1323 "/root/mnt/basilisk/src/grid/tree.h"
((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(v.y.i)] = undefined;}}}
    }
    if (faces) {
      int id = (- (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).pid - 1);

 for (int i = -1; i <= 1; i += 2) {

   if (((((point.i+i) >= (((Tree *)grid)->L[point.level]->m)->r1.start && (point.i+i) < (((Tree *)grid)->L[point.level]->m->r1.end) && (((Tree *)grid)->L[point.level]->m)->b[point.i+i] && (point.j+0) >= (((Tree *)grid)->L[point.level]->m)->r2[point.i+i].start && (point.j+0) < (((Tree *)grid)->L[point.level]->m)->r2[point.i+i].end && (((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) && !((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) )))).pid < 0))) {
     Point neighbor = (Point) { point.i + i, point.j + 0, point.level };
     {vector*_i=(vector*)( faces);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){ {
       scalar vn = v.x;
       if (_attribute[vn.i].boundary[id])

    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+(i + 1)/2][point.j+0]) ) + sizeof(Cell)))[(v.x.i)] = _attribute[vn.i].boundary[id](neighbor, point, v.x, 
# 1336 "/root/mnt/basilisk/src/grid/tree.h" 3 4
                                                                                ((void *)0)
# 1336 "/root/mnt/basilisk/src/grid/tree.h"
                                                                                    );
     }}}
   }

   else if (i == -1) {

     
# 1342 "/root/mnt/basilisk/src/grid/tree.h" 3 4
    _Bool 
# 1342 "/root/mnt/basilisk/src/grid/tree.h"
         zn;
     Point neighbor = tangential_neighbor_x (point, &zn);
     if (neighbor.level >= 0) {
       int id = is_boundary_point (neighbor) ?
  (- (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) )))).pid - 1) : (- (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).pid - 1);
       {vector*_i=(vector*)( faces);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){ {

  scalar vt = v.y;




    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(v.x.i)] = _attribute[vt.i].boundary[id](neighbor, point, v.x, 
# 1354 "/root/mnt/basilisk/src/grid/tree.h" 3 4
                                                                        ((void *)0)
# 1354 "/root/mnt/basilisk/src/grid/tree.h"
                                                                            );
       }}}
     }
     else

       {vector*_i=(vector*)( faces);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){

    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(v.x.i)] = 0.;}}
   }

 }
# 1328 "/root/mnt/basilisk/src/grid/tree.h"
for (int i = -1; i <= 1; i += 2) {

   if (((((point.i+0) >= (((Tree *)grid)->L[point.level]->m)->r1.start && (point.i+0) < (((Tree *)grid)->L[point.level]->m->r1.end) && (((Tree *)grid)->L[point.level]->m)->b[point.i+0] && (point.j+i) >= (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].start && (point.j+i) < (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].end && (((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) && !((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) )))).pid < 0))) {
     Point neighbor = (Point) { point.i + 0, point.j + i, point.level };
     {vector*_i=(vector*)( faces);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){ {
       scalar vn = v.x;
       if (_attribute[vn.i].boundary[id])

    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+(i + 1)/2]) ) + sizeof(Cell)))[(v.y.i)] = _attribute[vn.i].boundary[id](neighbor, point, v.y, 
# 1336 "/root/mnt/basilisk/src/grid/tree.h" 3 4
                                                                                ((void *)0)
# 1336 "/root/mnt/basilisk/src/grid/tree.h"
                                                                                    );
     }}}
   }

   else if (i == -1) {

     
# 1342 "/root/mnt/basilisk/src/grid/tree.h" 3 4
    _Bool 
# 1342 "/root/mnt/basilisk/src/grid/tree.h"
         zn;
     Point neighbor = tangential_neighbor_y (point, &zn);
     if (neighbor.level >= 0) {
       int id = is_boundary_point (neighbor) ?
  (- (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) )))).pid - 1) : (- (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).pid - 1);
       {vector*_i=(vector*)( faces);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){ {

  scalar vt = v.y;




    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(v.y.i)] = _attribute[vt.i].boundary[id](neighbor, point, v.y, 
# 1354 "/root/mnt/basilisk/src/grid/tree.h" 3 4
                                                                        ((void *)0)
# 1354 "/root/mnt/basilisk/src/grid/tree.h"
                                                                            );
       }}}
     }
     else

       {vector*_i=(vector*)( faces);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){

    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(v.y.i)] = 0.;}}
   }

 }
    }
  }} } }; }};}

  free(scalars);
  free(vectors);
  free(faces);
  ;
}
# 1381 "/root/mnt/basilisk/src/grid/tree.h"
static double masked_average (Point point, scalar s)
{int ig=0;(void)(ig);int jg=0;(void)(jg);; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  double sum = 0., n = 0.;
  {{ int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    if (!((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).pid < 0) && ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] != ((double)1e30))
      sum += ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)], n++;} } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}}
  return n ? sum/n : ((double)1e30);
}


static double masked_average_x (Point point, scalar s)
{int ig=0;(void)(ig);int jg=0;(void)(jg);; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  double sum = 0., n = 0.;
  {{ int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    if (child.x < 0 && (!((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).pid < 0) || !((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) )))).pid < 0)) &&
 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(s.i)] != ((double)1e30))
      sum += ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(s.i)], n++;} } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}}
  return n ? sum/n : ((double)1e30);
}
# 1391 "/root/mnt/basilisk/src/grid/tree.h"
static double masked_average_y (Point point, scalar s)
{int ig=0;(void)(ig);int jg=0;(void)(jg);; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  double sum = 0., n = 0.;
  {{ int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    if (child.y < 0 && (!((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).pid < 0) || !((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) )))).pid < 0)) &&
 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(s.i)] != ((double)1e30))
      sum += ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(s.i)], n++;} } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}}
  return n ? sum/n : ((double)1e30);
}

static void masked_boundary_restriction (const Boundary * b,
      scalar * list, int l)
{
  scalar * scalars = 
# 1404 "/root/mnt/basilisk/src/grid/tree.h" 3 4
                    ((void *)0)
# 1404 "/root/mnt/basilisk/src/grid/tree.h"
                        ;
  vector * faces = 
# 1405 "/root/mnt/basilisk/src/grid/tree.h" 3 4
                  ((void *)0)
# 1405 "/root/mnt/basilisk/src/grid/tree.h"
                      ;
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (!((s).i >= 65536) && _attribute[s.i].refine != no_restriction) {
      if (_attribute[s.i].v.x.i == s.i && _attribute[s.i].face)
 faces = vectors_add (faces, _attribute[s.i].v);
      else
 scalars = list_add (scalars, s);
    }}}

  {{ if (l <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _cache = ((Tree *)grid)->restriction[l]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.level = l; int _k; for (_k = 0; _k < _cache.n; _k++) { point.i = _cache.p[_k].i; point.j = _cache.p[_k].j; ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
    {scalar*_i=(scalar*)( scalars);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] = masked_average (parent, s);}}
    {vector*_i=(vector*)( faces);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){
      { {
 double average = masked_average_x (parent, v.x);
 if (((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) )))).pid < 0))
   ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(v.x.i)] = average;
 if (((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) )))).pid < 0))
   ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(v.x.i)] = average;
      }
# 1418 "/root/mnt/basilisk/src/grid/tree.h"
{
 double average = masked_average_y (parent, v.y);
 if (((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) )))).pid < 0))
   ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(v.y.i)] = average;
 if (((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) )))).pid < 0))
   ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(v.y.i)] = average;
      }}}}
  }} } }; }};}

  free(scalars);
  free(faces);
}
# 1454 "/root/mnt/basilisk/src/grid/tree.h"
static void free_cache (CacheLevel * c)
{
  for (int l = 0; l <= (grid->depth); l++)
    free(c[l].p);
  free(c);
}

void free_grid (void)
{
  if (!grid)
    return;
  free_boundaries();
  Tree * q = ((Tree *)grid);
  free(q->leaves.p);
  free(q->faces.p);
  free(q->vertices.p);
  free(q->refined.p);


  Layer * L = q->L[0];
  {{ Point point = {0}; for (point.i = ((Period.x*2) > ((L->m)->r1.start) ? (Period.x*2) : ((L->m)->r1.start)); point.i < ((L->len - Period.x*2) < ((L->m)->r1.end) ? (L->len - Period.x*2) : ((L->m)->r1.end)); point.i += 1) if ((L->m)->b[point.i]) for (point.j = ((Period.y*2) > ((L->m)->r2[point.i].start) ? (Period.y*2) : ((L->m)->r2[point.i].start)); point.j < ((L->len - Period.y*2) < ((L->m)->r2[point.i].end) ? (L->len - Period.y*2) : ((L->m)->r2[point.i].end)); point.j += 1) if ((L->m)->b[point.i][point.j]) { {



    free(((L->m)->b[point.i][point.j]));



  }}};}
  for (int l = 0; l <= (grid->depth); l++)
    destroy_layer (q->L[l]);
  q->L = &(q->L[-1]);
  free(q->L);
  free_cache (q->active);
  free_cache (q->prolongation);
  free_cache (q->boundary);
  free_cache (q->restriction);
  free(q);
  grid = 
# 1492 "/root/mnt/basilisk/src/grid/tree.h" 3 4
        ((void *)0)
# 1492 "/root/mnt/basilisk/src/grid/tree.h"
            ;
}

static void refine_level (int depth);


void init_grid (int n)
{;

  if (!(sizeof(Cell) % 8 == 0)) qassert ("/root/mnt/basilisk/src/grid/tree.h", 1501, "sizeof(Cell) % 8 == 0");

  free_grid();
  int depth = 0;
  while (n > 1) {
    if (n % 2) {
      fprintf (
# 1507 "/root/mnt/basilisk/src/grid/tree.h" 3
              stderr
# 1507 "/root/mnt/basilisk/src/grid/tree.h"
                  , "tree: N must be a power-of-two\n");
      exit (1);
    }
    n /= 2;
    depth++;
  }
  Tree * q = ((Tree *) calloc(1,sizeof(Tree)));
  grid = (Grid *) q;
  grid->depth = 0;


  q->L = ((Layer * *) malloc((2)*sizeof(Layer *)));

  q->L[0] = 
# 1520 "/root/mnt/basilisk/src/grid/tree.h" 3 4
           ((void *)0)
# 1520 "/root/mnt/basilisk/src/grid/tree.h"
               ; q->L = &(q->L[1]);

  Layer * L = new_layer (0);
  q->L[0] = L;
# 1537 "/root/mnt/basilisk/src/grid/tree.h"
  for (int i = Period.x*2; i < L->len - Period.x*2; i++)
    for (int j = Period.y*2; j < L->len - Period.y*2; j++)
      assign_periodic (L->m, i, j, L->len,
         (char *) calloc(1,sizeof(Cell) + datasize));
  (*((Cell *)(((L->m)->b[2][2])))).flags |= leaf;
  if (0 == 0)
    (*((Cell *)(((L->m)->b[2][2])))).flags |= active;
  for (int k = - 2*(1 - Period.x); k <= 2*(1 - Period.x); k++)
    for (int l = -2*(1 - Period.y); l <= 2*(1 - Period.y); l++)
      (*((Cell *)(((L->m)->b[2 +k][2 +l])))).pid =
 (k < 0 ? -1 - left :
  k > 0 ? -1 - right :
  l > 0 ? -1 - top :
  l < 0 ? -1 - bottom :
  0);
  (*((Cell *)(((L->m)->b[2][2])))).pid = 0;
# 1575 "/root/mnt/basilisk/src/grid/tree.h"
  q->active = ((CacheLevel *) calloc(1,sizeof(CacheLevel)));
  q->prolongation = ((CacheLevel *) calloc(1,sizeof(CacheLevel)));
  q->boundary = ((CacheLevel *) calloc(1,sizeof(CacheLevel)));
  q->restriction = ((CacheLevel *) calloc(1,sizeof(CacheLevel)));
  q->dirty = 
# 1579 "/root/mnt/basilisk/src/grid/tree.h" 3 4
            1
# 1579 "/root/mnt/basilisk/src/grid/tree.h"
                ;
  N = 1 << depth;





  Boundary * b = ((Boundary *) calloc(1,sizeof(Boundary)));
  b->level = box_boundary_level;
  b->restriction = masked_boundary_restriction;
  add_boundary (b);
  refine_level (depth);
  reset (all, 0.);
  { if (((Tree *)grid)->dirty) update_cache_f(); };
;}


void check_two_one (void)
{
  {{ Point root = {2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point = {0}; struct { int l, i, j, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; }; if (!(((point.i+0) >= (((Tree *)grid)->L[point.level]->m)->r1.start && (point.i+0) < (((Tree *)grid)->L[point.level]->m->r1.end) && (((Tree *)grid)->L[point.level]->m)->b[point.i+0] && (point.j+0) >= (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].start && (point.j+0) < (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].end && (((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )) continue; switch (stage) { case 0: { ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; if ((((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & leaf)) { if ((((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & active) && (((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).pid == 0)) {
    if (level > 0)
      for (int k = -1; k <= 1; k++)
 for (int l = -1; l <= 1; l++) {

   int i = (point.i + 2)/2 + k;
   int j = (point.j + 2)/2 + l;
   double x = ((i - 2 + 0.5)*(1./(1 << point.level))*2. - 0.5);
   double y = ((j - 2 + 0.5)*(1./(1 << point.level))*2. - 0.5);
   if (x > -0.5 && x < 0.5 && y > -0.5 && y < 0.5 &&
       !((*((Cell *)((((((Tree *)grid)->L[point.level-1]->m)->b[(point.i+2)/2+k][(point.j+2)/2+l]) )))).flags & active)) {
     FILE * fp = fopen("check_two_one_loc", "w");
     fprintf (fp,
       "# %d %d\n"
       "%g %g\n%g %g\n",
       k, l,
       (((point.i - 2) + 0.5)*(1./(1 << point.level)) - 0.5),
       (((point.j - 2) + 0.5)*(1./(1 << point.level)) - 0.5),
       x, y);
     fclose (fp);





     if (!(
# 1623 "/root/mnt/basilisk/src/grid/tree.h" 3 4
          0
# 1623 "/root/mnt/basilisk/src/grid/tree.h"
               )) qassert ("/root/mnt/basilisk/src/grid/tree.h", 1623, "false");
   }
 }} continue; } if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; } } } };}
}


struct _locate { double x, y, z; };

Point locate (struct _locate p)
{
  for (int l = (grid->depth); l >= 0; l--) {
    Point point = {0};int ig=0;(void)(ig);int jg=0;(void)(jg);; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    point.level = l;
    int n = 1 << point.level;
    point.i = (p.x - X0)/L0*n + 2;

    point.j = (p.y - Y0)/L0*n + 2;




    if (point.i >= 0 && point.i < n + 2*2

 && point.j >= 0 && point.j < n + 2*2




 ) {
      if ((((point.i+0) >= (((Tree *)grid)->L[point.level]->m)->r1.start && (point.i+0) < (((Tree *)grid)->L[point.level]->m->r1.end) && (((Tree *)grid)->L[point.level]->m)->b[point.i+0] && (point.j+0) >= (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].start && (point.j+0) < (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].end && (((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) && (((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).pid == 0) && (((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & leaf))
 return point;
    }
    else
      break;
  }
  Point point = {0};int ig=0;(void)(ig);int jg=0;(void)(jg);; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  point.level = -1;
  return point;
}




# 1665 "/root/mnt/basilisk/src/grid/tree.h" 3 4
_Bool 
# 1665 "/root/mnt/basilisk/src/grid/tree.h"
    tree_is_full()
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
  return (grid->tn == 1L << grid->maxdepth*2);
}
# 1 "grid/tree-common.h"
# 1 "/root/mnt/basilisk/src/grid/tree-common.h"
# 1 "grid/multigrid-common.h"
# 1 "/root/mnt/basilisk/src/grid/multigrid-common.h"
# 1 "grid/cartesian-common.h"
# 1 "/root/mnt/basilisk/src/grid/cartesian-common.h"
# 1 "grid/events.h"
# 1 "/root/mnt/basilisk/src/grid/events.h"







static void event_error (Event * ev, const char * s)
{
  fprintf (
# 10 "/root/mnt/basilisk/src/grid/events.h" 3
          stderr
# 10 "/root/mnt/basilisk/src/grid/events.h"
              , "%s:%d: error: %s\n", ev->file, ev->line, s);
  exit (1);
}

static void init_event (Event * ev)
{
  if (ev->arrayi || ev->arrayt) {
    ev->i = ev->t = -1;
    if (ev->arrayi)
      ev->i = ev->arrayi[0];
    else
      ev->t = ev->arrayt[0];
    ev->a = 1;
    ev->expr[1] = 
# 23 "/root/mnt/basilisk/src/grid/events.h" 3 4
                 ((void *)0)
# 23 "/root/mnt/basilisk/src/grid/events.h"
                     ;
  }
  else {
    if (ev->nexpr > 0) {
      Expr init = 
# 27 "/root/mnt/basilisk/src/grid/events.h" 3 4
                 ((void *)0)
# 27 "/root/mnt/basilisk/src/grid/events.h"
                     , cond = 
# 27 "/root/mnt/basilisk/src/grid/events.h" 3 4
                              ((void *)0)
# 27 "/root/mnt/basilisk/src/grid/events.h"
                                  , inc = 
# 27 "/root/mnt/basilisk/src/grid/events.h" 3 4
                                          ((void *)0)
# 27 "/root/mnt/basilisk/src/grid/events.h"
                                              ;
      for (int j = 0; j < ev->nexpr; j++) {
 int i = -123456; double t = i;
 (* ev->expr[j]) (&i, &t, ev);
 if (i == -123456 && t == -123456) {

   if (cond)
     event_error (ev, "events can only use a single condition");
   cond = ev->expr[j];
 }
 else {

   int i1 = i; double t1 = t;
   (* ev->expr[j]) (&i1, &t1, ev);
   if (i1 == i && t1 == t) {


     if (init)
       event_error (ev, "events can only use a single initialisation");
     init = ev->expr[j];
   }
   else {

     if (inc)
       event_error (ev, "events can only use a single increment");
     inc = ev->expr[j];
   }
 }
      }
      ev->expr[0] = init;
      ev->expr[1] = cond;
      ev->expr[2] = inc;
      ev->nexpr = 0;
    }
    ev->i = ev->t = -1;
    if (ev->expr[0]) {
      (* ev->expr[0]) (&ev->i, &ev->t, ev);
      if (ev->i == 1234567890 || ev->t == 1234567890) {
 ev->i = 1234567890; ev->t = -1;
      }
    }
    else if (ev->expr[2]) {
      (* ev->expr[2]) (&ev->i, &ev->t, ev);
      if (ev->i != -1)
 ev->i = 0;
      if (ev->t != -1)
 ev->t = 0;
    }
  }
}

enum { event_done, event_alive, event_stop };

static int event_finished (Event * ev)
{
  ev->t = ev->i = -1;
  return event_done;
}

void event_register (Event event) {
  if (!(Events)) qassert ("/root/mnt/basilisk/src/grid/events.h", 87, "Events");
  if (!(!event.last)) qassert ("/root/mnt/basilisk/src/grid/events.h", 88, "!event.last");
  int n = 0, parent = -1;
  for (Event * ev = Events; !ev->last; ev++) {
    if (!strcmp (event.name, ev->name)) {
      if (!(parent < 0)) qassert ("/root/mnt/basilisk/src/grid/events.h", 92, "parent < 0");
      parent = n;
    }
    n++;
  }
  if (parent < 0) {
    Events = (Event *) realloc(Events,(n + 2)*sizeof(Event));
    Events[n] = event;
    Events[n].next = 
# 100 "/root/mnt/basilisk/src/grid/events.h" 3 4
                    ((void *)0)
# 100 "/root/mnt/basilisk/src/grid/events.h"
                        ;
    Events[n + 1].last = 
# 101 "/root/mnt/basilisk/src/grid/events.h" 3 4
                        1
# 101 "/root/mnt/basilisk/src/grid/events.h"
                            ;
    init_event (&Events[n]);
  }
  else {
    Event * ev = ((Event *) calloc(1,sizeof(Event)));
    *ev = Events[parent];
    Events[parent] = event;
    Events[parent].next = ev;
    init_event (&Events[parent]);
  }
}

static int event_cond (Event * ev, int i, double t)
{
  if (!ev->expr[1])
    return 
# 116 "/root/mnt/basilisk/src/grid/events.h" 3 4
          1
# 116 "/root/mnt/basilisk/src/grid/events.h"
              ;
  return (* ev->expr[1]) (&i, &t, ev);
}
# 131 "/root/mnt/basilisk/src/grid/events.h"
static int event_do (Event * ev, 
# 131 "/root/mnt/basilisk/src/grid/events.h" 3 4
                                _Bool 
# 131 "/root/mnt/basilisk/src/grid/events.h"
                                     action)
{
  if ((iter > ev->i && t > ev->t) || !event_cond (ev, iter, t))
    return event_finished (ev);
  if (iter == ev->i || fabs (t - ev->t) <= 1e-9) {
    if (action) {
      
# 137 "/root/mnt/basilisk/src/grid/events.h" 3 4
     _Bool 
# 137 "/root/mnt/basilisk/src/grid/events.h"
          finished = 
# 137 "/root/mnt/basilisk/src/grid/events.h" 3 4
                     0
# 137 "/root/mnt/basilisk/src/grid/events.h"
                          ;
      for (Event * e = ev; e; e = e->next) {



 if ((* e->action) (iter, t, e))
   finished = 
# 143 "/root/mnt/basilisk/src/grid/events.h" 3 4
             1
# 143 "/root/mnt/basilisk/src/grid/events.h"
                 ;
      }
      if (finished) {
 event_finished (ev);
 return event_stop;
      }
    }
    if (ev->arrayi) {
      ev->i = ev->arrayi[ev->a++];
      if (ev->i < 0)
 return event_finished (ev);
    }
    if (ev->arrayt) {
      ev->t = ev->arrayt[ev->a++];
      if (ev->t < 0)
 return event_finished (ev);
    }
    else if (ev->expr[2]) {
      int i0 = ev->i;
      (* ev->expr[2]) (&ev->i, &ev->t, ev);
      if (i0 == -1 && ev->i != i0)
 ev->i += iter + 1;
      if (!event_cond (ev, iter + 1, ev->t))
 return event_finished (ev);
    }
    else if (ev->expr[0] && !ev->expr[1])
      return event_finished (ev);
  }
  return event_alive;
}

static void end_event_do (
# 174 "/root/mnt/basilisk/src/grid/events.h" 3 4
                         _Bool 
# 174 "/root/mnt/basilisk/src/grid/events.h"
                              action)
{




  for (Event * ev = Events; !ev->last; ev++)
    if (ev->i == 1234567890 && action)
      for (Event * e = ev; e; e = e->next) {



 e->action (iter, t, e);
      }
}

int events (
# 190 "/root/mnt/basilisk/src/grid/events.h" 3 4
           _Bool 
# 190 "/root/mnt/basilisk/src/grid/events.h"
                action)
{





  if (iter == 0)
    for (Event * ev = Events; !ev->last; ev++)
      init_event (ev);

  int cond = 0, cond1 = 0;
  inext = 1234567890; tnext = ((double)1e30);
  for (Event * ev = Events; !ev->last && !cond; ev++)
    if (ev->i != 1234567890 &&
 (ev->expr[1] || (ev->expr[0] && !ev->expr[1] && !ev->expr[2]) || ev->arrayi || ev->arrayt))
      cond = 1;
  for (Event * ev = Events; !ev->last; ev++) {
    int status = event_do (ev, action);
    if (status == event_stop) {
      end_event_do (action);
      return 0;
    }
    if (status == event_alive && ev->i != 1234567890 &&
 (ev->expr[1] || (ev->expr[0] && !ev->expr[1] && !ev->expr[2]) || ev->arrayi || ev->arrayt))
      cond1 = 1;
    if (ev->t > t && ev->t < tnext)
      tnext = ev->t;
    if (ev->i > iter && ev->i < inext)
      inext = ev->i;
  }
  if ((!cond || cond1) && (tnext != ((double)1e30) || inext != 1234567890)) {
    inext = iter + 1;
    return 1;
  }
  end_event_do (action);
  return 0;
}

void event (const char * name)
{
  for (Event * ev = Events; !ev->last; ev++)
    if (!strcmp (ev->name, name))
      for (Event * e = ev; e; e = e->next) {



 (* e->action) (0, 0, e);
      }
}

double dtnext (double dt)
{
  if (tnext != ((double)1e30) && tnext > t) {
    unsigned int n = (tnext - t)/dt;
    if (!(n < 0x7fffffff)) qassert ("/root/mnt/basilisk/src/grid/events.h", 245, "n < INT_MAX");
    if (n == 0)
      dt = tnext - t;
    else {
      double dt1 = (tnext - t)/n;
      if (dt1 > dt + 1e-9)
 dt = (tnext - t)/(n + 1);
      else if (dt1 < dt)
 dt = dt1;
      tnext = t + dt;
    }
  }
  else
    tnext = t + dt;
  return dt;
}
# 2 "/root/mnt/basilisk/src/grid/cartesian-common.h"

void (* debug) (Point);
# 44 "/root/mnt/basilisk/src/grid/cartesian-common.h"
# 1 "grid/fpe.h"
# 1 "/root/mnt/basilisk/src/grid/fpe.h"


# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/signal.h" 1 3
# 27 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/signal.h" 3



# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/signum-generic.h" 1 3
# 76 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/signum-generic.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/signum-arch.h" 1 3
# 77 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/signum-generic.h" 2 3
# 31 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/signal.h" 2 3

# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/sig_atomic_t.h" 1 3








# 8 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/sig_atomic_t.h" 3
typedef __sig_atomic_t sig_atomic_t;
# 33 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/signal.h" 2 3
# 57 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/signal.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/siginfo_t.h" 1 3



# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/wordsize.h" 1 3
# 5 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/siginfo_t.h" 2 3

# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/__sigval_t.h" 1 3
# 24 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/__sigval_t.h" 3
union sigval
{
  int sival_int;
  void *sival_ptr;
};

typedef union sigval __sigval_t;
# 7 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/siginfo_t.h" 2 3
# 16 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/siginfo_t.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/siginfo-arch.h" 1 3
# 17 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/siginfo_t.h" 2 3
# 36 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/siginfo_t.h" 3
typedef struct
  {
    int si_signo;

    int si_errno;

    int si_code;





    int __pad0;


    union
      {
 int _pad[((128 / sizeof (int)) - 4)];


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
   } _kill;


 struct
   {
     int si_tid;
     int si_overrun;
     __sigval_t si_sigval;
   } _timer;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     __sigval_t si_sigval;
   } _rt;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     int si_status;
     __clock_t si_utime;
     __clock_t si_stime;
   } _sigchld;


 struct
   {
     void *si_addr;
    
     short int si_addr_lsb;
     union
       {

  struct
    {
      void *_lower;
      void *_upper;
    } _addr_bnd;

  __uint32_t _pkey;
       } _bounds;
   } _sigfault;


 struct
   {
     long int si_band;
     int si_fd;
   } _sigpoll;



 struct
   {
     void *_call_addr;
     int _syscall;
     unsigned int _arch;
   } _sigsys;

      } _sifields;
  } siginfo_t ;
# 58 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/signal.h" 2 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/siginfo-consts.h" 1 3
# 35 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/siginfo-consts.h" 3
enum
{
  SI_ASYNCNL = -60,
  SI_DETHREAD = -7,

  SI_TKILL,
  SI_SIGIO,

  SI_ASYNCIO,
  SI_MESGQ,
  SI_TIMER,





  SI_QUEUE,
  SI_USER,
  SI_KERNEL = 0x80
# 66 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/siginfo-consts.h" 3
};




enum
{
  ILL_ILLOPC = 1,

  ILL_ILLOPN,

  ILL_ILLADR,

  ILL_ILLTRP,

  ILL_PRVOPC,

  ILL_PRVREG,

  ILL_COPROC,

  ILL_BADSTK,

  ILL_BADIADDR

};


enum
{
  FPE_INTDIV = 1,

  FPE_INTOVF,

  FPE_FLTDIV,

  FPE_FLTOVF,

  FPE_FLTUND,

  FPE_FLTRES,

  FPE_FLTINV,

  FPE_FLTSUB,

  FPE_FLTUNK = 14,

  FPE_CONDTRAP

};


enum
{
  SEGV_MAPERR = 1,

  SEGV_ACCERR,

  SEGV_BNDERR,

  SEGV_PKUERR,

  SEGV_ACCADI,

  SEGV_ADIDERR,

  SEGV_ADIPERR,

  SEGV_MTEAERR,

  SEGV_MTESERR

};


enum
{
  BUS_ADRALN = 1,

  BUS_ADRERR,

  BUS_OBJERR,

  BUS_MCEERR_AR,

  BUS_MCEERR_AO

};




enum
{
  TRAP_BRKPT = 1,

  TRAP_TRACE,

  TRAP_BRANCH,

  TRAP_HWBKPT,

  TRAP_UNK

};




enum
{
  CLD_EXITED = 1,

  CLD_KILLED,

  CLD_DUMPED,

  CLD_TRAPPED,

  CLD_STOPPED,

  CLD_CONTINUED

};


enum
{
  POLL_IN = 1,

  POLL_OUT,

  POLL_MSG,

  POLL_ERR,

  POLL_PRI,

  POLL_HUP

};





# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/siginfo-consts-arch.h" 1 3
# 214 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/siginfo-consts.h" 2 3
# 59 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/signal.h" 2 3



# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/sigval_t.h" 1 3
# 16 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/sigval_t.h" 3
typedef __sigval_t sigval_t;
# 63 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/signal.h" 2 3



# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/sigevent_t.h" 1 3



# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/wordsize.h" 1 3
# 5 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/sigevent_t.h" 2 3
# 22 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/sigevent_t.h" 3
typedef struct sigevent
  {
    __sigval_t sigev_value;
    int sigev_signo;
    int sigev_notify;

    union
      {
 int _pad[((64 / sizeof (int)) - 4)];



 __pid_t _tid;

 struct
   {
     void (*_function) (__sigval_t);
     pthread_attr_t *_attribute;
   } _sigev_thread;
      } _sigev_un;
  } sigevent_t;
# 67 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/signal.h" 2 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/sigevent-consts.h" 1 3
# 27 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/sigevent-consts.h" 3
enum
{
  SIGEV_SIGNAL = 0,

  SIGEV_NONE,

  SIGEV_THREAD,


  SIGEV_THREAD_ID = 4


};
# 68 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/signal.h" 2 3




typedef void (*__sighandler_t) (int);




extern __sighandler_t __sysv_signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));

extern __sighandler_t sysv_signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));






extern __sighandler_t signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));
# 112 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/signal.h" 3
extern int kill (__pid_t __pid, int __sig) __attribute__ ((__nothrow__ , __leaf__));






extern int killpg (__pid_t __pgrp, int __sig) __attribute__ ((__nothrow__ , __leaf__));



extern int raise (int __sig) __attribute__ ((__nothrow__ , __leaf__));



extern __sighandler_t ssignal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));
extern int gsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));




extern void psignal (int __sig, const char *__s);


extern void psiginfo (const siginfo_t *__pinfo, const char *__s);
# 151 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/signal.h" 3
extern int sigpause (int __sig) __asm__ ("__xpg_sigpause")
  __attribute__ ((__deprecated__ ("Use the sigsuspend function instead")));
# 173 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/signal.h" 3
extern int sigblock (int __mask) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));


extern int sigsetmask (int __mask) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));


extern int siggetmask (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
# 188 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/signal.h" 3
typedef __sighandler_t sighandler_t;




typedef __sighandler_t sig_t;





extern int sigemptyset (sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigfillset (sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigaddset (sigset_t *__set, int __signo) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigdelset (sigset_t *__set, int __signo) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigismember (const sigset_t *__set, int __signo)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int sigisemptyset (const sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigandset (sigset_t *__set, const sigset_t *__left,
        const sigset_t *__right) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern int sigorset (sigset_t *__set, const sigset_t *__left,
       const sigset_t *__right) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3)));




# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/sigaction.h" 1 3
# 27 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/sigaction.h" 3
struct sigaction
  {


    union
      {

 __sighandler_t sa_handler;

 void (*sa_sigaction) (int, siginfo_t *, void *);
      }
    __sigaction_handler;







    __sigset_t sa_mask;


    int sa_flags;


    void (*sa_restorer) (void);
  };
# 230 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/signal.h" 2 3


extern int sigprocmask (int __how, const sigset_t *__restrict __set,
   sigset_t *__restrict __oset) __attribute__ ((__nothrow__ , __leaf__));






extern int sigsuspend (const sigset_t *__set) __attribute__ ((__nonnull__ (1)));


extern int sigaction (int __sig, const struct sigaction *__restrict __act,
        struct sigaction *__restrict __oact) __attribute__ ((__nothrow__ , __leaf__));


extern int sigpending (sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int sigwait (const sigset_t *__restrict __set, int *__restrict __sig)
     __attribute__ ((__nonnull__ (1, 2)));







extern int sigwaitinfo (const sigset_t *__restrict __set,
   siginfo_t *__restrict __info) __attribute__ ((__nonnull__ (1)));






extern int sigtimedwait (const sigset_t *__restrict __set,
    siginfo_t *__restrict __info,
    const struct timespec *__restrict __timeout)
     __attribute__ ((__nonnull__ (1)));



extern int sigqueue (__pid_t __pid, int __sig, const union sigval __val)
     __attribute__ ((__nothrow__ , __leaf__));







# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/sigcontext.h" 1 3
# 31 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/sigcontext.h" 3
struct _fpx_sw_bytes
{
  __uint32_t magic1;
  __uint32_t extended_size;
  __uint64_t xstate_bv;
  __uint32_t xstate_size;
  __uint32_t __glibc_reserved1[7];
};

struct _fpreg
{
  unsigned short significand[4];
  unsigned short exponent;
};

struct _fpxreg
{
  unsigned short significand[4];
  unsigned short exponent;
  unsigned short __glibc_reserved1[3];
};

struct _xmmreg
{
  __uint32_t element[4];
};
# 123 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/sigcontext.h" 3
struct _fpstate
{

  __uint16_t cwd;
  __uint16_t swd;
  __uint16_t ftw;
  __uint16_t fop;
  __uint64_t rip;
  __uint64_t rdp;
  __uint32_t mxcsr;
  __uint32_t mxcr_mask;
  struct _fpxreg _st[8];
  struct _xmmreg _xmm[16];
  __uint32_t __glibc_reserved1[24];
};

struct sigcontext
{
  __uint64_t r8;
  __uint64_t r9;
  __uint64_t r10;
  __uint64_t r11;
  __uint64_t r12;
  __uint64_t r13;
  __uint64_t r14;
  __uint64_t r15;
  __uint64_t rdi;
  __uint64_t rsi;
  __uint64_t rbp;
  __uint64_t rbx;
  __uint64_t rdx;
  __uint64_t rax;
  __uint64_t rcx;
  __uint64_t rsp;
  __uint64_t rip;
  __uint64_t eflags;
  unsigned short cs;
  unsigned short gs;
  unsigned short fs;
  unsigned short __pad0;
  __uint64_t err;
  __uint64_t trapno;
  __uint64_t oldmask;
  __uint64_t cr2;
  __extension__ union
    {
      struct _fpstate * fpstate;
      __uint64_t __fpstate_word;
    };
  __uint64_t __reserved1 [8];
};



struct _xsave_hdr
{
  __uint64_t xstate_bv;
  __uint64_t __glibc_reserved1[2];
  __uint64_t __glibc_reserved2[5];
};

struct _ymmh_state
{
  __uint32_t ymmh_space[64];
};

struct _xstate
{
  struct _fpstate fpstate;
  struct _xsave_hdr xstate_hdr;
  struct _ymmh_state ymmh;
};
# 289 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/signal.h" 2 3


extern int sigreturn (struct sigcontext *__scp) __attribute__ ((__nothrow__ , __leaf__));






# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/lib/gcc/x86_64-mk-linux/11.2.0/include/stddef.h" 1 3 4
# 299 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/signal.h" 2 3

# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/stack_t.h" 1 3
# 23 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/stack_t.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/lib/gcc/x86_64-mk-linux/11.2.0/include/stddef.h" 1 3 4
# 24 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/stack_t.h" 2 3


typedef struct
  {
    void *ss_sp;
    int ss_flags;
    size_t ss_size;
  } stack_t;
# 301 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/signal.h" 2 3


# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/sys/ucontext.h" 1 3
# 37 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/sys/ucontext.h" 3
__extension__ typedef long long int greg_t;
# 46 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/sys/ucontext.h" 3
typedef greg_t gregset_t[23];



enum
{
  REG_R8 = 0,

  REG_R9,

  REG_R10,

  REG_R11,

  REG_R12,

  REG_R13,

  REG_R14,

  REG_R15,

  REG_RDI,

  REG_RSI,

  REG_RBP,

  REG_RBX,

  REG_RDX,

  REG_RAX,

  REG_RCX,

  REG_RSP,

  REG_RIP,

  REG_EFL,

  REG_CSGSFS,

  REG_ERR,

  REG_TRAPNO,

  REG_OLDMASK,

  REG_CR2

};


struct _libc_fpxreg
{
  unsigned short int significand[4];
  unsigned short int exponent;
  unsigned short int __glibc_reserved1[3];
};

struct _libc_xmmreg
{
  __uint32_t element[4];
};

struct _libc_fpstate
{

  __uint16_t cwd;
  __uint16_t swd;
  __uint16_t ftw;
  __uint16_t fop;
  __uint64_t rip;
  __uint64_t rdp;
  __uint32_t mxcsr;
  __uint32_t mxcr_mask;
  struct _libc_fpxreg _st[8];
  struct _libc_xmmreg _xmm[16];
  __uint32_t __glibc_reserved1[24];
};


typedef struct _libc_fpstate *fpregset_t;


typedef struct
  {
    gregset_t gregs;

    fpregset_t fpregs;
    __extension__ unsigned long long __reserved1 [8];
} mcontext_t;


typedef struct ucontext_t
  {
    unsigned long int uc_flags;
    struct ucontext_t *uc_link;
    stack_t uc_stack;
    mcontext_t uc_mcontext;
    sigset_t uc_sigmask;
    struct _libc_fpstate __fpregs_mem;
    __extension__ unsigned long long int __ssp[4];
  } ucontext_t;
# 304 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/signal.h" 2 3







extern int siginterrupt (int __sig, int __interrupt) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__deprecated__ ("Use sigaction with SA_RESTART instead")));

# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/sigstack.h" 1 3
# 315 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/signal.h" 2 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/ss_flags.h" 1 3
# 27 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/ss_flags.h" 3
enum
{
  SS_ONSTACK = 1,

  SS_DISABLE

};
# 316 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/signal.h" 2 3



extern int sigaltstack (const stack_t *__restrict __ss,
   stack_t *__restrict __oss) __attribute__ ((__nothrow__ , __leaf__));




# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/struct_sigstack.h" 1 3
# 23 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/types/struct_sigstack.h" 3
struct sigstack
  {
    void *ss_sp;
    int ss_onstack;
  };
# 326 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/signal.h" 2 3







extern int sigstack (struct sigstack *__ss, struct sigstack *__oss)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));






extern int sighold (int __sig) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__deprecated__ ("Use the sigprocmask function instead")));


extern int sigrelse (int __sig) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__deprecated__ ("Use the sigprocmask function instead")));


extern int sigignore (int __sig) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__deprecated__ ("Use the signal function instead")));


extern __sighandler_t sigset (int __sig, __sighandler_t __disp) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__deprecated__ ("Use the signal and sigprocmask functions instead")))
                                                        ;






# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/sigthread.h" 1 3
# 31 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/sigthread.h" 3
extern int pthread_sigmask (int __how,
       const __sigset_t *__restrict __newmask,
       __sigset_t *__restrict __oldmask)__attribute__ ((__nothrow__ , __leaf__));


extern int pthread_kill (pthread_t __threadid, int __signo) __attribute__ ((__nothrow__ , __leaf__));



extern int pthread_sigqueue (pthread_t __threadid, int __signo,
        const union sigval __value) __attribute__ ((__nothrow__ , __leaf__));
# 363 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/signal.h" 2 3






extern int __libc_current_sigrtmin (void) __attribute__ ((__nothrow__ , __leaf__));

extern int __libc_current_sigrtmax (void) __attribute__ ((__nothrow__ , __leaf__));





# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/signal_ext.h" 1 3
# 29 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/signal_ext.h" 3
extern int tgkill (__pid_t __tgid, __pid_t __tid, int __signal);
# 378 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/signal.h" 2 3


# 4 "/root/mnt/basilisk/src/grid/fpe.h" 2
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/unistd.h" 1 3
# 27 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/unistd.h" 3

# 202 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/unistd.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/posix_opt.h" 1 3
# 203 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/unistd.h" 2 3



# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/environments.h" 1 3
# 22 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/environments.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/wordsize.h" 1 3
# 23 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/environments.h" 2 3
# 207 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/unistd.h" 2 3
# 226 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/unistd.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/lib/gcc/x86_64-mk-linux/11.2.0/include/stddef.h" 1 3 4
# 227 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/unistd.h" 2 3
# 274 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/unistd.h" 3
typedef __socklen_t socklen_t;
# 287 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/unistd.h" 3
extern int access (const char *__name, int __type) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int euidaccess (const char *__name, int __type)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int eaccess (const char *__name, int __type)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int faccessat (int __fd, const char *__file, int __type, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;
# 334 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/unistd.h" 3
extern __off_t lseek (int __fd, __off_t __offset, int __whence) __attribute__ ((__nothrow__ , __leaf__));
# 345 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/unistd.h" 3
extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     __attribute__ ((__nothrow__ , __leaf__));






extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes)
    __attribute__ ((__access__ (__write_only__, 2, 3)));





extern ssize_t write (int __fd, const void *__buf, size_t __n)
    __attribute__ ((__access__ (__read_only__, 2, 3)));
# 378 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/unistd.h" 3
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset)
    __attribute__ ((__access__ (__write_only__, 2, 3)));






extern ssize_t pwrite (int __fd, const void *__buf, size_t __n,
         __off_t __offset)
    __attribute__ ((__access__ (__read_only__, 2, 3)));
# 411 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/unistd.h" 3
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset)
    __attribute__ ((__access__ (__write_only__, 2, 3)));


extern ssize_t pwrite64 (int __fd, const void *__buf, size_t __n,
    __off64_t __offset)
    __attribute__ ((__access__ (__read_only__, 2, 3)));







extern int pipe (int __pipedes[2]) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int pipe2 (int __pipedes[2], int __flags) __attribute__ ((__nothrow__ , __leaf__)) ;
# 441 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/unistd.h" 3
extern unsigned int alarm (unsigned int __seconds) __attribute__ ((__nothrow__ , __leaf__));
# 453 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/unistd.h" 3
extern unsigned int sleep (unsigned int __seconds);







extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     __attribute__ ((__nothrow__ , __leaf__));






extern int usleep (__useconds_t __useconds);
# 478 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/unistd.h" 3
extern int pause (void);



extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;






extern int fchownat (int __fd, const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;



extern int chdir (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;
# 520 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/unistd.h" 3
extern char *getcwd (char *__buf, size_t __size) __attribute__ ((__nothrow__ , __leaf__))
    __attribute__ ((__access__ (__write_only__, 1, 2)));





extern char *get_current_dir_name (void) __attribute__ ((__nothrow__ , __leaf__));







extern char *getwd (char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__))
    __attribute__ ((__access__ (__write_only__, 1)));




extern int dup (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;


extern int dup2 (int __fd, int __fd2) __attribute__ ((__nothrow__ , __leaf__));




extern int dup3 (int __fd, int __fd2, int __flags) __attribute__ ((__nothrow__ , __leaf__));



extern char **__environ;

extern char **environ;





extern int execve (const char *__path, char *const __argv[],
     char *const __envp[]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern int execv (const char *__path, char *const __argv[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execle (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execl (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execvp (const char *__file, char *const __argv[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int execlp (const char *__file, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int execvpe (const char *__file, char *const __argv[],
      char *const __envp[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern int nice (int __inc) __attribute__ ((__nothrow__ , __leaf__)) ;




extern void _exit (int __status) __attribute__ ((__noreturn__));





# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/confname.h" 1 3
# 24 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/confname.h" 3
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
# 621 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/unistd.h" 2 3


extern long int pathconf (const char *__path, int __name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) __attribute__ ((__nothrow__ , __leaf__));


extern long int sysconf (int __name) __attribute__ ((__nothrow__ , __leaf__));



extern size_t confstr (int __name, char *__buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__))
    __attribute__ ((__access__ (__write_only__, 2, 3)));




extern __pid_t getpid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t getppid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t getpgrp (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t __getpgid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));

extern __pid_t getpgid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));






extern int setpgid (__pid_t __pid, __pid_t __pgid) __attribute__ ((__nothrow__ , __leaf__));
# 672 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/unistd.h" 3
extern int setpgrp (void) __attribute__ ((__nothrow__ , __leaf__));






extern __pid_t setsid (void) __attribute__ ((__nothrow__ , __leaf__));



extern __pid_t getsid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));



extern __uid_t getuid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __uid_t geteuid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __gid_t getgid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __gid_t getegid (void) __attribute__ ((__nothrow__ , __leaf__));




extern int getgroups (int __size, __gid_t __list[]) __attribute__ ((__nothrow__ , __leaf__))
    __attribute__ ((__access__ (__write_only__, 2, 1)));


extern int group_member (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__));






extern int setuid (__uid_t __uid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setreuid (__uid_t __ruid, __uid_t __euid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int seteuid (__uid_t __uid) __attribute__ ((__nothrow__ , __leaf__)) ;






extern int setgid (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setregid (__gid_t __rgid, __gid_t __egid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setegid (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__)) ;





extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     __attribute__ ((__nothrow__ , __leaf__));



extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     __attribute__ ((__nothrow__ , __leaf__));



extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     __attribute__ ((__nothrow__ , __leaf__)) ;



extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     __attribute__ ((__nothrow__ , __leaf__)) ;






extern __pid_t fork (void) __attribute__ ((__nothrow__));







extern __pid_t vfork (void) __attribute__ ((__nothrow__ , __leaf__));





extern char *ttyname (int __fd) __attribute__ ((__nothrow__ , __leaf__));



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) __attribute__ ((__access__ (__write_only__, 2, 3)));



extern int isatty (int __fd) __attribute__ ((__nothrow__ , __leaf__));




extern int ttyslot (void) __attribute__ ((__nothrow__ , __leaf__));




extern int link (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern int linkat (int __fromfd, const char *__from, int __tofd,
     const char *__to, int __flags)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4))) ;




extern int symlink (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__access__ (__write_only__, 2, 3)));





extern int symlinkat (const char *__from, int __tofd,
        const char *__to) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3))) ;


extern ssize_t readlinkat (int __fd, const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3))) __attribute__ ((__access__ (__write_only__, 3, 4)));



extern int unlink (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, const char *__name, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern int rmdir (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) __attribute__ ((__nothrow__ , __leaf__));


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) __attribute__ ((__nothrow__ , __leaf__));






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)))
    __attribute__ ((__access__ (__write_only__, 1, 2)));




extern int setlogin (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/getopt_posix.h" 1 3
# 27 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/getopt_posix.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/getopt_core.h" 1 3
# 28 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/getopt_core.h" 3








extern char *optarg;
# 50 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/getopt_core.h" 3
extern int optind;




extern int opterr;



extern int optopt;
# 91 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/getopt_core.h" 3
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));


# 28 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/getopt_posix.h" 2 3


# 49 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/getopt_posix.h" 3

# 884 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/unistd.h" 2 3







extern int gethostname (char *__name, size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)))
    __attribute__ ((__access__ (__write_only__, 1, 2)));






extern int sethostname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__access__ (__read_only__, 1, 2)));



extern int sethostid (long int __id) __attribute__ ((__nothrow__ , __leaf__)) ;





extern int getdomainname (char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__access__ (__write_only__, 1, 2)));
extern int setdomainname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__access__ (__read_only__, 1, 2)));




extern int vhangup (void) __attribute__ ((__nothrow__ , __leaf__));


extern int revoke (const char *__file) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int acct (const char *__name) __attribute__ ((__nothrow__ , __leaf__));



extern char *getusershell (void) __attribute__ ((__nothrow__ , __leaf__));
extern void endusershell (void) __attribute__ ((__nothrow__ , __leaf__));
extern void setusershell (void) __attribute__ ((__nothrow__ , __leaf__));





extern int daemon (int __nochdir, int __noclose) __attribute__ ((__nothrow__ , __leaf__)) ;






extern int chroot (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (const char *__prompt) __attribute__ ((__nonnull__ (1)));







extern int fsync (int __fd);





extern int syncfs (int __fd) __attribute__ ((__nothrow__ , __leaf__));






extern long int gethostid (void);


extern void sync (void) __attribute__ ((__nothrow__ , __leaf__));





extern int getpagesize (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern int getdtablesize (void) __attribute__ ((__nothrow__ , __leaf__));
# 1005 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/unistd.h" 3
extern int truncate (const char *__file, __off_t __length)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 1017 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/unistd.h" 3
extern int truncate64 (const char *__file, __off64_t __length)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 1028 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/unistd.h" 3
extern int ftruncate (int __fd, __off_t __length) __attribute__ ((__nothrow__ , __leaf__)) ;
# 1038 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/unistd.h" 3
extern int ftruncate64 (int __fd, __off64_t __length) __attribute__ ((__nothrow__ , __leaf__)) ;
# 1049 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/unistd.h" 3
extern int brk (void *__addr) __attribute__ ((__nothrow__ , __leaf__)) ;





extern void *sbrk (intptr_t __delta) __attribute__ ((__nothrow__ , __leaf__));
# 1070 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/unistd.h" 3
extern long int syscall (long int __sysno, ...) __attribute__ ((__nothrow__ , __leaf__));
# 1093 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/unistd.h" 3
extern int lockf (int __fd, int __cmd, __off_t __len) ;
# 1103 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/unistd.h" 3
extern int lockf64 (int __fd, int __cmd, __off64_t __len) ;
# 1121 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/unistd.h" 3
ssize_t copy_file_range (int __infd, __off64_t *__pinoff,
    int __outfd, __off64_t *__poutoff,
    size_t __length, unsigned int __flags);





extern int fdatasync (int __fildes);
# 1138 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/unistd.h" 3
extern char *crypt (const char *__key, const char *__salt)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));







extern void swab (const void *__restrict __from, void *__restrict __to,
    ssize_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)))
    __attribute__ ((__access__ (__read_only__, 1, 3)))
    __attribute__ ((__access__ (__write_only__, 2, 3)));
# 1177 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/unistd.h" 3
int getentropy (void *__buffer, size_t __length)
    __attribute__ ((__access__ (__write_only__, 1, 2)));
# 1187 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/unistd.h" 3
# 1 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/unistd_ext.h" 1 3
# 34 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/bits/unistd_ext.h" 3
extern __pid_t gettid (void) __attribute__ ((__nothrow__ , __leaf__));
# 1188 "/u/sw/toolchains/gcc-glibc/11.2.0/prefix/include/unistd.h" 2 3


# 5 "/root/mnt/basilisk/src/grid/fpe.h" 2


# 6 "/root/mnt/basilisk/src/grid/fpe.h"
static int gdb()
{
  if (last_point.level >= 0) {
    debug (last_point);
    fputc ('\n', 
# 10 "/root/mnt/basilisk/src/grid/fpe.h" 3
                stderr
# 10 "/root/mnt/basilisk/src/grid/fpe.h"
                    );
    fflush (
# 11 "/root/mnt/basilisk/src/grid/fpe.h" 3
           stderr
# 11 "/root/mnt/basilisk/src/grid/fpe.h"
               );
  }
  char command[80];
  sprintf (command, "exec xterm -e 'gdb -p %d' & xterm -e 'gnuplot plot -'",
    getpid());
  return system (command);
}

static void caught_abort (int sig)
{
  fprintf (
# 21 "/root/mnt/basilisk/src/grid/fpe.h" 3
          stderr
# 21 "/root/mnt/basilisk/src/grid/fpe.h"
              , "Caught signal %d (Aborted)\n", sig);
  gdb();
}

static void caught_fpe (int sig)
{
  fprintf (
# 27 "/root/mnt/basilisk/src/grid/fpe.h" 3
          stderr
# 27 "/root/mnt/basilisk/src/grid/fpe.h"
              , "Caught signal %d (Floating Point Exception)\n", sig);
  gdb();
  exit (1);
}

static void caught_segfault (int sig)
{
  fprintf (
# 34 "/root/mnt/basilisk/src/grid/fpe.h" 3
          stderr
# 34 "/root/mnt/basilisk/src/grid/fpe.h"
              , "Caught signal %d (Segmentation Fault)\n", sig);
  gdb();
  exit (2);
}

void catch_fpe (void)
{
  struct sigaction act;
  act.
# 42 "/root/mnt/basilisk/src/grid/fpe.h" 3
     __sigaction_handler.sa_handler 
# 42 "/root/mnt/basilisk/src/grid/fpe.h"
                = caught_fpe;
  sigemptyset (&act.sa_mask);
  act.sa_flags = 0;
  last_point.level = -1;
  sigaction (8, &act, 
# 46 "/root/mnt/basilisk/src/grid/fpe.h" 3 4
                     ((void *)0)
# 46 "/root/mnt/basilisk/src/grid/fpe.h"
                         );
  act.
# 47 "/root/mnt/basilisk/src/grid/fpe.h" 3
     __sigaction_handler.sa_handler 
# 47 "/root/mnt/basilisk/src/grid/fpe.h"
                = caught_segfault;
  sigaction (11, &act, 
# 48 "/root/mnt/basilisk/src/grid/fpe.h" 3 4
                      ((void *)0)
# 48 "/root/mnt/basilisk/src/grid/fpe.h"
                          );
  act.
# 49 "/root/mnt/basilisk/src/grid/fpe.h" 3
     __sigaction_handler.sa_handler 
# 49 "/root/mnt/basilisk/src/grid/fpe.h"
                = caught_abort;
  act.sa_flags = 
# 50 "/root/mnt/basilisk/src/grid/fpe.h" 3
                0x80000000
# 50 "/root/mnt/basilisk/src/grid/fpe.h"
                            ;
  sigaction (6, &act, 
# 51 "/root/mnt/basilisk/src/grid/fpe.h" 3 4
                     ((void *)0)
# 51 "/root/mnt/basilisk/src/grid/fpe.h"
                         );
}
# 47 "/root/mnt/basilisk/src/grid/cartesian-common.h"





static void init_block_scalar (scalar sb, const char * name, const char * ext,
          int n, int block)
{
  char bname[strlen(name) + strlen(ext) + 10];
  if (n == 0) {
    sprintf (bname, "%s%s", name, ext);
    _attribute[sb.i].block = block;
    init_scalar (sb, bname);
    baseblock = list_append (baseblock, sb);
  }
  else {
    sprintf (bname, "%s%d%s", name, n, ext);
    _attribute[sb.i].block = - n;
    init_scalar (sb, bname);
  }
  all = list_append (all, sb);
}

scalar new_block_scalar (const char * name, const char * ext, int block)
{
  int nvar = datasize/sizeof(double);

  scalar s = {0};
  while (s.i < nvar) {
    int n = 0;
    scalar sb = s;
    while (sb.i < nvar && n < block && _attribute[sb.i].freed)
      n++, sb.i++;
    if (n >= block) {
      for (sb.i = s.i, n = 0; n < block; n++, sb.i++)
 init_block_scalar (sb, name, ext, n, block);
      ;
      return s;
    }
    s.i = sb.i + 1;
  }


  s = (scalar){nvar};
  if (!(nvar + block <= 65536)) qassert ("/root/mnt/basilisk/src/grid/cartesian-common.h", 91, "nvar + block <= _NVARMAX");
  _attribute = (_Attributes *) realloc(_attribute,(nvar + block)*sizeof(_Attributes));
  memset (&_attribute[nvar], 0, block*sizeof (_Attributes));
  for (int n = 0; n < block; n++, nvar++) {
    scalar sb = (scalar){nvar};
    init_block_scalar (sb, name, ext, n, block);
  }

  realloc_scalar (block*sizeof(double));
  ;
  return s;
}

scalar new_scalar (const char * name)
{
  return new_block_scalar (name, "", 1);
}

scalar new_vertex_scalar (const char * name)
{
  return init_vertex_scalar (new_scalar (name), name);
}

static vector alloc_block_vector (const char * name, int block)
{
  vector v;
  struct { char * x, * y, * z; } ext = {".x", ".y", ".z"};

    v.x = new_block_scalar (name, ext.x, block);
# 119 "/root/mnt/basilisk/src/grid/cartesian-common.h"
v.y = new_block_scalar (name, ext.y, block);
  return v;
}

vector new_vector (const char * name)
{
  vector v = alloc_block_vector (name, 1);
  init_vector (v, 
# 126 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
                 ((void *)0)
# 126 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                     );
  return v;
}

vector new_face_vector (const char * name)
{
  vector v = alloc_block_vector (name, 1);
  init_face_vector (v, 
# 133 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
                      ((void *)0)
# 133 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                          );
  return v;
}

vector new_block_vector (const char * name, int block)
{
  vector v = alloc_block_vector (name, block);
  for (int i = 0; i < block; i++) {
    vector vb;

      vb.x.i = v.x.i + i;
# 143 "/root/mnt/basilisk/src/grid/cartesian-common.h"
vb.y.i = v.y.i + i;
    init_vector (vb, 
# 144 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
                    ((void *)0)
# 144 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                        );

      _attribute[vb.x.i].block = - i;
# 146 "/root/mnt/basilisk/src/grid/cartesian-common.h"
_attribute[vb.y.i].block = - i;
  }

    _attribute[v.x.i].block = block;
# 149 "/root/mnt/basilisk/src/grid/cartesian-common.h"
_attribute[v.y.i].block = block;
  return v;
}

vector new_block_face_vector (const char * name, int block)
{
  vector v = alloc_block_vector (name, block);
  for (int i = 0; i < block; i++) {
    vector vb;

      vb.x.i = v.x.i + i;
# 159 "/root/mnt/basilisk/src/grid/cartesian-common.h"
vb.y.i = v.y.i + i;
    init_face_vector (vb, 
# 160 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
                         ((void *)0)
# 160 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                             );

      _attribute[vb.x.i].block = - i;
# 162 "/root/mnt/basilisk/src/grid/cartesian-common.h"
_attribute[vb.y.i].block = - i;
  }

    _attribute[v.x.i].block = block;
# 165 "/root/mnt/basilisk/src/grid/cartesian-common.h"
_attribute[v.y.i].block = block;
  return v;
}

tensor new_tensor (const char * name)
{
  char cname[strlen(name) + 3];
  struct { char * x, * y, * z; } ext = {"%s.x", "%s.y", "%s.z"};
  tensor t;
   {
    sprintf (cname, ext.x, name);
    t.x = new_vector (cname);
  }
# 174 "/root/mnt/basilisk/src/grid/cartesian-common.h"
{
    sprintf (cname, ext.y, name);
    t.y = new_vector (cname);
  }
  init_tensor (t, 
# 178 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
                 ((void *)0)
# 178 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                     );
  return t;
}

tensor new_symmetric_tensor (const char * name)
{
  char cname[strlen(name) + 5];
  struct { char * x, * y, * z; } ext = {"%s.x.x", "%s.y.y", "%s.z.z"};
  tensor t;
   {
    sprintf (cname, ext.x, name);
    t.x.x = new_scalar(cname);
  }
# 187 "/root/mnt/basilisk/src/grid/cartesian-common.h"
{
    sprintf (cname, ext.y, name);
    t.y.y = new_scalar(cname);
  }

    sprintf (cname, "%s.x.y", name);
    t.x.y = new_scalar(cname);
    t.y.x = t.x.y;
# 207 "/root/mnt/basilisk/src/grid/cartesian-common.h"
  init_tensor (t, 
# 207 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
                 ((void *)0)
# 207 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                     );
  return t;
}

static int nconst = 0;

void init_const_scalar (scalar s, const char * name, double val)
{
  if (s.i - 65536 >= nconst) {
    nconst = s.i - 65536 + 1;
    _constant = (double *) realloc(_constant,(nconst)*sizeof(double));
  }
  _constant[s.i - 65536] = val;
}

scalar new_const_scalar (const char * name, int i, double val)
{
  scalar s = (scalar){i + 65536};
  init_const_scalar (s, name, val);
  return s;
}

void init_const_vector (vector v, const char * name, double * val)
{

    init_const_scalar (v.x, name, *val++);
# 232 "/root/mnt/basilisk/src/grid/cartesian-common.h"
init_const_scalar (v.y, name, *val++);
}

vector new_const_vector (const char * name, int i, double * val)
{
  vector v;

    v.x.i = 65536 + i++;
# 239 "/root/mnt/basilisk/src/grid/cartesian-common.h"
v.y.i = 65536 + i++;
  init_const_vector (v, name, val);
  return v;
}

void scalar_clone (scalar a, scalar b)
{
  char * name = _attribute[a.i].name;
  double (** boundary) (Point, Point, scalar, void *) = _attribute[a.i].boundary;
  double (** boundary_homogeneous) (Point, Point, scalar, void *) =
    _attribute[a.i].boundary_homogeneous;
  if (!(_attribute[b.i].block > 0 && _attribute[a.i].block == _attribute[b.i].block)) qassert ("/root/mnt/basilisk/src/grid/cartesian-common.h", 250, "b.block > 0 && a.block == b.block");
  free(_attribute[a.i].depends);
  _attribute[a.i] = _attribute[b.i];
  _attribute[a.i].name = name;
  _attribute[a.i].boundary = boundary;
  _attribute[a.i].boundary_homogeneous = boundary_homogeneous;
  for (int i = 0; i < nboundary; i++) {
    _attribute[a.i].boundary[i] = _attribute[b.i].boundary[i];
    _attribute[a.i].boundary_homogeneous[i] = _attribute[b.i].boundary_homogeneous[i];
  }
  _attribute[a.i].depends = list_copy (_attribute[b.i].depends);
}

scalar * list_clone (scalar * l)
{
  scalar * list = 
# 265 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
                 ((void *)0)
# 265 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                     ;
  int nvar = datasize/sizeof(double), map[nvar];
  for (int i = 0; i < nvar; i++)
    map[i] = -1;
  {scalar*_i=(scalar*)( l);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
    scalar c = _attribute[s.i].block > 1 ? new_block_scalar("c", "", _attribute[s.i].block) :
      new_scalar("c");
    scalar_clone (c, s);
    map[s.i] = c.i;
    list = list_append (list, c);
  }}}
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    {
      if (_attribute[s.i].v.x.i >= 0 && map[_attribute[s.i].v.x.i] >= 0)
 _attribute[s.i].v.x.i = map[_attribute[s.i].v.x.i];
# 278 "/root/mnt/basilisk/src/grid/cartesian-common.h"
if (_attribute[s.i].v.y.i >= 0 && map[_attribute[s.i].v.y.i] >= 0)
 _attribute[s.i].v.y.i = map[_attribute[s.i].v.y.i];}}}
  return list;
}

void delete (scalar * list)
{
  if (all == 
# 285 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
            ((void *)0)
# 285 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                )
    return;

  {scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){ {
    for (int i = 0; i < _attribute[f.i].block; i++) {
      scalar fb = {f.i + i};
      if (_attribute[f.i].delete)
 _attribute[f.i].delete (fb);
      free(_attribute[fb.i].name); _attribute[fb.i].name = 
# 293 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
                                                                                       ((void *)0)
# 293 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                                                                                           ;
      free(_attribute[fb.i].boundary); _attribute[fb.i].boundary = 
# 294 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
                                                                                               ((void *)0)
# 294 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                                                                                                   ;
      free(_attribute[fb.i].boundary_homogeneous); _attribute[fb.i].boundary_homogeneous = 
# 295 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
                                                                                                                       ((void *)0)
# 295 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                                                                                                                           ;
      free(_attribute[fb.i].depends); _attribute[fb.i].depends = 
# 296 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
                                                                                             ((void *)0)
# 296 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                                                                                                 ;
      _attribute[fb.i].freed = 
# 297 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
                              1
# 297 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                                  ;
    }
  }}}

  if (list == all) {
    all[0].i = -1;
    baseblock[0].i = -1;
    return;
  }

  ;
  {scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){ {
    if (_attribute[f.i].block > 0) {
      scalar * s = all;
      for (; s->i >= 0 && s->i != f.i; s++);
      if (s->i == f.i) {
 for (; s[_attribute[f.i].block].i >= 0; s++)
   s[0] = s[_attribute[f.i].block];
 s->i = -1;
      }
      for (s = baseblock; s->i >= 0 && s->i != f.i; s++);
      if (s->i == f.i) {
 for (; s[1].i >= 0; s++)
   s[0] = s[1];
 s->i = -1;
      }
    }
  }}}
}

void free_solver()
{
  if (!(_val_higher_dimension == 0.)) qassert ("/root/mnt/basilisk/src/grid/cartesian-common.h", 329, "_val_higher_dimension == 0.");

  if (free_solver_funcs) {
    free_solver_func * a = (free_solver_func *) free_solver_funcs->p;
    for (int i = 0; i < free_solver_funcs->len/sizeof(free_solver_func); i++)
      a[i] ();
    array_free (free_solver_funcs);
  }

  delete (all);
  free(all); all = 
# 339 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
                                               ((void *)0)
# 339 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                                                   ;
  free(baseblock); baseblock = 
# 340 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
                                                           ((void *)0)
# 340 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                                                               ;
  for (Event * ev = Events; !ev->last; ev++) {
    Event * e = ev->next;
    while (e) {
      Event * next = e->next;
      free(e);
      e = next;
    }
  }

  free(Events); Events = 
# 350 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
                                                     ((void *)0)
# 350 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                                                         ;
  free(_attribute); _attribute = 
# 351 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
                                                             ((void *)0)
# 351 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                                                                 ;
  free(_constant); _constant = 
# 352 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
                                                           ((void *)0)
# 352 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                                                               ;
  free_grid();
  qpclose_all();
# 364 "/root/mnt/basilisk/src/grid/cartesian-common.h"
}



void (* boundary_level) (scalar *, int l);
void (* boundary_face) (vectorl);




void boundary_flux (vector * list) __attribute__ ((deprecated));

void boundary_flux (vector * list)
{
  vectorl list1 = {
# 378 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
                  ((void *)0)
# 378 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                      };
  {vector*_i=(vector*)( list);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){
    {
      list1.x = list_append (list1.x, v.x);
# 381 "/root/mnt/basilisk/src/grid/cartesian-common.h"
list1.y = list_append (list1.y, v.y);}}}
  boundary_face (list1);

    free(list1.x);
# 384 "/root/mnt/basilisk/src/grid/cartesian-common.h"
free(list1.y);
}

static scalar * list_add_depends (scalar * list, scalar s)
{
  {scalar*_i=(scalar*)( list);if(_i)for(scalar t=*_i;(&t)->i>=0;t=*++_i){
    if (t.i == s.i)
      return list;}}
  scalar * list1 = list;
  {scalar*_i=(scalar*)( _attribute[s.i].depends);if(_i)for(scalar d=*_i;(&d)->i>=0;d=*++_i){
    if (_attribute[d.i].dirty)
      list1 = list_add_depends (list1, d);}}
  return list_append (list1, s);
}


void boundary_internal (scalar * list, const char * fname, int line)
{;
  if (list == 
# 402 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
             ((void *)0)
# 402 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                 )
    {;return;}
  scalar * listc = 
# 404 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
                  ((void *)0)
# 404 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                      ;
  vectorl listf = {
# 405 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
                  ((void *)0)
# 405 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                      };
  
# 406 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
 _Bool 
# 406 "/root/mnt/basilisk/src/grid/cartesian-common.h"
      flux = 
# 406 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
             0
# 406 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                  ;
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (!((s).i >= 65536) && _attribute[s.i].block > 0) {
      if (scalar_is_dirty (s)) {
 if (_attribute[s.i].face && _attribute[s.i].dirty != 2)
   {
     if (_attribute[s.i].v.x.i == s.i)
       listf.x = list_add (listf.x, s), flux = 
# 413 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
                                              1
# 413 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                                                  ;
# 412 "/root/mnt/basilisk/src/grid/cartesian-common.h"
if (_attribute[s.i].v.y.i == s.i)
       listf.y = list_add (listf.y, s), flux = 
# 413 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
                                              1
# 413 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                                                  ;}
 if (!((cm).i >= 65536) && _attribute[cm.i].dirty)
   listc = list_add_depends (listc, cm);
 if (_attribute[s.i].face != 2)
   listc = list_add_depends (listc, s);
      }




    }}}
  if (flux) {
    boundary_face (listf);

      free(listf.x);
# 427 "/root/mnt/basilisk/src/grid/cartesian-common.h"
free(listf.y);
  }
  if (listc) {
    boundary_level (listc, -1);
    {scalar*_i=(scalar*)( listc);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      _attribute[s.i].dirty = 
# 432 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
                             0
# 432 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                                  ;}}
    free(listc);
  }
;}

void cartesian_boundary_level (scalar * list, int l)
{
  { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->level) _b->level (_b, list, l); };
}

void cartesian_boundary_face (vectorl list)
{

    {scalar*_i=(scalar*)( list.x);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      _attribute[s.i].dirty = 2;}}
# 445 "/root/mnt/basilisk/src/grid/cartesian-common.h"
{scalar*_i=(scalar*)( list.y);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      _attribute[s.i].dirty = 2;}}
}

static double symmetry (Point point, Point neighbor, scalar s, void * data)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  return ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)];
}

static double antisymmetry (Point point, Point neighbor, scalar s, void * data)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  return -((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)];
}

double (* default_scalar_bc[]) (Point, Point, scalar, void *) = {
  symmetry, symmetry, symmetry, symmetry, symmetry, symmetry
};

scalar cartesian_init_scalar (scalar s, const char * name)
{

  char * pname;
  if (name) {
    free(_attribute[s.i].name);
    pname = strdup(name);
  }
  else
    pname = _attribute[s.i].name;
  int block = _attribute[s.i].block;
  double (** boundary) (Point, Point, scalar, void *) = _attribute[s.i].boundary;
  double (** boundary_homogeneous) (Point, Point, scalar, void *) =
    _attribute[s.i].boundary_homogeneous;

  _attribute[s.i] = (const _Attributes){0};
  _attribute[s.i].name = pname;
  _attribute[s.i].block = block == 0 ? 1 : block;

  _attribute[s.i].boundary = boundary ? boundary :
    (double (**)(Point, Point, scalar, void *))
    malloc(nboundary*sizeof (void (*)()));
  _attribute[s.i].boundary_homogeneous = boundary_homogeneous ? boundary_homogeneous :
    (double (**)(Point, Point, scalar, void *))
    malloc(nboundary*sizeof (void (*)()));
  for (int b = 0; b < nboundary; b++)
    _attribute[s.i].boundary[b] = _attribute[s.i].boundary_homogeneous[b] =
      b < 2*2 ? default_scalar_bc[b] : symmetry;
  _attribute[s.i].gradient = 
# 491 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
                            ((void *)0)
# 491 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                                ;
   {
    _attribute[s.i].d.x = 0;
    _attribute[s.i].v.x.i = -1;
  }
# 492 "/root/mnt/basilisk/src/grid/cartesian-common.h"
{
    _attribute[s.i].d.y = 0;
    _attribute[s.i].v.y.i = -1;
  }
  _attribute[s.i].face = 
# 496 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
                        0
# 496 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                             ;
  return s;
}

scalar cartesian_init_vertex_scalar (scalar s, const char * name)
{

    _attribute[s.i].d.x = -1;
# 503 "/root/mnt/basilisk/src/grid/cartesian-common.h"
_attribute[s.i].d.y = -1;
  for (int d = 0; d < nboundary; d++)
    _attribute[s.i].boundary[d] = _attribute[s.i].boundary_homogeneous[d] = 
# 505 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
                                                                           ((void *)0)
# 505 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                                                                               ;
  return s;
}

double (* default_vector_bc[]) (Point, Point, scalar, void *) = {
  antisymmetry, antisymmetry,
  antisymmetry, antisymmetry,
  antisymmetry, antisymmetry
};

vector cartesian_init_vector (vector v, const char * name)
{
  struct { char * x, * y, * z; } ext = {".x", ".y", ".z"};
   {
    if (name) {
      char cname[strlen(name) + 3];
      sprintf (cname, "%s%s", name, ext.x);
      init_scalar (v.x, cname);
    }
    else
      init_scalar (v.x, 
# 525 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
                       ((void *)0)
# 525 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                           );
    _attribute[v.x.i].v = v;
  }
# 518 "/root/mnt/basilisk/src/grid/cartesian-common.h"
{
    if (name) {
      char cname[strlen(name) + 3];
      sprintf (cname, "%s%s", name, ext.y);
      init_scalar (v.y, cname);
    }
    else
      init_scalar (v.y, 
# 525 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
                       ((void *)0)
# 525 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                           );
    _attribute[v.y.i].v = v;
  }

  for (int d = 0; d < nboundary; d++)
    _attribute[v.x.i].boundary[d] = _attribute[v.x.i].boundary_homogeneous[d] =
      d < 2*2 ? default_vector_bc[d] : antisymmetry;
  return v;
}

vector cartesian_init_face_vector (vector v, const char * name)
{
  v = cartesian_init_vector (v, name);
   {
    _attribute[v.x.i].d.x = -1;
    _attribute[v.x.i].face = 
# 540 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
                            1
# 540 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                                ;
  }
# 538 "/root/mnt/basilisk/src/grid/cartesian-common.h"
{
    _attribute[v.y.i].d.y = -1;
    _attribute[v.y.i].face = 
# 540 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
                            1
# 540 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                                ;
  }
  for (int d = 0; d < nboundary; d++)
    _attribute[v.x.i].boundary[d] = _attribute[v.x.i].boundary_homogeneous[d] = 
# 543 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
                                                                               ((void *)0)
# 543 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                                                                                   ;
  return v;
}

tensor cartesian_init_tensor (tensor t, const char * name)
{
  struct { char * x, * y, * z; } ext = {".x", ".y", ".z"};
   {
    if (name) {
      char cname[strlen(name) + 3];
      sprintf (cname, "%s%s", name, ext.x);
      init_vector (t.x, cname);
    }
    else
      init_vector (t.x, 
# 557 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
                       ((void *)0)
# 557 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                           );
  }
# 550 "/root/mnt/basilisk/src/grid/cartesian-common.h"
{
    if (name) {
      char cname[strlen(name) + 3];
      sprintf (cname, "%s%s", name, ext.y);
      init_vector (t.y, cname);
    }
    else
      init_vector (t.y, 
# 557 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
                       ((void *)0)
# 557 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                           );
  }






    for (int b = 0; b < nboundary; b++) {
      _attribute[t.x.x.i].boundary[b] = _attribute[t.y.x.i].boundary[b] =
 _attribute[t.x.x.i].boundary_homogeneous[b] = _attribute[t.y.y.i].boundary_homogeneous[b] =
 b < 2*2 ? default_scalar_bc[b] : symmetry;
      _attribute[t.x.y.i].boundary[b] = _attribute[t.y.y.i].boundary[b] =
 _attribute[t.x.y.i].boundary_homogeneous[b] = _attribute[t.y.x.i].boundary_homogeneous[b] =
 b < 2*2 ? default_vector_bc[b] : antisymmetry;
    }



  return t;
}

struct OutputCells {
  FILE * fp;
  coord c;
  double size;
};

void output_cells (struct OutputCells p)
{
  if (!p.fp) p.fp = 
# 587 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3
                   stdout
# 587 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                       ;
  {{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
    
# 589 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
   _Bool 
# 589 "/root/mnt/basilisk/src/grid/cartesian-common.h"
        inside = 
# 589 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
                 1
# 589 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                     ;
    coord o = {x,y,z};

      if (inside && p.size > 0. &&
   (o.x > p.c.x + p.size || o.x < p.c.x - p.size))
 inside = 
# 594 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
         0
# 594 "/root/mnt/basilisk/src/grid/cartesian-common.h"
              ;
# 592 "/root/mnt/basilisk/src/grid/cartesian-common.h"
if (inside && p.size > 0. &&
   (o.y > p.c.y + p.size || o.y < p.c.y - p.size))
 inside = 
# 594 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
         0
# 594 "/root/mnt/basilisk/src/grid/cartesian-common.h"
              ;
    if (inside) {
      Delta /= 2.;



      fprintf (p.fp, "%g %g\n%g %g\n%g %g\n%g %g\n%g %g\n\n",
        x - Delta, y - Delta,
        x - Delta, y + Delta,
        x + Delta, y + Delta,
        x + Delta, y - Delta,
        x - Delta, y - Delta);
# 620 "/root/mnt/basilisk/src/grid/cartesian-common.h"
    }
  }} } };}
  fflush (p.fp);
}
# 632 "/root/mnt/basilisk/src/grid/cartesian-common.h"
static char * replace_ (const char * vname)
{
  char * name = strdup(vname), * c = name;
  while (*c != '\0') {
    if (*c == '.')
      *c = '_';
    c++;
  }
  return name;
}

static void debug_plot (FILE * fp, const char * name, const char * cells,
   const char * stencil)
{
  char * vname = replace_ (name);
  fprintf (fp,
    "  load 'debug.plot'\n"
    "  v=%s\n"




    "  plot '%s' w l lc 0, "
    "'%s' u 1+3*v:2+3*v:3+3*v w labels tc lt 1 title columnhead(3+3*v)",





    vname, cells, stencil);
  free(vname);
}

void cartesian_debug (Point point)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  char name[80] = "cells";
  if (0 > 0)
    sprintf (name, "cells-%d", 0);
  FILE * fp = fopen (name, "w");
  output_cells ((struct OutputCells){fp, (coord){x,y,z}, 4.*Delta});
  fclose (fp);

  char stencil[80] = "stencil";
  if (0 > 0)
    sprintf (stencil, "stencil-%d", 0);
  fp = fopen (stencil, "w");
  {scalar*_i=(scalar*)( all);if(_i)for(scalar v=*_i;(&v)->i>=0;v=*++_i){



    fprintf (fp, "x y %s ", _attribute[v.i].name);}}



  fputc ('\n', fp);
# 699 "/root/mnt/basilisk/src/grid/cartesian-common.h"
    for (int k = -2; k <= 2; k++)
      for (int l = -2; l <= 2; l++) {
 {scalar*_i=(scalar*)( all);if(_i)for(scalar v=*_i;(&v)->i>=0;v=*++_i){ {
   fprintf (fp, "%g %g ",
     x + k*Delta + _attribute[v.i].d.x*Delta/2.,
     y + l*Delta + _attribute[v.i].d.y*Delta/2.);
   if ((((point.i+k) >= (((Tree *)grid)->L[point.level]->m)->r1.start && (point.i+k) < (((Tree *)grid)->L[point.level]->m->r1.end) && (((Tree *)grid)->L[point.level]->m)->b[point.i+k] && (point.j+l) >= (((Tree *)grid)->L[point.level]->m)->r2[point.i+k].start && (point.j+l) < (((Tree *)grid)->L[point.level]->m)->r2[point.i+k].end && (((Tree *)grid)->L[point.level]->m)->b[point.i+k][point.j+l]) ))
     fprintf (fp, "%g ", ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+k][point.j+l]) ) + sizeof(Cell)))[(v.i)]);
   else
     fputs ("n/a ", fp);
 }}}
 fputc ('\n', fp);
      }
# 729 "/root/mnt/basilisk/src/grid/cartesian-common.h"
  fclose (fp);

  fp = fopen ("debug.plot", "w");
  fprintf (fp,
    "set term x11\n"
    "set size ratio -1\n"
    "set key outside\n");
  {scalar*_i=(scalar*)( all);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
    char * name = replace_ (_attribute[s.i].name);
    fprintf (fp, "%s = %d\n", name, s.i);
    free(name);
  }}}
  fclose (fp);

  fprintf (
# 743 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3
          stderr
# 743 "/root/mnt/basilisk/src/grid/cartesian-common.h"
              , "Last point stencils can be displayed using (in gnuplot)\n");
  debug_plot (
# 744 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3
             stderr
# 744 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                 , _attribute[0].name, name, stencil);
  fflush (
# 745 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3
         stderr
# 745 "/root/mnt/basilisk/src/grid/cartesian-common.h"
             );

  fp = fopen ("plot", "w");
  debug_plot (fp, _attribute[0].name, name, stencil);
  fclose (fp);
}

void cartesian_methods()
{
  init_scalar = cartesian_init_scalar;
  init_vertex_scalar = cartesian_init_vertex_scalar;
  init_vector = cartesian_init_vector;
  init_tensor = cartesian_init_tensor;
  init_face_vector = cartesian_init_face_vector;
  boundary_level = cartesian_boundary_level;
  boundary_face = cartesian_boundary_face;
  debug = cartesian_debug;
}

tensor init_symmetric_tensor (tensor t, const char * name)
{
  return init_tensor (t, name);
}

struct _interpolate {
  scalar v;
  double x, y, z;
};

static double interpolate_linear (Point point, struct _interpolate p)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  scalar v = p.v;







  x = (p.x - x)/Delta - _attribute[v.i].d.x/2.;
  y = (p.y - y)/Delta - _attribute[v.i].d.y/2.;
  int i = ((x) > 0 ? 1 : -1), j = ((y) > 0 ? 1 : -1);
  x = fabs(x); y = fabs(y);

  return ((((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(v.i)]*(1. - x) + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(v.i)]*x)*(1. - y) +
   (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+j]) ) + sizeof(Cell)))[(v.i)]*(1. - x) + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+j]) ) + sizeof(Cell)))[(v.i)]*x)*y);
# 803 "/root/mnt/basilisk/src/grid/cartesian-common.h"
}


double interpolate (struct _interpolate p)
{;
  scalar v = p.v;
  boundary_internal ((scalar *)((scalar[]){v,{-1}}), "/root/mnt/basilisk/src/grid/cartesian-common.h", 809);
  Point point = locate ((struct _locate){p.x, p.y, p.z});int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  if (point.level < 0)
    {;return ((double)1e30);}
  { double _ret= interpolate_linear (point, p);;return _ret;}
;}


void interpolate_array (scalar * list, coord * a, int n, double * v, 
# 817 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
                                                                    _Bool 
# 817 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                                                                         linear)
{;
  boundary_internal ((scalar *)list, "/root/mnt/basilisk/src/grid/cartesian-common.h", 819);
  int j = 0;
  for (int i = 0; i < n; i++) {
    Point point = locate ((struct _locate){a[i].x, a[i].y, a[i].z});int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    if (point.level >= 0) {
      {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
 v[j++] = !linear ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] :
   interpolate_linear (point,
         (struct _interpolate){s, a[i].x, a[i].y, a[i].z});}}
    }
    else
      {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
 v[j++] = ((double)1e30);}}
  }
# 841 "/root/mnt/basilisk/src/grid/cartesian-common.h"
;}



typedef int bid;

bid new_bid()
{
  int b = nboundary++;
  {scalar*_i=(scalar*)( all);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
    _attribute[s.i].boundary = (double (**)(Point, Point, scalar, void *))
      realloc(_attribute[s.i].boundary,nboundary*sizeof (void (*)()));
    _attribute[s.i].boundary_homogeneous = (double (**)(Point, Point, scalar, void *))
      realloc(_attribute[s.i].boundary_homogeneous,nboundary*sizeof (void (*)()));
  }}}
  {scalar*_i=(scalar*)( all);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
    if (_attribute[s.i].v.x.i < 0)
      _attribute[s.i].boundary[b] = _attribute[s.i].boundary_homogeneous[b] = symmetry;
    else if (_attribute[s.i].v.x.i == s.i) {
      vector v = _attribute[s.i].v;

 _attribute[v.y.i].boundary[b] = _attribute[v.y.i].boundary_homogeneous[b] = symmetry;
# 862 "/root/mnt/basilisk/src/grid/cartesian-common.h"
_attribute[v.x.i].boundary[b] = _attribute[v.x.i].boundary_homogeneous[b] = symmetry;
      _attribute[v.x.i].boundary[b] = _attribute[v.x.i].boundary_homogeneous[b] =
 _attribute[v.x.i].face ? 
# 864 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
                         ((void *)0) 
# 864 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                              : antisymmetry;
    }
  }}}
  return b;
}



static double periodic_bc (Point point, Point neighbor, scalar s, void * data)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  return ((double)1e30);
}

static void periodic_boundary (int d)
{

  {scalar*_i=(scalar*)( all);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    _attribute[s.i].boundary[d] = _attribute[s.i].boundary_homogeneous[d] = periodic_bc;}}

  {scalar*_i=(scalar*)( all);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (_attribute[s.i].face) {
      vector v = _attribute[s.i].v;
      _attribute[v.x.i].boundary[d] = _attribute[v.x.i].boundary_homogeneous[d] = 
# 886 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
                                                                                 ((void *)0)
# 886 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                                                                                     ;
    }}}

  default_scalar_bc[d] = periodic_bc;
  default_vector_bc[d] = periodic_bc;
}

void periodic (int dir)
{



    if (!(dir <= bottom)) qassert ("/root/mnt/basilisk/src/grid/cartesian-common.h", 898, "dir <= bottom");




  int c = dir/2;
  periodic_boundary (2*c);
  periodic_boundary (2*c + 1);
  (&Period.x)[c] = 
# 906 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
                  1
# 906 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                      ;
}


double getvalue (Point point, scalar s, int i, int j, int k)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  return ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+j]) ) + sizeof(Cell)))[(s.i)];
}

void default_stencil (Point p, scalar * list)
{
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    _attribute[s.i].input = 
# 918 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
                           1
# 918 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                               , _attribute[s.i].width = 2;}}
}




static void write_stencil_index (int * index)
{
  fprintf (
# 926 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3
          stderr
# 926 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                   , "[%d", index[0]);
  for (int d = 1; d < 2; d++)
    fprintf (
# 928 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3
            stderr
# 928 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                     , ",%d", index[d]);
  fputs ("]", 
# 929 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3
             stderr
# 929 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                      );
}

void stencil_val (Point p, scalar s, int i, int j, int k,
    const char * file, int line, 
# 933 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
                                _Bool 
# 933 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                                     overflow)
{
  if (((s).i >= 65536) || s.i < 0)
    return;
  int index[] = {i, j, k};
  for (int d = 0; d < 2; d++)
    index[d] += (&p.i)[d];
  
# 940 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
 _Bool 
# 940 "/root/mnt/basilisk/src/grid/cartesian-common.h"
      central = 
# 940 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
                1
# 940 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                    ;
  for (int d = 0; d < 2; d++) {
    if (!overflow && (index[d] > 2 || index[d] < - 2)) {
      fprintf (
# 943 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3
              stderr
# 943 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                       , "%s:%d: error: stencil overflow: %s",
        file, line, _attribute[s.i].name);
      write_stencil_index (index);
      fprintf (
# 946 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3
              stderr
# 946 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                       , "\n");
      fflush (
# 947 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3
             stderr
# 947 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                      );
      abort();
    }
    if (index[d] != 0)
      central = 
# 951 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
               0
# 951 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                    ;
  }
  if (central) {
    if (!_attribute[s.i].output)
      _attribute[s.i].input = 
# 955 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
                             1
# 955 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                                 ;
  }
  else {
    _attribute[s.i].input = 
# 958 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
                           1
# 958 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                               ;
    int d = 0;
     {
      if ((!_attribute[s.i].face || _attribute[s.i].v.x.i != s.i) && abs(index[d]) > _attribute[s.i].width)
 _attribute[s.i].width = abs(index[d]);
      d++;
    }
# 960 "/root/mnt/basilisk/src/grid/cartesian-common.h"
{
      if ((!_attribute[s.i].face || _attribute[s.i].v.y.i != s.i) && abs(index[d]) > _attribute[s.i].width)
 _attribute[s.i].width = abs(index[d]);
      d++;
    }
  }
}

void stencil_val_a (Point p, scalar s, int i, int j, int k, 
# 968 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
                                                           _Bool 
# 968 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                                                                input,
      const char * file, int line)
{
  if (((s).i >= 65536) || s.i < 0)
    abort();
  int index[] = {i, j, k};
  for (int d = 0; d < 2; d++)
    index[d] += (&p.i)[d];
  for (int d = 0; d < 2; d++)
    if (index[d] != 0) {
      fprintf (
# 978 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3
              stderr
# 978 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                       , "%s:%d: error: illegal write: %s",
        file, line, _attribute[s.i].name);
      write_stencil_index (index);
      fprintf (
# 981 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3
              stderr
# 981 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                       , "\n");
      fflush (
# 982 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3
             stderr
# 982 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                      );
      abort();
    }
  if (input && !_attribute[s.i].output)
    _attribute[s.i].input = 
# 986 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
                           1
# 986 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                               ;
  _attribute[s.i].output = 
# 987 "/root/mnt/basilisk/src/grid/cartesian-common.h" 3 4
                          1
# 987 "/root/mnt/basilisk/src/grid/cartesian-common.h"
                              ;
}
# 4 "/root/mnt/basilisk/src/grid/multigrid-common.h"
# 24 "/root/mnt/basilisk/src/grid/multigrid-common.h"
void (* restriction) (scalar *);

static inline void restriction_average (Point point, scalar s)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  double sum = 0.;
  {{ int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    sum += ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)];} } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}}
  ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] = sum/(1 << 2);
}

static inline void restriction_volume_average (Point point, scalar s)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 35 "/root/mnt/basilisk/src/grid/multigrid-common.h"
if(!((cm).i >= 65536)){{
  double sum = 0.;
  {{ int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    sum += ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(cm.i)]*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)];} } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}}
  ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] = sum/(1 << 2)/(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(cm.i)] + 1e-30);
}}else {double _const_cm=_constant[cm.i-65536];(void)(_const_cm);
# 35 "/root/mnt/basilisk/src/grid/multigrid-common.h"
{
  double sum = 0.;
  {{ int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    sum += _const_cm*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)];} } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}}
  ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] = sum/(1 << 2)/(_const_cm + 1e-30);
}}
# 40 "/root/mnt/basilisk/src/grid/multigrid-common.h"
}

static inline void face_average (Point point, vector v)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
   {




      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(v.x.i)] = (((double *) ((((((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +0][2*point.j-2 +0]) ) + sizeof(Cell)))[(v.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +0][2*point.j-2 +1]) ) + sizeof(Cell)))[(v.x.i)])/2.;
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(v.x.i)] = (((double *) ((((((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +2][2*point.j-2 +0]) ) + sizeof(Cell)))[(v.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +2][2*point.j-2 +1]) ) + sizeof(Cell)))[(v.x.i)])/2.;






  }
# 44 "/root/mnt/basilisk/src/grid/multigrid-common.h"
{




      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(v.y.i)] = (((double *) ((((((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +0][2*point.j-2 +0]) ) + sizeof(Cell)))[(v.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +1][2*point.j-2 +0]) ) + sizeof(Cell)))[(v.y.i)])/2.;
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(v.y.i)] = (((double *) ((((((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +0][2*point.j-2 +2]) ) + sizeof(Cell)))[(v.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +1][2*point.j-2 +2]) ) + sizeof(Cell)))[(v.y.i)])/2.;






  }
}

static inline void restriction_face (Point point, scalar s)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  face_average (point, _attribute[s.i].v);
}

static inline void restriction_vertex (Point point, scalar s)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  for (int i = 0; i <= 1; i++) {
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(s.i)] = ((double *) ((((((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +2*i][2*point.j-2 +0]) ) + sizeof(Cell)))[(s.i)];

    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+1]) ) + sizeof(Cell)))[(s.i)] = ((double *) ((((((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +2*i][2*point.j-2 +2]) ) + sizeof(Cell)))[(s.i)];





  }
}

static inline void no_restriction (Point point, scalar s) {int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;}

static inline void no_data (Point point, scalar s) {int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  {{ int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] = ((double)1e30);} } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}}
}

void wavelet (scalar s, scalar w)
{
  restriction (((scalar[]){s,{-1}}));
  for (int l = grid->maxdepth - 1; l >= 0; l--) {
    {{ if (l <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[l]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.level = l; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; if (!(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & leaf)) { {
      {{ int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
        ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(w.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)];} } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}}
      _attribute[s.i].prolongation (point, s);
      {{ int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
        double sp = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)];
        ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(w.i)];

        ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(w.i)] -= sp;
      }} } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}}
    }} } } }; }};}
    boundary_level (((scalar[]){w,{-1}}), l + 1);
  }

  {{ if (0 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[0]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.level = 0; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(w.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)];} } }; }};}
  boundary_level (((scalar[]){w,{-1}}), 0);
}

void inverse_wavelet (scalar s, scalar w)
{
  {{ if (0 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[0]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.level = 0; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(w.i)];} } }; }};}
  boundary_level (((scalar[]){s,{-1}}), 0);
  for (int l = 0; l <= grid->maxdepth - 1; l++) {
    {{ if (l <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[l]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.level = l; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; if (!(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & leaf)) { {
      _attribute[s.i].prolongation (point, s);
      {{ int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
        ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] += ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(w.i)];} } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}}
    }} } } }; }};}
    boundary_level (((scalar[]){s,{-1}}), l + 1);
  }
}

static inline double bilinear (Point point, scalar s)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;



    return (9.*((double *) ((((((Tree *)grid)->L[point.level-1]->m)->b[(point.i+2)/2+0][(point.j+2)/2+0]) ) + sizeof(Cell)))[(s.i)] +
     3.*(((double *) ((((((Tree *)grid)->L[point.level-1]->m)->b[(point.i+2)/2+child.x][(point.j+2)/2+0]) ) + sizeof(Cell)))[(s.i)] + ((double *) ((((((Tree *)grid)->L[point.level-1]->m)->b[(point.i+2)/2+0][(point.j+2)/2+child.y]) ) + sizeof(Cell)))[(s.i)]) +
     ((double *) ((((((Tree *)grid)->L[point.level-1]->m)->b[(point.i+2)/2+child.x][(point.j+2)/2+child.y]) ) + sizeof(Cell)))[(s.i)])/16.;
# 140 "/root/mnt/basilisk/src/grid/multigrid-common.h"
}

static inline void refine_bilinear (Point point, scalar s)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  {{ int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] = bilinear (point, s);} } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}}
}

static inline double quadratic (double a, double b, double c)
{
  return (30.*a + 5.*b - 3.*c)/32.;
}

static inline double biquadratic (Point point, scalar s)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;



  return
    quadratic (quadratic (((double *) ((((((Tree *)grid)->L[point.level-1]->m)->b[(point.i+2)/2+0][(point.j+2)/2+0]) ) + sizeof(Cell)))[(s.i)],
     ((double *) ((((((Tree *)grid)->L[point.level-1]->m)->b[(point.i+2)/2+child.x][(point.j+2)/2+0]) ) + sizeof(Cell)))[(s.i)],
     ((double *) ((((((Tree *)grid)->L[point.level-1]->m)->b[(point.i+2)/2+-child.x][(point.j+2)/2+0]) ) + sizeof(Cell)))[(s.i)]),
        quadratic (((double *) ((((((Tree *)grid)->L[point.level-1]->m)->b[(point.i+2)/2+0][(point.j+2)/2+child.y]) ) + sizeof(Cell)))[(s.i)],
     ((double *) ((((((Tree *)grid)->L[point.level-1]->m)->b[(point.i+2)/2+child.x][(point.j+2)/2+child.y]) ) + sizeof(Cell)))[(s.i)],
     ((double *) ((((((Tree *)grid)->L[point.level-1]->m)->b[(point.i+2)/2+-child.x][(point.j+2)/2+child.y]) ) + sizeof(Cell)))[(s.i)]),
        quadratic (((double *) ((((((Tree *)grid)->L[point.level-1]->m)->b[(point.i+2)/2+0][(point.j+2)/2+-child.y]) ) + sizeof(Cell)))[(s.i)],
     ((double *) ((((((Tree *)grid)->L[point.level-1]->m)->b[(point.i+2)/2+child.x][(point.j+2)/2+-child.y]) ) + sizeof(Cell)))[(s.i)],
     ((double *) ((((((Tree *)grid)->L[point.level-1]->m)->b[(point.i+2)/2+-child.x][(point.j+2)/2+-child.y]) ) + sizeof(Cell)))[(s.i)]));




}

static inline double biquadratic_vertex (Point point, scalar s)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;



  return (36.*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] + 18.*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(s.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(s.i)]) - 6.*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(s.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(s.i)]) +
   9.*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+-1]) ) + sizeof(Cell)))[(s.i)] - 3.*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+-1]) ) + sizeof(Cell)))[(s.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+1]) ) + sizeof(Cell)))[(s.i)]) + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+1]) ) + sizeof(Cell)))[(s.i)])/64.;




}

static inline void refine_biquadratic (Point point, scalar s)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  {{ int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] = biquadratic (point, s);} } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}}
}

static inline void refine_linear (Point point, scalar s)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 194 "/root/mnt/basilisk/src/grid/multigrid-common.h"
if(!((cm).i >= 65536)){{
  coord g;
  if (_attribute[s.i].gradient)
    {
      g.x = _attribute[s.i].gradient (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(s.i)], ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)], ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(s.i)]);
# 198 "/root/mnt/basilisk/src/grid/multigrid-common.h"
g.y = _attribute[s.i].gradient (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(s.i)], ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)], ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(s.i)]);}
  else
    {
      g.x = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(s.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(s.i)])/2.;
# 201 "/root/mnt/basilisk/src/grid/multigrid-common.h"
g.y = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(s.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(s.i)])/2.;}

  double sc = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)], cmc = 4.*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(cm.i)], sum = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(cm.i)]*(1 << 2);
  {{ int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] = sc;

      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] += child.x*g.x*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-child.x][point.j+0]) ) + sizeof(Cell)))[(cm.i)]/cmc;
# 207 "/root/mnt/basilisk/src/grid/multigrid-common.h"
((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] += child.y*g.y*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-child.y]) ) + sizeof(Cell)))[(cm.i)]/cmc;
    sum -= ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(cm.i)];
  }} } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}}
  if (!(fabs(sum) < 1e-10)) qassert ("/root/mnt/basilisk/src/grid/multigrid-common.h", 210, "fabs(sum) < 1e-10");
}}else {double _const_cm=_constant[cm.i-65536];(void)(_const_cm);
# 194 "/root/mnt/basilisk/src/grid/multigrid-common.h"
{
  coord g;
  if (_attribute[s.i].gradient)
    {
      g.x = _attribute[s.i].gradient (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(s.i)], ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)], ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(s.i)]);
# 198 "/root/mnt/basilisk/src/grid/multigrid-common.h"
g.y = _attribute[s.i].gradient (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(s.i)], ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)], ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(s.i)]);}
  else
    {
      g.x = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(s.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(s.i)])/2.;
# 201 "/root/mnt/basilisk/src/grid/multigrid-common.h"
g.y = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(s.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(s.i)])/2.;}

  double sc = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)], cmc = 4.*_const_cm, sum = _const_cm*(1 << 2);
  {{ int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] = sc;

      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] += child.x*g.x*_const_cm/cmc;
# 207 "/root/mnt/basilisk/src/grid/multigrid-common.h"
((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] += child.y*g.y*_const_cm/cmc;
    sum -= _const_cm;
  }} } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}}
  if (!(fabs(sum) < 1e-10)) qassert ("/root/mnt/basilisk/src/grid/multigrid-common.h", 210, "fabs(sum) < 1e-10");
}}
# 211 "/root/mnt/basilisk/src/grid/multigrid-common.h"
}

static inline void refine_reset (Point point, scalar v)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  {{ int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(v.i)] = 0.;} } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}}
}

static inline void refine_injection (Point point, scalar v)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  double val = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(v.i)];
  {{ int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(v.i)] = val;} } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}}
}

static scalar multigrid_init_scalar (scalar s, const char * name)
{
  s = cartesian_init_scalar (s, name);
  _attribute[s.i].prolongation = refine_bilinear;
  _attribute[s.i].restriction = restriction_average;
  return s;
}

static scalar multigrid_init_vertex_scalar (scalar s, const char * name)
{
  s = cartesian_init_vertex_scalar (s, name);
  _attribute[s.i].restriction = restriction_vertex;
  return s;
}

static vector multigrid_init_face_vector (vector v, const char * name)
{
  v = cartesian_init_face_vector (v, name);

    _attribute[v.y.i].restriction = no_restriction;
# 245 "/root/mnt/basilisk/src/grid/multigrid-common.h"
_attribute[v.x.i].restriction = no_restriction;
  _attribute[v.x.i].restriction = restriction_face;
  return v;
}

void multigrid_debug (Point point)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  cartesian_debug (point);

  FILE * plot = fopen ("plot", "a");
  if (point.level > 0) {
    char name[80] = "coarse";
    if (0 > 0)
      sprintf (name, "coarse-%d", 0);
    FILE * fp = fopen (name, "w");
# 271 "/root/mnt/basilisk/src/grid/multigrid-common.h"
      double xc = x - child.x*Delta/2., yc = y - child.y*Delta/2.;
      for (int k = 0; k <= 1; k++)
 for (int l = 0; l <= 1; l++) {
   {scalar*_i=(scalar*)( all);if(_i)for(scalar v=*_i;(&v)->i>=0;v=*++_i){
     fprintf (fp, "%g %g %g ",
       xc + k*child.x*Delta*2. + _attribute[v.i].d.x*Delta,
       yc + l*child.y*Delta*2. + _attribute[v.i].d.y*Delta,
       ((double *) ((((((Tree *)grid)->L[point.level-1]->m)->b[(point.i+2)/2+k*child.x][(point.j+2)/2+l*child.y]) ) + sizeof(Cell)))[(v.i)]);}}
   fputc ('\n', fp);
 }
      fprintf (
# 281 "/root/mnt/basilisk/src/grid/multigrid-common.h" 3
              stderr
# 281 "/root/mnt/basilisk/src/grid/multigrid-common.h"
                  , ", '%s' u 1+3*v:2+3*v:3+3*v w labels tc lt 3 t ''", name);
      fprintf (plot, ", '%s' u 1+3*v:2+3*v:3+3*v w labels tc lt 3 t ''", name);
# 302 "/root/mnt/basilisk/src/grid/multigrid-common.h"
    fclose (fp);
  }

  if ((((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).neighbors > 0)) {
    char name[80] = "fine";
    if (0 > 0)
      sprintf (name, "fine-%d", 0);
    FILE * fp = fopen (name, "w");
# 324 "/root/mnt/basilisk/src/grid/multigrid-common.h"
      double xf = x - Delta/4., yf = y - Delta/4.;
      for (int k = -2; k <= 3; k++)
 for (int l = -2; l <= 3; l++) {
   {scalar*_i=(scalar*)( all);if(_i)for(scalar v=*_i;(&v)->i>=0;v=*++_i){ {
     fprintf (fp, "%g %g ",
       xf + k*Delta/2. + _attribute[v.i].d.x*Delta/4.,
       yf + l*Delta/2. + _attribute[v.i].d.y*Delta/4.);
     if ((level < (grid->depth) && ((2*point.i-2 +k) >= (((Tree *)grid)->L[point.level+1]->m)->r1.start && (2*point.i-2 +k) < (((Tree *)grid)->L[point.level+1]->m->r1.end) && (((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +k] && (2*point.j-2 +l) >= (((Tree *)grid)->L[point.level+1]->m)->r2[2*point.i-2 +k].start && (2*point.j-2 +l) < (((Tree *)grid)->L[point.level+1]->m)->r2[2*point.i-2 +k].end && (((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +k][2*point.j-2 +l]) ))
       fprintf (fp, "%g ", ((double *) ((((((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +k][2*point.j-2 +l]) ) + sizeof(Cell)))[(v.i)]);
     else
       fputs ("n/a ", fp);
   }}}
   fputc ('\n', fp);
 }
      fprintf (
# 338 "/root/mnt/basilisk/src/grid/multigrid-common.h" 3
              stderr
# 338 "/root/mnt/basilisk/src/grid/multigrid-common.h"
                  , ", '%s' u 1+3*v:2+3*v:3+3*v w labels tc lt 2 t ''", name);
      fprintf (plot, ", '%s' u 1+3*v:2+3*v:3+3*v w labels tc lt 2 t ''", name);
# 362 "/root/mnt/basilisk/src/grid/multigrid-common.h"
    fclose (fp);
  }
  fflush (
# 364 "/root/mnt/basilisk/src/grid/multigrid-common.h" 3
         stderr
# 364 "/root/mnt/basilisk/src/grid/multigrid-common.h"
             );
  fclose (plot);
}

static void multigrid_restriction (scalar * list)
{
  scalar * listdef = 
# 370 "/root/mnt/basilisk/src/grid/multigrid-common.h" 3 4
                    ((void *)0)
# 370 "/root/mnt/basilisk/src/grid/multigrid-common.h"
                        , * listc = 
# 370 "/root/mnt/basilisk/src/grid/multigrid-common.h" 3 4
                                    ((void *)0)
# 370 "/root/mnt/basilisk/src/grid/multigrid-common.h"
                                        , * list2 = 
# 370 "/root/mnt/basilisk/src/grid/multigrid-common.h" 3 4
                                                    ((void *)0)
# 370 "/root/mnt/basilisk/src/grid/multigrid-common.h"
                                                        ;
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (!((s).i >= 65536) && _attribute[s.i].block > 0) {
      if (_attribute[s.i].restriction == restriction_average) {
 listdef = list_add (listdef, s);
 list2 = list_add (list2, s);
      }
      else if (_attribute[s.i].restriction != no_restriction) {
 listc = list_add (listc, s);
 if (_attribute[s.i].face)
   {
     list2 = list_add (list2, _attribute[s.i].v.x);
# 381 "/root/mnt/basilisk/src/grid/multigrid-common.h"
list2 = list_add (list2, _attribute[s.i].v.y);}
 else
   list2 = list_add (list2, s);
      }
    }}}

  if (listdef || listc) {
    for (int l = (grid->depth) - 1; l >= 0; l--) {
      {{ if (l <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[l]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.level = l; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; if (!(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & leaf)) { {
 {scalar*_i=(scalar*)( listdef);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){

     restriction_average (point, s);}}
 {scalar*_i=(scalar*)( listc);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {

     _attribute[s.i].restriction (point, s);
 }}}
      }} } } }; }};}
      { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->level) _b->level (_b, list2, l); };
    }
    free(listdef);
    free(listc);
    free(list2);
  }
}

void multigrid_methods()
{
  cartesian_methods();
  debug = multigrid_debug;
  init_scalar = multigrid_init_scalar;
  init_vertex_scalar = multigrid_init_vertex_scalar;
  init_face_vector = multigrid_init_face_vector;
  restriction = multigrid_restriction;
}







void subtree_size (scalar size, 
# 422 "/root/mnt/basilisk/src/grid/multigrid-common.h" 3 4
                               _Bool 
# 422 "/root/mnt/basilisk/src/grid/multigrid-common.h"
                                    leaves)
{




  { static ForeachData _loop = { "/root/mnt/basilisk/src/grid/multigrid-common.h", 428, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 428 "/root/mnt/basilisk/src/grid/multigrid-common.h" 3 4
 0
# 428 "/root/mnt/basilisk/src/grid/multigrid-common.h"
 ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point);
    {stencil_val_a (point, size, 0, 0, 0, 
# 429 "/root/mnt/basilisk/src/grid/multigrid-common.h" 3 4
    0
# 429 "/root/mnt/basilisk/src/grid/multigrid-common.h"
    , "/root/mnt/basilisk/src/grid/multigrid-common.h", 429); }end_stencil (&_loop); _loop.first = 0;};




  {
# 428 "/root/mnt/basilisk/src/grid/multigrid-common.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(size.i)] = 1;} } };}





  { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->restriction) _b->restriction (_b, ((scalar[]){size,{-1}}), (grid->depth)); };
  for (int l = (grid->depth) - 1; l >= 0; l--) {
    {{ if (l <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[l]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.level = l; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; if (!(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & leaf)) { {
      double sum = !leaves;
      {{ int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
 sum += ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(size.i)];} } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}}
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(size.i)] = sum;
    }} } } }; }};}
    { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->restriction) _b->restriction (_b, ((scalar[]){size,{-1}}), l); };
  }
}
# 5 "/root/mnt/basilisk/src/grid/tree-common.h"
# 21 "/root/mnt/basilisk/src/grid/tree-common.h"
int refine_cell (Point point, scalar * list, int flag, Cache * refined)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  int nr = 0;


  if (level > 0)
    for (int k = 0; k != 2*child.x; k += child.x)

      for (int l = 0; l != 2*child.y; l += child.y)




   if ((*((Cell *)((((((Tree *)grid)->L[point.level-1]->m)->b[(point.i+2)/2+k][(point.j+2)/2+l]) )))).pid >= 0 && (((*((Cell *)((((((Tree *)grid)->L[point.level-1]->m)->b[(point.i+2)/2+k][(point.j+2)/2+l]) ))))).flags & leaf)) {
     Point p = point;


     p.level = point.level - 1;
     p.i = (point.i + 2)/2 + k;
     do { if (p.i < 2) p.i += 1 << p.level; else if (p.i >= 2 + (1 << p.level)) p.i -= 1 << p.level; } while(0);

       p.j = (point.j + 2)/2 + l;
       do { if (p.j < 2) p.j += 1 << p.level; else if (p.j >= 2 + (1 << p.level)) p.j -= 1 << p.level; } while(0);





     nr += refine_cell (p, list, flag, refined);
     (*((Cell *)((((((Tree *)grid)->L[point.level-1]->m)->b[(point.i+2)/2+k][(point.j+2)/2+l]) )))).flags |= flag;
   }



  increment_neighbors (point);

  int cflag = (((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & active) ? (active|leaf) : leaf;
  {{ int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).flags |= cflag;} } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}}


  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if ((((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).pid == 0) || _attribute[s.i].face)
      _attribute[s.i].refine (point, s);}}


  (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).flags &= ~leaf;
# 93 "/root/mnt/basilisk/src/grid/tree-common.h"
  return nr;
}






# 100 "/root/mnt/basilisk/src/grid/tree-common.h" 3 4
_Bool 
# 100 "/root/mnt/basilisk/src/grid/tree-common.h"
    coarsen_cell (Point point, scalar * list)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;



  int pid = (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).pid;
  {{ int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    if ((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).neighbors || ((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).pid < 0 && (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).pid != pid))
      return 
# 108 "/root/mnt/basilisk/src/grid/tree-common.h" 3 4
            0
# 108 "/root/mnt/basilisk/src/grid/tree-common.h"
                 ;} } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}}



  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
    _attribute[s.i].restriction (point, s);
    if (_attribute[s.i].coarsen)
      _attribute[s.i].coarsen (point, s);
  }}}


  (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).flags |= leaf;


  decrement_neighbors (point);
# 135 "/root/mnt/basilisk/src/grid/tree-common.h"
  return 
# 135 "/root/mnt/basilisk/src/grid/tree-common.h" 3 4
        1
# 135 "/root/mnt/basilisk/src/grid/tree-common.h"
            ;
}

void coarsen_cell_recursive (Point point, scalar * list)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;


  {{ int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    if ((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).neighbors)
      {{ int _nn = 1 + 0 ? 1 + 0 : 2; int _i = point.i, _j = point.j; for (int _k = - _nn; _k <= _nn; _k++) { point.i = _i + _k; for (int _l = - _nn; _l <= _nn; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
 if ((!(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & leaf) && (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).neighbors && (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).pid >= 0))
   coarsen_cell_recursive (point, list);} } point.i = _i; point.j = _j;}}} } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}}

  if (!(coarsen_cell (point, list))) qassert ("/root/mnt/basilisk/src/grid/tree-common.h", 148, "coarsen_cell (point, list)");
}

void mpi_boundary_refine (scalar *);
void mpi_boundary_coarsen (int, int);
void mpi_boundary_update (scalar *);

typedef struct {
  int nc, nf;
} astats;

struct Adapt {
  scalar * slist;
  double * max;
  int maxlevel;
  int minlevel;
  scalar * list;
};


astats adapt_wavelet (struct Adapt p)
{;
  scalar * list = p.list;

  if (((cm).i >= 65536)) {
    if (list == 
# 173 "/root/mnt/basilisk/src/grid/tree-common.h" 3 4
               ((void *)0) 
# 173 "/root/mnt/basilisk/src/grid/tree-common.h"
                    || list == all)
      list = list_copy (all);
    boundary_internal ((scalar *)list, "/root/mnt/basilisk/src/grid/tree-common.h", 175);
    restriction (p.slist);
  }
  else {
    if (list == 
# 179 "/root/mnt/basilisk/src/grid/tree-common.h" 3 4
               ((void *)0) 
# 179 "/root/mnt/basilisk/src/grid/tree-common.h"
                    || list == all) {
      list = list_copy (((scalar[]){cm, fm.x,fm.y,{-1}}));
      {scalar*_i=(scalar*)( all);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
 list = list_add (list, s);}}
    }
    boundary_internal ((scalar *)list, "/root/mnt/basilisk/src/grid/tree-common.h", 184);
    scalar * listr = list_concat (p.slist, ((scalar[]){cm,{-1}}));
    restriction (listr);
    free(listr);
  }

  astats st = {0, 0};
  scalar * listc = 
# 191 "/root/mnt/basilisk/src/grid/tree-common.h" 3 4
                  ((void *)0)
# 191 "/root/mnt/basilisk/src/grid/tree-common.h"
                      ;
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (!((s).i >= 65536) && _attribute[s.i].restriction != no_restriction)
      listc = list_add (listc, s);}}


  if (p.minlevel < 1)
    p.minlevel = 1;
  ((Tree *)grid)->refined.n = 0;
  static const int refined = 1 << user, too_fine = 1 << (user + 1);
  {{ Point root = {2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point = {0}; struct { int l, i, j, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; }; if (!(((point.i+0) >= (((Tree *)grid)->L[point.level]->m)->r1.start && (point.i+0) < (((Tree *)grid)->L[point.level]->m->r1.end) && (((Tree *)grid)->L[point.level]->m)->b[point.i+0] && (point.j+0) >= (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].start && (point.j+0) < (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].end && (((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
    if ((((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & active)) {
      static const int too_coarse = 1 << (user + 2);
      if ((((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & leaf)) {
 if ((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).flags & too_coarse) {
   (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).flags &= ~too_coarse;
   refine_cell (point, listc, refined, &((Tree *)grid)->refined);
   st.nf++;
 }
 continue;
      }
      else {
 if ((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).flags & refined) {

   (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).flags &= ~too_coarse;
   continue;
 }

 
# 219 "/root/mnt/basilisk/src/grid/tree-common.h" 3 4
_Bool 
# 219 "/root/mnt/basilisk/src/grid/tree-common.h"
     local = (((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).pid == 0);
 if (!local)
   {{ int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
     if ((((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).pid == 0)) {
       local = 
# 223 "/root/mnt/basilisk/src/grid/tree-common.h" 3 4
              1
# 223 "/root/mnt/basilisk/src/grid/tree-common.h"
                  ; _k = _l = 2;
     }} } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}}
 if (local) {
   int i = 0;
   static const int just_fine = 1 << (user + 3);
   {scalar*_i=(scalar*)( p.slist);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
     double max = p.max[i++], sc[1 << 2];
     int c = 0;
     {{ int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
       sc[c++] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)];} } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}}
     _attribute[s.i].prolongation (point, s);
     c = 0;
     {{ int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
       double e = fabs(sc[c] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)]);
       if (e > max && level < p.maxlevel) {
  (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).flags &= ~too_fine;
  (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).flags |= too_coarse;
       }
       else if ((e <= max/1.5 || level > p.maxlevel) &&
         !((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).flags & (too_coarse|just_fine))) {
  if (level >= p.minlevel)
    (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).flags |= too_fine;
       }
       else if (!((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).flags & too_coarse)) {
  (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).flags &= ~too_fine;
  (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).flags |= just_fine;
       }
       ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] = sc[c++];
     }} } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}}
   }}}
   {{ int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
     (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).flags &= ~just_fine;
     if (!(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & leaf)) {
       (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).flags &= ~too_coarse;
       if (level >= p.maxlevel)
  (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).flags |= too_fine;
     }
     else if (!(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & active))
       (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).flags &= ~too_coarse;
   }} } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}}
 }
      }
    }
    else
      continue;
  }if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; } } } };}
  mpi_boundary_refine (listc);



  for (int l = (grid->depth); l >= 0; l--) {
    {{ Point root = {2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point = {0}; struct { int l, i, j, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; }; if (!(((point.i+0) >= (((Tree *)grid)->L[point.level]->m)->r1.start && (point.i+0) < (((Tree *)grid)->L[point.level]->m->r1.end) && (((Tree *)grid)->L[point.level]->m)->b[point.i+0] && (point.j+0) >= (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].start && (point.j+0) < (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].end && (((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
      if (!((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).pid < 0)) {
 if (level == l) {
   if (!(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & leaf)) {
     if ((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).flags & refined)

       (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).flags &= ~(refined|too_fine);
     else if ((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).flags & too_fine) {
       if ((((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).pid == 0) && coarsen_cell (point, listc))
  st.nc++;
       (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).flags &= ~too_fine;
     }
   }
   if ((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).flags & too_fine)
     (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).flags &= ~too_fine;
   else if (level > 0 && ((*((Cell *)((((((Tree *)grid)->L[point.level-1]->m)->b[(point.i+2)/2+0][(point.j+2)/2+0]) )))).flags & too_fine))
     (*((Cell *)((((((Tree *)grid)->L[point.level-1]->m)->b[(point.i+2)/2+0][(point.j+2)/2+0]) )))).flags &= ~too_fine;
   continue;
 }
 else if ((((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & leaf))
   continue;
      }if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; } } } };}
    mpi_boundary_coarsen (l, too_fine);
  }
  free(listc);

  ;
  ;
  if (st.nc || st.nf)
    mpi_boundary_update (list);

  if (list != p.list)
    free(list);

  {;return st;}
;}
# 331 "/root/mnt/basilisk/src/grid/tree-common.h"
static void refine_level (int depth)
{
  int refined;
  do {
    refined = 0;
    ((Tree *)grid)->refined.n = 0;
    {{ Point root = {2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point = {0}; struct { int l, i, j, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; }; if (!(((point.i+0) >= (((Tree *)grid)->L[point.level]->m)->r1.start && (point.i+0) < (((Tree *)grid)->L[point.level]->m->r1.end) && (((Tree *)grid)->L[point.level]->m)->b[point.i+0] && (point.j+0) >= (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].start && (point.j+0) < (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].end && (((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; if ((((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & leaf)) { if ((((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & active) && (((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).pid == 0)) {
      if (level < depth) {
 refine_cell (point, 
# 339 "/root/mnt/basilisk/src/grid/tree-common.h" 3 4
                    ((void *)0)
# 339 "/root/mnt/basilisk/src/grid/tree-common.h"
                        , 0, &((Tree *)grid)->refined);
 refined++;
 continue;
      }} continue; } if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; } } } };}
    ;
    if (refined) {
      mpi_boundary_refine (
# 345 "/root/mnt/basilisk/src/grid/tree-common.h" 3 4
                          ((void *)0)
# 345 "/root/mnt/basilisk/src/grid/tree-common.h"
                              );
      mpi_boundary_update (
# 346 "/root/mnt/basilisk/src/grid/tree-common.h" 3 4
                          ((void *)0)
# 346 "/root/mnt/basilisk/src/grid/tree-common.h"
                              );
    }
  } while (refined);
}
# 376 "/root/mnt/basilisk/src/grid/tree-common.h"

static void halo_face (vectorl vl)
{;

    {scalar*_i=(scalar*)( vl.x);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      _attribute[s.i].dirty = 2;}}
# 380 "/root/mnt/basilisk/src/grid/tree-common.h"
{scalar*_i=(scalar*)( vl.y);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      _attribute[s.i].dirty = 2;}}

  for (int l = (grid->depth) - 1; l >= 0; l--)
    {{ if (l <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _cache = ((Tree *)grid)->prolongation[l]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.level = l; int _k; for (_k = 0; _k < _cache.n; _k++) { point.i = _cache.p[_k].i; point.j = _cache.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
      {
        if (vl.x) {
# 395 "/root/mnt/basilisk/src/grid/tree-common.h"
   if ((!(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ))))).flags & leaf) && (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) )))).neighbors && (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) )))).pid >= 0))
     {scalar*_i=(scalar*)( vl.x);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
       ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] = (((double *) ((((((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +0][2*point.j-2 +0]) ) + sizeof(Cell)))[(s.i)] + ((double *) ((((((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +0][2*point.j-2 +1]) ) + sizeof(Cell)))[(s.i)])/2.;}}
   if ((!(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ))))).flags & leaf) && (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) )))).neighbors && (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) )))).pid >= 0))
     {scalar*_i=(scalar*)( vl.x);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
       ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(s.i)] = (((double *) ((((((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +2][2*point.j-2 +0]) ) + sizeof(Cell)))[(s.i)] + ((double *) ((((((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +2][2*point.j-2 +1]) ) + sizeof(Cell)))[(s.i)])/2.;}}
# 411 "/root/mnt/basilisk/src/grid/tree-common.h"
 }
# 386 "/root/mnt/basilisk/src/grid/tree-common.h"
if (vl.y) {
# 395 "/root/mnt/basilisk/src/grid/tree-common.h"
   if ((!(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ))))).flags & leaf) && (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) )))).neighbors && (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) )))).pid >= 0))
     {scalar*_i=(scalar*)( vl.y);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
       ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] = (((double *) ((((((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +0][2*point.j-2 +0]) ) + sizeof(Cell)))[(s.i)] + ((double *) ((((((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +1][2*point.j-2 +0]) ) + sizeof(Cell)))[(s.i)])/2.;}}
   if ((!(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ))))).flags & leaf) && (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) )))).neighbors && (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) )))).pid >= 0))
     {scalar*_i=(scalar*)( vl.y);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
       ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(s.i)] = (((double *) ((((((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +0][2*point.j-2 +2]) ) + sizeof(Cell)))[(s.i)] + ((double *) ((((((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +1][2*point.j-2 +2]) ) + sizeof(Cell)))[(s.i)])/2.;}}
# 411 "/root/mnt/basilisk/src/grid/tree-common.h"
 }}} } }; }};}
;}



static scalar tree_init_scalar (scalar s, const char * name)
{
  s = multigrid_init_scalar (s, name);
  _attribute[s.i].refine = _attribute[s.i].prolongation;
  return s;
}

static void prolongation_vertex (Point point, scalar s)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;

  ((double *) ((((((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +1][2*point.j-2 +1]) ) + sizeof(Cell)))[(s.i)] = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(s.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(s.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+1]) ) + sizeof(Cell)))[(s.i)])/4.;





  for (int i = 0; i <= 1; i++) {
    for (int j = 0; j <= 1; j++)





      if ((level < (grid->depth) && ((2*point.i-2 +2*i) >= (((Tree *)grid)->L[point.level+1]->m)->r1.start && (2*point.i-2 +2*i) < (((Tree *)grid)->L[point.level+1]->m->r1.end) && (((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +2*i] && (2*point.j-2 +2*j) >= (((Tree *)grid)->L[point.level+1]->m)->r2[2*point.i-2 +2*i].start && (2*point.j-2 +2*j) < (((Tree *)grid)->L[point.level+1]->m)->r2[2*point.i-2 +2*i].end && (((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +2*i][2*point.j-2 +2*j]) ))
 ((double *) ((((((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +2*i][2*point.j-2 +2*j]) ) + sizeof(Cell)))[(s.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+j]) ) + sizeof(Cell)))[(s.i)];



      if ((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) )))).neighbors) {

 ((double *) ((((((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +2*i][2*point.j-2 +1]) ) + sizeof(Cell)))[(s.i)] = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(s.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+1]) ) + sizeof(Cell)))[(s.i)])/2.;
# 456 "/root/mnt/basilisk/src/grid/tree-common.h"
      }
# 444 "/root/mnt/basilisk/src/grid/tree-common.h"
if ((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) )))).neighbors) {

 ((double *) ((((((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +1][2*point.j-2 +2*i]) ) + sizeof(Cell)))[(s.i)] = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(s.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+i]) ) + sizeof(Cell)))[(s.i)])/2.;
# 456 "/root/mnt/basilisk/src/grid/tree-common.h"
      }
  }
}

static scalar tree_init_vertex_scalar (scalar s, const char * name)
{
  s = multigrid_init_vertex_scalar (s, name);
  _attribute[s.i].refine = _attribute[s.i].prolongation = prolongation_vertex;
  return s;
}


static void refine_face_x (Point point, scalar s)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  vector v = _attribute[s.i].v;

  if (!(!(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ))))).flags & leaf) && (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) )))).neighbors && (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) )))).pid >= 0) &&
      ((((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).pid == 0) || (((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ))))).pid == 0))) {
    double g1 = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+ +1]) ) + sizeof(Cell)))[(v.x.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(v.x.i)])/8.;
    for (int j = 0; j <= 1; j++)
      ((double *) ((((((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +0][2*point.j-2 +j]) ) + sizeof(Cell)))[(v.x.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(v.x.i)] + (2*j - 1)*g1;
  }
  if (!(!(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ))))).flags & leaf) && (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) )))).neighbors && (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) )))).pid >= 0) && (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) )))).neighbors &&
      ((((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).pid == 0) || (((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ))))).pid == 0))) {
    double g1 = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+ +1]) ) + sizeof(Cell)))[(v.x.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+-1]) ) + sizeof(Cell)))[(v.x.i)])/8.;
    for (int j = 0; j <= 1; j++)
      ((double *) ((((((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +2][2*point.j-2 +j]) ) + sizeof(Cell)))[(v.x.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(v.x.i)] + (2*j - 1)*g1;
  }
  if ((((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).pid == 0)) {
    double g1 = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+ +1]) ) + sizeof(Cell)))[(v.x.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(v.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+ +1]) ) + sizeof(Cell)))[(v.x.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+-1]) ) + sizeof(Cell)))[(v.x.i)])/16.;
    for (int j = 0; j <= 1; j++)
      ((double *) ((((((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +1][2*point.j-2 +j]) ) + sizeof(Cell)))[(v.x.i)] = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(v.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(v.x.i)])/2. + (2*j - 1)*g1;
  }
# 514 "/root/mnt/basilisk/src/grid/tree-common.h"
}
# 468 "/root/mnt/basilisk/src/grid/tree-common.h"
static void refine_face_y (Point point, scalar s)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  vector v = _attribute[s.i].v;

  if (!(!(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ))))).flags & leaf) && (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) )))).neighbors && (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) )))).pid >= 0) &&
      ((((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).pid == 0) || (((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ))))).pid == 0))) {
    double g1 = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+ +1][point.j+0]) ) + sizeof(Cell)))[(v.y.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(v.y.i)])/8.;
    for (int j = 0; j <= 1; j++)
      ((double *) ((((((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +j][2*point.j-2 +0]) ) + sizeof(Cell)))[(v.y.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(v.y.i)] + (2*j - 1)*g1;
  }
  if (!(!(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ))))).flags & leaf) && (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) )))).neighbors && (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) )))).pid >= 0) && (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) )))).neighbors &&
      ((((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).pid == 0) || (((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ))))).pid == 0))) {
    double g1 = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+ +1][point.j+1]) ) + sizeof(Cell)))[(v.y.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+1]) ) + sizeof(Cell)))[(v.y.i)])/8.;
    for (int j = 0; j <= 1; j++)
      ((double *) ((((((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +j][2*point.j-2 +2]) ) + sizeof(Cell)))[(v.y.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(v.y.i)] + (2*j - 1)*g1;
  }
  if ((((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).pid == 0)) {
    double g1 = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+ +1][point.j+0]) ) + sizeof(Cell)))[(v.y.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(v.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+ +1][point.j+1]) ) + sizeof(Cell)))[(v.y.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+1]) ) + sizeof(Cell)))[(v.y.i)])/16.;
    for (int j = 0; j <= 1; j++)
      ((double *) ((((((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +j][2*point.j-2 +1]) ) + sizeof(Cell)))[(v.y.i)] = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(v.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(v.y.i)])/2. + (2*j - 1)*g1;
  }
# 514 "/root/mnt/basilisk/src/grid/tree-common.h"
}

void refine_face (Point point, scalar s)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  vector v = _attribute[s.i].v;

    _attribute[v.x.i].prolongation (point, v.x);
# 520 "/root/mnt/basilisk/src/grid/tree-common.h"
_attribute[v.y.i].prolongation (point, v.y);
}

void refine_face_solenoidal (Point point, scalar s)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  refine_face (point, s);

  if ((((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).pid == 0)) {

    vector v = _attribute[s.i].v;
    double d[1 << 2], p[1 << 2];
    int i = 0;
    {{ int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
      d[i] = 0.;

 d[i] += ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(v.x.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(v.x.i)];
# 535 "/root/mnt/basilisk/src/grid/tree-common.h"
d[i] += ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(v.y.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(v.y.i)];
      i++;
    }} } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}}

    p[0] = 0.;
    p[1] = (3.*d[3] + d[0])/4. + d[2]/2.;
    p[2] = (d[3] + 3.*d[0])/4. + d[2]/2.;
    p[3] = (d[3] + d[0])/2. + d[2];
    ((double *) ((((((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +1][2*point.j-2 +1]) ) + sizeof(Cell)))[(v.x.i)] += p[1] - p[0];
    ((double *) ((((((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +1][2*point.j-2 +0]) ) + sizeof(Cell)))[(v.x.i)] += p[3] - p[2];
    ((double *) ((((((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +0][2*point.j-2 +1]) ) + sizeof(Cell)))[(v.y.i)] += p[0] - p[2];
    ((double *) ((((((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +1][2*point.j-2 +1]) ) + sizeof(Cell)))[(v.y.i)] += p[1] - p[3];
# 574 "/root/mnt/basilisk/src/grid/tree-common.h"
  }

}

vector tree_init_face_vector (vector v, const char * name)
{
  v = cartesian_init_face_vector (v, name);

    _attribute[v.x.i].restriction = _attribute[v.x.i].refine = no_restriction;
# 582 "/root/mnt/basilisk/src/grid/tree-common.h"
_attribute[v.y.i].restriction = _attribute[v.y.i].refine = no_restriction;
  _attribute[v.x.i].restriction = restriction_face;
  _attribute[v.x.i].refine = refine_face;

    _attribute[v.x.i].prolongation = refine_face_x;
# 586 "/root/mnt/basilisk/src/grid/tree-common.h"
_attribute[v.y.i].prolongation = refine_face_y;
  return v;
}


static void tree_boundary_level (scalar * list, int l)
{;
  int depth = l < 0 ? (grid->depth) : l;

  if (tree_is_full()) {
    { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->level) _b->level (_b, list, depth); };
    {;return;}
  }

  scalar * listdef = 
# 600 "/root/mnt/basilisk/src/grid/tree-common.h" 3 4
                    ((void *)0)
# 600 "/root/mnt/basilisk/src/grid/tree-common.h"
                        , * listc = 
# 600 "/root/mnt/basilisk/src/grid/tree-common.h" 3 4
                                    ((void *)0)
# 600 "/root/mnt/basilisk/src/grid/tree-common.h"
                                        , * list2 = 
# 600 "/root/mnt/basilisk/src/grid/tree-common.h" 3 4
                                                    ((void *)0)
# 600 "/root/mnt/basilisk/src/grid/tree-common.h"
                                                        , * vlist = 
# 600 "/root/mnt/basilisk/src/grid/tree-common.h" 3 4
                                                                    ((void *)0)
# 600 "/root/mnt/basilisk/src/grid/tree-common.h"
                                                                        ;
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (!((s).i >= 65536)) {
      if (_attribute[s.i].restriction == restriction_average) {
 listdef = list_add (listdef, s);
 list2 = list_add (list2, s);
      }
      else if (_attribute[s.i].restriction != no_restriction) {
 listc = list_add (listc, s);
 if (_attribute[s.i].face)
   {
     list2 = list_add (list2, _attribute[s.i].v.x);
# 611 "/root/mnt/basilisk/src/grid/tree-common.h"
list2 = list_add (list2, _attribute[s.i].v.y);}
 else {
   list2 = list_add (list2, s);
   if (_attribute[s.i].restriction == restriction_vertex)
     vlist = list_add (vlist, s);
 }
      }
    }}}

  if (vlist)






    {{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->vertices.n; _k++) { point.i = ((Tree *)grid)->vertices.p[_k].i; point.j = ((Tree *)grid)->vertices.p[_k].j; point.level = ((Tree *)grid)->vertices.p[_k].level; _flags = ((Tree *)grid)->vertices.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { x -= Delta/2.; y -= Delta/2.; {
      if ((!(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & leaf) && (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).neighbors && (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).pid >= 0) || (!(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ))))).flags & leaf) && (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) )))).neighbors && (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) )))).pid >= 0) ||
   (!(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ))))).flags & leaf) && (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) )))).neighbors && (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) )))).pid >= 0) || (!(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+-1]) ))))).flags & leaf) && (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+-1]) )))).neighbors && (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+-1]) )))).pid >= 0)) {

 {scalar*_i=(scalar*)( vlist);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
   ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] = (((*((Cell *)((((((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +0][2*point.j-2 +0]) ))))).flags & vertex) ? ((double *) ((((((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +0][2*point.j-2 +0]) ) + sizeof(Cell)))[(s.i)] : ((double)1e30);}}
      }
      else
 {
   if (child.y == 1 &&
       ((!(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & leaf) && !(*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).neighbors && (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).pid >= 0) || (!(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ))))).flags & leaf) && !(*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) )))).neighbors && (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) )))).pid >= 0))) {

     {scalar*_i=(scalar*)( vlist);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
       ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] = (((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ))))).flags & vertex) && (((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ))))).flags & vertex) ?
  (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(s.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(s.i)])/2. : ((double)1e30);}}
   }
# 636 "/root/mnt/basilisk/src/grid/tree-common.h"
if (child.x == 1 &&
       ((!(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & leaf) && !(*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).neighbors && (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).pid >= 0) || (!(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ))))).flags & leaf) && !(*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) )))).neighbors && (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) )))).pid >= 0))) {

     {scalar*_i=(scalar*)( vlist);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
       ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] = (((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ))))).flags & vertex) && (((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ))))).flags & vertex) ?
  (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(s.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(s.i)])/2. : ((double)1e30);}}
   }}
    }} } } };}
# 676 "/root/mnt/basilisk/src/grid/tree-common.h"
  free(vlist);

  if (listdef || listc) {
    { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->restriction) _b->restriction (_b, list2, depth); };
    for (int l = depth - 1; l >= 0; l--) {
      {{ if (l <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[l]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.level = l; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; if (!(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & leaf)) { {
 {scalar*_i=(scalar*)( listdef);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
   restriction_average (point, s);}}
 {scalar*_i=(scalar*)( listc);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
   _attribute[s.i].restriction (point, s);}}
      }} } } }; }};}
      { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->restriction) _b->restriction (_b, list2, l); };
    }
    free(listdef);
    free(listc);
    free(list2);
  }

  scalar * listr = 
# 694 "/root/mnt/basilisk/src/grid/tree-common.h" 3 4
                  ((void *)0)
# 694 "/root/mnt/basilisk/src/grid/tree-common.h"
                      ;
  vector * listf = 
# 695 "/root/mnt/basilisk/src/grid/tree-common.h" 3 4
                  ((void *)0)
# 695 "/root/mnt/basilisk/src/grid/tree-common.h"
                      ;
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (!((s).i >= 65536) && _attribute[s.i].refine != no_restriction) {
      if (_attribute[s.i].face)
 listf = vectors_add (listf, _attribute[s.i].v);
      else
 listr = list_add (listr, s);
    }}}

  if (listr || listf) {
    { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->level) _b->level (_b, list, 0); };
    for (int i = 0; i < depth; i++) {
      {{ if (i <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _cache = ((Tree *)grid)->prolongation[i]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.level = i; int _k; for (_k = 0; _k < _cache.n; _k++) { point.i = _cache.p[_k].i; point.j = _cache.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
 {scalar*_i=(scalar*)( listr);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
          _attribute[s.i].prolongation (point, s);}}
 {vector*_i=(vector*)( listf);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){
   {
     _attribute[v.x.i].prolongation (point, v.x);
# 712 "/root/mnt/basilisk/src/grid/tree-common.h"
_attribute[v.y.i].prolongation (point, v.y);}}}
      }} } }; }};}
      { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->level) _b->level (_b, list, i + 1); };
    }
    free(listr);
    free(listf);
  }
;}

double treex (Point point) {int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  if (level == 0)
    return 0;

  double i = 2*child.x - child.y;
  if (i <= 1 && i >= -1) i = -i;




  return treex(parent) + i/(1 << 2*(level - 1));
}

double treey (Point point) {int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  if (level == 0)
    return 0;
  return treey(parent) + 4./(1 << 2*(level - 1));
}

void output_tree (FILE * fp)
{
  {{ Point root = {2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point = {0}; struct { int l, i, j, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; }; if (!(((point.i+0) >= (((Tree *)grid)->L[point.level]->m)->r1.start && (point.i+0) < (((Tree *)grid)->L[point.level]->m->r1.end) && (((Tree *)grid)->L[point.level]->m)->b[point.i+0] && (point.j+0) >= (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].start && (point.j+0) < (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].end && (((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    if ((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).neighbors)
      {{ int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
 if ((((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).pid == 0))
   fprintf (fp, "%g %g\n%g %g\n\n",
     treex(parent), treey(parent), treex(point), treey(point));} } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}}if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; } } } };}
}


void tree_check()
{;


  long nleaves = 0, nactive = 0;
  {{ Point root = {0}; for (root.i = 2*Period.x; root.i <= 2*(2 - Period.x); root.i++) for (root.j = 2*Period.y; root.j <= 2*(2 - Period.y); root.j++) { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point = {0}; struct { int l, i, j, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; }; if (!(((point.i+0) >= (((Tree *)grid)->L[point.level]->m)->r1.start && (point.i+0) < (((Tree *)grid)->L[point.level]->m->r1.end) && (((Tree *)grid)->L[point.level]->m)->b[point.i+0] && (point.j+0) >= (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].start && (point.j+0) < (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].end && (((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
    if ((((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & leaf)) {
      if (!((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).pid >= 0)) qassert ("/root/mnt/basilisk/src/grid/tree-common.h", 758, "cell.pid >= 0");
      nleaves++;
    }
    if ((((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).pid == 0))
      if (!((((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & active) || (!(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & leaf) && !(*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).neighbors && (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).pid >= 0))) qassert ("/root/mnt/basilisk/src/grid/tree-common.h", 762, "is_active(cell) || is_prolongation(cell)");
    if ((((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & active))
      nactive++;

    int neighbors = 0;
    {{ int _nn = 1 + 0 ? 1 + 0 : 2; int _i = point.i, _j = point.j; for (int _k = - _nn; _k <= _nn; _k++) { point.i = _i + _k; for (int _l = - _nn; _l <= _nn; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
      if ((((point.i+0) >= (((Tree *)grid)->L[point.level]->m)->r1.start && (point.i+0) < (((Tree *)grid)->L[point.level]->m->r1.end) && (((Tree *)grid)->L[point.level]->m)->b[point.i+0] && (point.j+0) >= (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].start && (point.j+0) < (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].end && (((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) && (!(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & leaf) && (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).neighbors && (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).pid >= 0))
 neighbors++;} } point.i = _i; point.j = _j;}}
    if (!((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).neighbors == neighbors)) qassert ("/root/mnt/basilisk/src/grid/tree-common.h", 770, "cell.neighbors == neighbors");


    if (!(*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).neighbors)
      if (!(!(level < (grid->depth) && ((2*point.i-2 +0) >= (((Tree *)grid)->L[point.level+1]->m)->r1.start && (2*point.i-2 +0) < (((Tree *)grid)->L[point.level+1]->m->r1.end) && (((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +0] && (2*point.j-2 +0) >= (((Tree *)grid)->L[point.level+1]->m)->r2[2*point.i-2 +0].start && (2*point.j-2 +0) < (((Tree *)grid)->L[point.level+1]->m)->r2[2*point.i-2 +0].end && (((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +0][2*point.j-2 +0]) ))) qassert ("/root/mnt/basilisk/src/grid/tree-common.h", 774, "!allocated_child(0)");
  }if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; } } } };}


  long reachable = 0;
  {{ Point root = {2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point = {0}; struct { int l, i, j, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; }; if (!(((point.i+0) >= (((Tree *)grid)->L[point.level]->m)->r1.start && (point.i+0) < (((Tree *)grid)->L[point.level]->m->r1.end) && (((Tree *)grid)->L[point.level]->m)->b[point.i+0] && (point.j+0) >= (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].start && (point.j+0) < (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].end && (((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
    if ((((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & active))
      reachable++;
    else
      continue;
  }if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; } } } };}
  if (!(nactive == reachable)) qassert ("/root/mnt/basilisk/src/grid/tree-common.h", 785, "nactive == reachable");


  reachable = 0;
  {{ Point root = {2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point = {0}; struct { int l, i, j, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; }; if (!(((point.i+0) >= (((Tree *)grid)->L[point.level]->m)->r1.start && (point.i+0) < (((Tree *)grid)->L[point.level]->m->r1.end) && (((Tree *)grid)->L[point.level]->m)->b[point.i+0] && (point.j+0) >= (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].start && (point.j+0) < (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].end && (((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    if ((((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & leaf)) {
      reachable++;
      continue;
    }if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; } } } };}
  if (!(nleaves == reachable)) qassert ("/root/mnt/basilisk/src/grid/tree-common.h", 794, "nleaves == reachable");
;}


static void tree_restriction (scalar * list) {;
  boundary_internal ((scalar *)list, "/root/mnt/basilisk/src/grid/tree-common.h", 799);
  if (tree_is_full())
    multigrid_restriction (list);
;}

void tree_methods()
{
  multigrid_methods();
  init_scalar = tree_init_scalar;
  init_vertex_scalar = tree_init_vertex_scalar;
  init_face_vector = tree_init_face_vector;
  boundary_level = tree_boundary_level;
  boundary_face = halo_face;
  restriction = tree_restriction;
}
# 1672 "/root/mnt/basilisk/src/grid/tree.h"


void tree_periodic (int dir)
{
  int depth = grid ? (grid->depth) : -1;
  if (grid)
    free_grid();
  periodic (dir);
  if (depth >= 0)
    init_grid (1 << depth);
}
# 3485 "/root/mnt/basilisk/src/grid/tree.h"
void mpi_boundary_refine (scalar * list){}
void mpi_boundary_coarsen (int a, int b){}
void mpi_boundary_update (scalar * list) {
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    _attribute[s.i].dirty = 
# 3489 "/root/mnt/basilisk/src/grid/tree.h" 3 4
                           1
# 3489 "/root/mnt/basilisk/src/grid/tree.h"
                               ;}}
  boundary_internal ((scalar *)list, "/root/mnt/basilisk/src/grid/tree.h", 1694);
}
# 4 "/root/mnt/basilisk/src/grid/quadtree.h"

void quadtree_methods() {
  tree_methods();
}
# 15 "rising-cpp.c"
# 1 "rising.c"
# 18 "rising.c"
# 1 "navier-stokes/centered.h"
# 1 "/root/mnt/basilisk/src/navier-stokes/centered.h"
# 27 "/root/mnt/basilisk/src/navier-stokes/centered.h"
# 1 "./run.h"
# 1 "/root/mnt/basilisk/src/run.h"
# 9 "/root/mnt/basilisk/src/run.h"
double dt = 1.;
# 1 "./utils.h"
# 1 "/root/mnt/basilisk/src/utils.h"







double DT = 1e10, CFL = 0.5;




struct {

  long nc;

  long tnc;

  double t;

  double speed;

  timer gt;
} perf;





void update_perf() {
  perf.nc += grid->n;
  perf.tnc += grid->tn;
  perf.t = timer_elapsed (perf.gt);
  perf.speed = perf.tnc/perf.t;
}






typedef struct {
  double cpu;
  double real;
  double speed;
  double min;
  double avg;
  double max;
  size_t tnc;
  long mem;
} timing;






timing timer_timing (timer t, int i, size_t tnc, double * mpi)
{
  timing s;



  clock_t end = clock();
  s.cpu = ((double) (end - t.c))/
# 65 "/root/mnt/basilisk/src/utils.h" 3
                                ((__clock_t) 1000000)
# 65 "/root/mnt/basilisk/src/utils.h"
                                              ;
  s.real = timer_elapsed (t);
  if (tnc == 0) {
    double n = 0;



{
# 69 "/root/mnt/basilisk/src/utils.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; n++;} } };;


}
# 70 "/root/mnt/basilisk/src/utils.h"
s.tnc = n;
    tnc = n*i;
  }
  else
    s.tnc = tnc;

  struct rusage usage;
  getrusage (
# 77 "/root/mnt/basilisk/src/utils.h" 3
            RUSAGE_SELF
# 77 "/root/mnt/basilisk/src/utils.h"
                       , &usage);
  s.mem = usage.ru_maxrss;
# 95 "/root/mnt/basilisk/src/utils.h"
  s.min = s.max = s.avg = 0.;

  s.speed = s.real > 0. ? tnc/s.real : -1.;
  return s;
}




void timer_print (timer t, int i, size_t tnc)
{
  timing s = timer_timing (t, i, tnc, 
# 106 "/root/mnt/basilisk/src/utils.h" 3 4
                                     ((void *)0)
# 106 "/root/mnt/basilisk/src/utils.h"
                                         );
  fprintf (
# 107 "/root/mnt/basilisk/src/utils.h" 3
          stdout
# 107 "/root/mnt/basilisk/src/utils.h"
              ,
    "\n# " "Quadtree"
    ", %d steps, %g CPU, %.4g real, %.3g points.step/s, %d var\n",
    i, s.cpu, s.real, s.speed, (int) (datasize/sizeof(double)));
# 120 "/root/mnt/basilisk/src/utils.h"
}







typedef struct {
  double avg, rms, max, volume;
} norm;

norm normf (scalar f)
{
  double avg = 0., rms = 0., max = 0., volume = 0.;
  { static ForeachData _loop = { "/root/mnt/basilisk/src/utils.h", 135, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 135 "/root/mnt/basilisk/src/utils.h" 3 4
 0
# 135 "/root/mnt/basilisk/src/utils.h"
 ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point);

    {stencil_val (point, f, 0, 0, 0, "/root/mnt/basilisk/src/utils.h", 137, 
# 137 "/root/mnt/basilisk/src/utils.h" 3 4
    0
# 137 "/root/mnt/basilisk/src/utils.h"
    );stencil_val (point, cm, 0, 0, 0, "/root/mnt/basilisk/src/utils.h", 137, 
# 137 "/root/mnt/basilisk/src/utils.h" 3 4
                          0
# 137 "/root/mnt/basilisk/src/utils.h"
                          ); {
      stencil_val (point, f, 0, 0, 0, "/root/mnt/basilisk/src/utils.h", 138, 
# 138 "/root/mnt/basilisk/src/utils.h" 3 4
     0
# 138 "/root/mnt/basilisk/src/utils.h"
     );

stencil_val (point, cm, 0, 0, 0, "/root/mnt/basilisk/src/utils.h", 140, 
# 140 "/root/mnt/basilisk/src/utils.h" 3 4
0
# 140 "/root/mnt/basilisk/src/utils.h"
);
       stencil_val (point, cm, 0, 0, 0, "/root/mnt/basilisk/src/utils.h", 141, 
# 141 "/root/mnt/basilisk/src/utils.h" 3 4
      0
# 141 "/root/mnt/basilisk/src/utils.h"
      );
       stencil_val (point, cm, 0, 0, 0, "/root/mnt/basilisk/src/utils.h", 142, 
# 142 "/root/mnt/basilisk/src/utils.h" 3 4
      0
# 142 "/root/mnt/basilisk/src/utils.h"
      );
# 143 "/root/mnt/basilisk/src/utils.h"
} }end_stencil (&_loop); _loop.first = 0;};
# 135 "/root/mnt/basilisk/src/utils.h"
if(!((cm).i >= 65536)){



                                                       {
# 135 "/root/mnt/basilisk/src/utils.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;

    if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)] != ((double)1e30) && (((Delta)*(Delta))*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(cm.i)]) > 0.) {
      double v = fabs(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)]);
      if (v > max) max = v;
      volume += (((Delta)*(Delta))*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(cm.i)]);
      avg += (((Delta)*(Delta))*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(cm.i)])*v;
      rms += (((Delta)*(Delta))*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(cm.i)])*((v)*(v));
    }} } };;;;;


}
# 143 "/root/mnt/basilisk/src/utils.h"
}else {double _const_cm=_constant[cm.i-65536];(void)(_const_cm);




                                                       {
# 135 "/root/mnt/basilisk/src/utils.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;

    if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)] != ((double)1e30) && (((Delta)*(Delta))*_const_cm) > 0.) {
      double v = fabs(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)]);
      if (v > max) max = v;
      volume += (((Delta)*(Delta))*_const_cm);
      avg += (((Delta)*(Delta))*_const_cm)*v;
      rms += (((Delta)*(Delta))*_const_cm)*((v)*(v));
    }} } };;;;;


}
# 143 "/root/mnt/basilisk/src/utils.h"
}
  norm n;
  n.avg = volume ? avg/volume : 0.;
  n.rms = volume ? sqrt(rms/volume) : 0.;
  n.max = max;
  n.volume = volume;
  return n;
}





typedef struct {
  double min, max, sum, stddev, volume;
} stats;

stats statsf (scalar f)
{
  double min = 1e100, max = -1e100, sum = 0., sum2 = 0., volume = 0.;
  { static ForeachData _loop = { "/root/mnt/basilisk/src/utils.h", 163, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 163 "/root/mnt/basilisk/src/utils.h" 3 4
 0
# 163 "/root/mnt/basilisk/src/utils.h"
 ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point);

    {stencil_val (point, cm, 0, 0, 0, "/root/mnt/basilisk/src/utils.h", 165, 
# 165 "/root/mnt/basilisk/src/utils.h" 3 4
    0
# 165 "/root/mnt/basilisk/src/utils.h"
    ); stencil_val (point, f, 0, 0, 0, "/root/mnt/basilisk/src/utils.h", 165, 
# 165 "/root/mnt/basilisk/src/utils.h" 3 4
                            0
# 165 "/root/mnt/basilisk/src/utils.h"
                            ); {
stencil_val (point, cm, 0, 0, 0, "/root/mnt/basilisk/src/utils.h", 166, 
# 166 "/root/mnt/basilisk/src/utils.h" 3 4
0
# 166 "/root/mnt/basilisk/src/utils.h"
);
       stencil_val (point, cm, 0, 0, 0, "/root/mnt/basilisk/src/utils.h", 167, 
# 167 "/root/mnt/basilisk/src/utils.h" 3 4
      0
# 167 "/root/mnt/basilisk/src/utils.h"
      );stencil_val (point, f, 0, 0, 0, "/root/mnt/basilisk/src/utils.h", 167, 
# 167 "/root/mnt/basilisk/src/utils.h" 3 4
                             0
# 167 "/root/mnt/basilisk/src/utils.h"
                             );
       stencil_val (point, cm, 0, 0, 0, "/root/mnt/basilisk/src/utils.h", 168, 
# 168 "/root/mnt/basilisk/src/utils.h" 3 4
      0
# 168 "/root/mnt/basilisk/src/utils.h"
      );stencil_val (point, f, 0, 0, 0, "/root/mnt/basilisk/src/utils.h", 168, 
# 168 "/root/mnt/basilisk/src/utils.h" 3 4
                             0
# 168 "/root/mnt/basilisk/src/utils.h"
                             );
       stencil_val (point, f, 0, 0, 0, "/root/mnt/basilisk/src/utils.h", 169, 
# 169 "/root/mnt/basilisk/src/utils.h" 3 4
      0
# 169 "/root/mnt/basilisk/src/utils.h"
      ); { stencil_val (point, f, 0, 0, 0, "/root/mnt/basilisk/src/utils.h", 169, 
# 169 "/root/mnt/basilisk/src/utils.h" 3 4
                               0
# 169 "/root/mnt/basilisk/src/utils.h"
                               ); }
stencil_val (point, f, 0, 0, 0, "/root/mnt/basilisk/src/utils.h", 170, 
# 170 "/root/mnt/basilisk/src/utils.h" 3 4
0
# 170 "/root/mnt/basilisk/src/utils.h"
); { stencil_val (point, f, 0, 0, 0, "/root/mnt/basilisk/src/utils.h", 170, 
# 170 "/root/mnt/basilisk/src/utils.h" 3 4
                        0
# 170 "/root/mnt/basilisk/src/utils.h"
                        ); }
# 171 "/root/mnt/basilisk/src/utils.h"
} }end_stencil (&_loop); _loop.first = 0;};
# 163 "/root/mnt/basilisk/src/utils.h"
if(!((cm).i >= 65536)){



                                                                            {
# 163 "/root/mnt/basilisk/src/utils.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;

    if ((((Delta)*(Delta))*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(cm.i)]) > 0. && ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)] != ((double)1e30)) {
      volume += (((Delta)*(Delta))*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(cm.i)]);
      sum += (((Delta)*(Delta))*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(cm.i)])*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)];
      sum2 += (((Delta)*(Delta))*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(cm.i)])*((((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)])*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)]));
      if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)] > max) max = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)];
      if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)] < min) min = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)];
    }} } };;;;;;


}
# 171 "/root/mnt/basilisk/src/utils.h"
}else {double _const_cm=_constant[cm.i-65536];(void)(_const_cm);




                                                                            {
# 163 "/root/mnt/basilisk/src/utils.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;

    if ((((Delta)*(Delta))*_const_cm) > 0. && ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)] != ((double)1e30)) {
      volume += (((Delta)*(Delta))*_const_cm);
      sum += (((Delta)*(Delta))*_const_cm)*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)];
      sum2 += (((Delta)*(Delta))*_const_cm)*((((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)])*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)]));
      if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)] > max) max = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)];
      if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)] < min) min = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)];
    }} } };;;;;;


}
# 171 "/root/mnt/basilisk/src/utils.h"
}
  stats s;
  s.min = min, s.max = max, s.sum = sum, s.volume = volume;
  if (volume > 0.)
    sum2 -= sum*sum/volume;
  s.stddev = sum2 > 0. ? sqrt(sum2/volume) : 0.;
  return s;
}
# 187 "/root/mnt/basilisk/src/utils.h"
static double generic_limiter (double r, double beta)
{
  double v1 = ((r) < (beta) ? (r) : (beta)), v2 = ((beta*r) < (1.) ? (beta*r) : (1.));
  v1 = ((0.) > (v1) ? (0.) : (v1));
  return ((v1) > (v2) ? (v1) : (v2));
}

double minmod (double s0, double s1, double s2) {
  return s1 == s0 ? 0. : generic_limiter ((s2 - s1)/(s1 - s0), 1.)*(s1 - s0);
}

double superbee (double s0, double s1, double s2) {
  return s1 == s0 ? 0. : generic_limiter ((s2 - s1)/(s1 - s0), 2.)*(s1 - s0);
}

double sweby (double s0, double s1, double s2) {
  return s1 == s0 ? 0. : generic_limiter ((s2 - s1)/(s1 - s0), 1.5)*(s1 - s0);
}
# 213 "/root/mnt/basilisk/src/utils.h"
double theta = 1.3;

double minmod2 (double s0, double s1, double s2)
{
  if (s0 < s1 && s1 < s2) {
    double d1 = theta*(s1 - s0), d2 = (s2 - s0)/2., d3 = theta*(s2 - s1);
    if (d2 < d1) d1 = d2;
    return ((d1) < (d3) ? (d1) : (d3));
  }
  if (s0 > s1 && s1 > s2) {
    double d1 = theta*(s1 - s0), d2 = (s2 - s0)/2., d3 = theta*(s2 - s1);
    if (d2 > d1) d1 = d2;
    return ((d1) > (d3) ? (d1) : (d3));
  }
  return 0.;
}
# 237 "/root/mnt/basilisk/src/utils.h"
void gradients (scalar * f, vector * g)
{
  if (!(list_len(f) == vectors_len(g))) qassert ("/root/mnt/basilisk/src/utils.h", 239, "list_len(f) == vectors_len(g)");
  { static ForeachData _loop = { "/root/mnt/basilisk/src/utils.h", 240, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 240 "/root/mnt/basilisk/src/utils.h" 3 4
 0
# 240 "/root/mnt/basilisk/src/utils.h"
 ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point); {
    scalar s; vector v;
    {vector*_i0=g;scalar*_i1= f;if(_i0)for(v=*_i0,s=*_i1;_i0->x.i>= 0;v=*++_i0,s=*++_i1){ {
      if (_attribute[s.i].gradient)
 { {





     stencil_val_a (point, v.x, 0, 0, 0, 
# 250 "/root/mnt/basilisk/src/utils.h" 3 4
    0
# 250 "/root/mnt/basilisk/src/utils.h"
    , "/root/mnt/basilisk/src/utils.h", 250);stencil_val (point, s, -1, 0, 0, "/root/mnt/basilisk/src/utils.h", 250, 
# 250 "/root/mnt/basilisk/src/utils.h" 3 4
                              0
# 250 "/root/mnt/basilisk/src/utils.h"
                              ); stencil_val (point, s, 0, 0, 0, "/root/mnt/basilisk/src/utils.h", 250, 
# 250 "/root/mnt/basilisk/src/utils.h" 3 4
                                                      0
# 250 "/root/mnt/basilisk/src/utils.h"
                                                      ); stencil_val (point, s, 1, 0, 0, "/root/mnt/basilisk/src/utils.h", 250, 
# 250 "/root/mnt/basilisk/src/utils.h" 3 4
                                                                             0
# 250 "/root/mnt/basilisk/src/utils.h"
                                                                             );
 }
# 244 "/root/mnt/basilisk/src/utils.h"
{





     stencil_val_a (point, v.y, 0, 0, 0, 
# 250 "/root/mnt/basilisk/src/utils.h" 3 4
    0
# 250 "/root/mnt/basilisk/src/utils.h"
    , "/root/mnt/basilisk/src/utils.h", 250);stencil_val (point, s, 0, -1, 0, "/root/mnt/basilisk/src/utils.h", 250, 
# 250 "/root/mnt/basilisk/src/utils.h" 3 4
                              0
# 250 "/root/mnt/basilisk/src/utils.h"
                              ); stencil_val (point, s, 0, 0, 0, "/root/mnt/basilisk/src/utils.h", 250, 
# 250 "/root/mnt/basilisk/src/utils.h" 3 4
                                                      0
# 250 "/root/mnt/basilisk/src/utils.h"
                                                      ); stencil_val (point, s, 0, 1, 0, "/root/mnt/basilisk/src/utils.h", 250, 
# 250 "/root/mnt/basilisk/src/utils.h" 3 4
                                                                             0
# 250 "/root/mnt/basilisk/src/utils.h"
                                                                             );
 }}
      else
 { {





     stencil_val_a (point, v.x, 0, 0, 0, 
# 259 "/root/mnt/basilisk/src/utils.h" 3 4
    0
# 259 "/root/mnt/basilisk/src/utils.h"
    , "/root/mnt/basilisk/src/utils.h", 259);stencil_val (point, s, 1, 0, 0, "/root/mnt/basilisk/src/utils.h", 259, 
# 259 "/root/mnt/basilisk/src/utils.h" 3 4
                              0
# 259 "/root/mnt/basilisk/src/utils.h"
                              ); stencil_val (point, s, -1, 0, 0, "/root/mnt/basilisk/src/utils.h", 259, 
# 259 "/root/mnt/basilisk/src/utils.h" 3 4
                                                     0
# 259 "/root/mnt/basilisk/src/utils.h"
                                                     );
 }
# 253 "/root/mnt/basilisk/src/utils.h"
{





     stencil_val_a (point, v.y, 0, 0, 0, 
# 259 "/root/mnt/basilisk/src/utils.h" 3 4
    0
# 259 "/root/mnt/basilisk/src/utils.h"
    , "/root/mnt/basilisk/src/utils.h", 259);stencil_val (point, s, 0, 1, 0, "/root/mnt/basilisk/src/utils.h", 259, 
# 259 "/root/mnt/basilisk/src/utils.h" 3 4
                              0
# 259 "/root/mnt/basilisk/src/utils.h"
                              ); stencil_val (point, s, 0, -1, 0, "/root/mnt/basilisk/src/utils.h", 259, 
# 259 "/root/mnt/basilisk/src/utils.h" 3 4
                                                     0
# 259 "/root/mnt/basilisk/src/utils.h"
                                                     );
 }}
    }}}
  }end_stencil (&_loop); _loop.first = 0;};
  {
# 240 "/root/mnt/basilisk/src/utils.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
    scalar s; vector v;
    {vector*_i0=g;scalar*_i1= f;if(_i0)for(v=*_i0,s=*_i1;_i0->x.i>= 0;v=*++_i0,s=*++_i1){ {
      if (_attribute[s.i].gradient)
 { {





     ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(v.x.i)] = _attribute[s.i].gradient (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(s.i)], ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)], ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(s.i)])/Delta;
 }
# 244 "/root/mnt/basilisk/src/utils.h"
{





     ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(v.y.i)] = _attribute[s.i].gradient (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(s.i)], ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)], ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(s.i)])/Delta;
 }}
      else
 { {





     ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(v.x.i)] = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(s.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(s.i)])/(2.*Delta);
 }
# 253 "/root/mnt/basilisk/src/utils.h"
{





     ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(v.y.i)] = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(s.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(s.i)])/(2.*Delta);
 }}
    }}}
  }} } };}
}
# 280 "/root/mnt/basilisk/src/utils.h"
void vorticity (const vector u, scalar omega)
{
  { static ForeachData _loop = { "/root/mnt/basilisk/src/utils.h", 282, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 282 "/root/mnt/basilisk/src/utils.h" 3 4
 0
# 282 "/root/mnt/basilisk/src/utils.h"
 ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point);
    {stencil_val_a (point, omega, 0, 0, 0, 
# 283 "/root/mnt/basilisk/src/utils.h" 3 4
    0
# 283 "/root/mnt/basilisk/src/utils.h"
    , "/root/mnt/basilisk/src/utils.h", 283);stencil_val (point, fm.x, 1, 0, 0, "/root/mnt/basilisk/src/utils.h", 283, 
# 283 "/root/mnt/basilisk/src/utils.h" 3 4
                                0
# 283 "/root/mnt/basilisk/src/utils.h"
                                ); stencil_val (point, fm.x, 0, 0, 0, "/root/mnt/basilisk/src/utils.h", 283, 
# 283 "/root/mnt/basilisk/src/utils.h" 3 4
                                                          0
# 283 "/root/mnt/basilisk/src/utils.h"
                                                          );stencil_val (point, u.y, 0, 0, 0, "/root/mnt/basilisk/src/utils.h", 283, 
# 283 "/root/mnt/basilisk/src/utils.h" 3 4
                                                                                   0
# 283 "/root/mnt/basilisk/src/utils.h"
                                                                                   );
        stencil_val (point, fm.x, 1, 0, 0, "/root/mnt/basilisk/src/utils.h", 284, 
# 284 "/root/mnt/basilisk/src/utils.h" 3 4
       0
# 284 "/root/mnt/basilisk/src/utils.h"
       );stencil_val (point, u.y, 1, 0, 0, "/root/mnt/basilisk/src/utils.h", 284, 
# 284 "/root/mnt/basilisk/src/utils.h" 3 4
                                0
# 284 "/root/mnt/basilisk/src/utils.h"
                                ); stencil_val (point, fm.x, 0, 0, 0, "/root/mnt/basilisk/src/utils.h", 284, 
# 284 "/root/mnt/basilisk/src/utils.h" 3 4
                                                         0
# 284 "/root/mnt/basilisk/src/utils.h"
                                                         );stencil_val (point, u.y, -1, 0, 0, "/root/mnt/basilisk/src/utils.h", 284, 
# 284 "/root/mnt/basilisk/src/utils.h" 3 4
                                                                                  0
# 284 "/root/mnt/basilisk/src/utils.h"
                                                                                  );
stencil_val (point, fm.y, 0, 1, 0, "/root/mnt/basilisk/src/utils.h", 285, 
# 285 "/root/mnt/basilisk/src/utils.h" 3 4
0
# 285 "/root/mnt/basilisk/src/utils.h"
); stencil_val (point, fm.y, 0, 0, 0, "/root/mnt/basilisk/src/utils.h", 285, 
# 285 "/root/mnt/basilisk/src/utils.h" 3 4
                         0
# 285 "/root/mnt/basilisk/src/utils.h"
                         );stencil_val (point, u.x, 0, 0, 0, "/root/mnt/basilisk/src/utils.h", 285, 
# 285 "/root/mnt/basilisk/src/utils.h" 3 4
                                                  0
# 285 "/root/mnt/basilisk/src/utils.h"
                                                  );
        stencil_val (point, fm.y, 0, 0, 0, "/root/mnt/basilisk/src/utils.h", 286, 
# 286 "/root/mnt/basilisk/src/utils.h" 3 4
       0
# 286 "/root/mnt/basilisk/src/utils.h"
       );stencil_val (point, u.x, 0, -1, 0, "/root/mnt/basilisk/src/utils.h", 286, 
# 286 "/root/mnt/basilisk/src/utils.h" 3 4
                                0
# 286 "/root/mnt/basilisk/src/utils.h"
                                ); stencil_val (point, fm.y, 0, 1, 0, "/root/mnt/basilisk/src/utils.h", 286, 
# 286 "/root/mnt/basilisk/src/utils.h" 3 4
                                                          0
# 286 "/root/mnt/basilisk/src/utils.h"
                                                          );stencil_val (point, u.x, 0, 1, 0, "/root/mnt/basilisk/src/utils.h", 286, 
# 286 "/root/mnt/basilisk/src/utils.h" 3 4
                                                                                   0
# 286 "/root/mnt/basilisk/src/utils.h"
                                                                                   );stencil_val (point, cm, 0, 0, 0, "/root/mnt/basilisk/src/utils.h", 286, 
# 286 "/root/mnt/basilisk/src/utils.h" 3 4
                                                                                                           0
# 286 "/root/mnt/basilisk/src/utils.h"
                                                                                                           );
# 286 "/root/mnt/basilisk/src/utils.h"
}end_stencil (&_loop); _loop.first = 0;};
# 282 "/root/mnt/basilisk/src/utils.h"
if(!((fm.x).i >= 65536) && !((cm).i >= 65536)){{{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(omega.i)] = ((((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)])*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] +
        ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)]*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)]*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] -
        (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(fm.y.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)])*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.x.i)] +
        ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)]*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(fm.y.i)]*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(u.x.i)])/(2.*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(cm.i)]*Delta + 0.);} } };}}else if(((fm.x).i >= 65536) && !((cm).i >= 65536)){struct{double x,y;}_const_fm={_constant[fm.x.i-65536],_constant[fm.y.i-65536]};(void)(_const_fm);
  {
# 282 "/root/mnt/basilisk/src/utils.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(omega.i)] = ((_const_fm.x - _const_fm.x)*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] +
        _const_fm.x*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] - _const_fm.x*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] -
        (_const_fm.y - _const_fm.y)*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.x.i)] +
        _const_fm.y*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(u.x.i)] - _const_fm.y*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(u.x.i)])/(2.*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(cm.i)]*Delta + 0.);} } };}}else if(!((fm.x).i >= 65536) && ((cm).i >= 65536)){double _const_cm=_constant[cm.i-65536];(void)(_const_cm);
  {
# 282 "/root/mnt/basilisk/src/utils.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(omega.i)] = ((((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)])*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] +
        ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)]*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)]*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] -
        (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(fm.y.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)])*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.x.i)] +
        ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)]*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(fm.y.i)]*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(u.x.i)])/(2.*_const_cm*Delta + 0.);} } };}}else {struct{double x,y;}_const_fm={_constant[fm.x.i-65536],_constant[fm.y.i-65536]};(void)(_const_fm);double _const_cm=_constant[cm.i-65536];(void)(_const_cm);
  {
# 282 "/root/mnt/basilisk/src/utils.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(omega.i)] = ((_const_fm.x - _const_fm.x)*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] +
        _const_fm.x*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] - _const_fm.x*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] -
        (_const_fm.y - _const_fm.y)*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.x.i)] +
        _const_fm.y*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(u.x.i)] - _const_fm.y*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(u.x.i)])/(2.*_const_cm*Delta + 0.);} } };}}
}





double change (scalar s, scalar sn)
{
  double max = 0.;
  { static ForeachData _loop = { "/root/mnt/basilisk/src/utils.h", 296, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 296 "/root/mnt/basilisk/src/utils.h" 3 4
 0
# 296 "/root/mnt/basilisk/src/utils.h"
 ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point); {
stencil_val (point, cm, 0, 0, 0, "/root/mnt/basilisk/src/utils.h", 297, 
# 297 "/root/mnt/basilisk/src/utils.h" 3 4
0
# 297 "/root/mnt/basilisk/src/utils.h"
); {
       stencil_val (point, sn, 0, 0, 0, "/root/mnt/basilisk/src/utils.h", 298, 
# 298 "/root/mnt/basilisk/src/utils.h" 3 4
      0
# 298 "/root/mnt/basilisk/src/utils.h"
      );stencil_val (point, s, 0, 0, 0, "/root/mnt/basilisk/src/utils.h", 298, 
# 298 "/root/mnt/basilisk/src/utils.h" 3 4
                             0
# 298 "/root/mnt/basilisk/src/utils.h"
                             );


    }
# 302 "/root/mnt/basilisk/src/utils.h"
stencil_val_a (point, sn, 0, 0, 0, 
# 302 "/root/mnt/basilisk/src/utils.h" 3 4
0
# 302 "/root/mnt/basilisk/src/utils.h"
, "/root/mnt/basilisk/src/utils.h", 302); stencil_val (point, s, 0, 0, 0, "/root/mnt/basilisk/src/utils.h", 302, 
# 302 "/root/mnt/basilisk/src/utils.h" 3 4
                         0
# 302 "/root/mnt/basilisk/src/utils.h"
                         );
  }end_stencil (&_loop); _loop.first = 0;};
# 296 "/root/mnt/basilisk/src/utils.h"
if(!((cm).i >= 65536)){


{
# 296 "/root/mnt/basilisk/src/utils.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
    if ((((Delta)*(Delta))*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(cm.i)]) > 0.) {
      double ds = fabs (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(sn.i)]);
      if (ds > max)
 max = ds;
    }
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(sn.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)];
  }} } };;


}
# 303 "/root/mnt/basilisk/src/utils.h"
}else {double _const_cm=_constant[cm.i-65536];(void)(_const_cm);



{
# 296 "/root/mnt/basilisk/src/utils.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
    if ((((Delta)*(Delta))*_const_cm) > 0.) {
      double ds = fabs (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(sn.i)]);
      if (ds > max)
 max = ds;
    }
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(sn.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)];
  }} } };;


}
# 303 "/root/mnt/basilisk/src/utils.h"
}
  return max;
}





scalar lookup_field (const char * name)
{
  if (name)
    {scalar*_i=(scalar*)( all);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      if (!strcmp (_attribute[s.i].name, name))
 return s;}}
  return (scalar){-1};
}

vector lookup_vector (const char * name)
{
  if (name) {
    char component[strlen(name) + 3];
    strcpy (component, name);
    strcat (component, ".x");
    {scalar*_i=(scalar*)( all);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      if (!strcmp (_attribute[s.i].name, component))
 return _attribute[s.i].v;}}
  }
  return (vector){{-1}};
}
# 340 "/root/mnt/basilisk/src/utils.h"
# 380 "/root/mnt/basilisk/src/utils.h"
# 410 "/root/mnt/basilisk/src/utils.h"





void fields_stats()
{
  fprintf (
# 417 "/root/mnt/basilisk/src/utils.h" 3
          stderr
# 417 "/root/mnt/basilisk/src/utils.h"
              , "# t = %g, fields = {", t);
  {scalar*_i=(scalar*)( all);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    fprintf (
# 419 "/root/mnt/basilisk/src/utils.h" 3
            stderr
# 419 "/root/mnt/basilisk/src/utils.h"
                , " %s", _attribute[s.i].name);}}
  fputs (" }\n", 
# 420 "/root/mnt/basilisk/src/utils.h" 3
                stderr
# 420 "/root/mnt/basilisk/src/utils.h"
                    );
  fprintf (
# 421 "/root/mnt/basilisk/src/utils.h" 3
          stderr
# 421 "/root/mnt/basilisk/src/utils.h"
              , "# %12s: %12s %12s %12s %12s\n",
    "name", "min", "avg", "stddev", "max");
  {scalar*_i=(scalar*)( all);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
    stats ss = statsf (s);
    fprintf (
# 425 "/root/mnt/basilisk/src/utils.h" 3
            stderr
# 425 "/root/mnt/basilisk/src/utils.h"
                , "# %12s: %12g %12g %12g %12g\n",
      _attribute[s.i].name, ss.min, ss.sum/ss.volume, ss.stddev, ss.max);
  }}}
}
# 1 "./output.h"
# 1 "/root/mnt/basilisk/src/output.h"
# 37 "/root/mnt/basilisk/src/output.h"
struct OutputField {
  scalar * list;
  FILE * fp;
  int n;
  
# 41 "/root/mnt/basilisk/src/output.h" 3 4
 _Bool 
# 41 "/root/mnt/basilisk/src/output.h"
      linear;
  double box[2][2];
};


void output_field (struct OutputField p)
{;
  if (!p.list) p.list = all;
  if (p.n == 0) p.n = N;
  if (!p.fp) p.fp = 
# 50 "/root/mnt/basilisk/src/output.h" 3
                   stdout
# 50 "/root/mnt/basilisk/src/output.h"
                       ;
  p.n++;
  if (p.box[0][0] == 0. && p.box[0][1] == 0. &&
      p.box[1][0] == 0. && p.box[1][1] == 0.) {
    p.box[0][0] = X0; p.box[0][1] = Y0;
    p.box[1][0] = X0 + L0; p.box[1][1] = Y0 + L0;
  }

  boundary_internal ((scalar *)p.list, "/root/mnt/basilisk/src/output.h", 58);
  int len = list_len(p.list);
  double Delta = 0.999999*(p.box[1][0] - p.box[0][0])/(p.n - 1);
  int ny = (p.box[1][1] - p.box[0][1])/Delta + 1;
  double ** field = (double **) matrix_new (p.n, ny, len*sizeof(double));
  for (int i = 0; i < p.n; i++) {
    double x = Delta*i + p.box[0][0];
    for (int j = 0; j < ny; j++) {
      double y = Delta*j + p.box[0][1];
      if (p.linear) {
 int k = 0;
 {scalar*_i=(scalar*)( p.list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
   field[i][len*j + k++] = interpolate ((struct _interpolate){s, x, y});}}
      }
      else {
 Point point = locate ((struct _locate){x, y});int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
 int k = 0;
 {scalar*_i=(scalar*)( p.list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
   field[i][len*j + k++] = point.level >= 0 ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] : ((double)1e30);}}
      }
    }
  }

  if (0 == 0) {




    fprintf (p.fp, "# 1:x 2:y");
    int i = 3;
    {scalar*_i=(scalar*)( p.list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      fprintf (p.fp, " %d:%s", i++, _attribute[s.i].name);}}
    fputc('\n', p.fp);
    for (int i = 0; i < p.n; i++) {
      double x = Delta*i + p.box[0][0];
      for (int j = 0; j < ny; j++) {
 double y = Delta*j + p.box[0][1];

 fprintf (p.fp, "%g %g", x, y);
 int k = 0;
 {scalar*_i=(scalar*)( p.list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
   fprintf (p.fp, " %g", field[i][len*j + k++]);}}
 fputc ('\n', p.fp);
      }
      fputc ('\n', p.fp);
    }
    fflush (p.fp);
  }






  matrix_free (field);
;}
# 141 "/root/mnt/basilisk/src/output.h"
struct OutputMatrix {
  scalar f;
  FILE * fp;
  int n;
  
# 145 "/root/mnt/basilisk/src/output.h" 3 4
 _Bool 
# 145 "/root/mnt/basilisk/src/output.h"
      linear;
};


void output_matrix (struct OutputMatrix p)
{;
  if (p.n == 0) p.n = N;
  if (!p.fp) p.fp = 
# 152 "/root/mnt/basilisk/src/output.h" 3
                   stdout
# 152 "/root/mnt/basilisk/src/output.h"
                       ;
  if (p.linear) {
    scalar f = p.f;
    boundary_internal ((scalar *)((scalar[]){f,{-1}}), "/root/mnt/basilisk/src/output.h", 155);
  }
  float fn = p.n;
  float Delta = (float) L0/fn;
  fwrite (&fn, sizeof(float), 1, p.fp);
  for (int j = 0; j < p.n; j++) {
    float yp = (float) (Delta*j + X0 + Delta/2.);
    fwrite (&yp, sizeof(float), 1, p.fp);
  }
  for (int i = 0; i < p.n; i++) {
    float xp = (float) (Delta*i + X0 + Delta/2.);
    fwrite (&xp, sizeof(float), 1, p.fp);
    for (int j = 0; j < p.n; j++) {
      float yp = (float)(Delta*j + Y0 + Delta/2.), v;
      if (p.linear)
 v = interpolate ((struct _interpolate){p.f, xp, yp});
      else {
 Point point = locate ((struct _locate){xp, yp});int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
 if (!(point.level >= 0)) qassert ("/root/mnt/basilisk/src/output.h", 173, "point.level >= 0");
 v = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(p.f.i)];
      }
      fwrite (&v, sizeof(float), 1, p.fp);
    }
  }
  fflush (p.fp);
;}
# 189 "/root/mnt/basilisk/src/output.h"
typedef void (* colormap) (double cmap[127][3]);

void jet (double cmap[127][3])
{
  for (int i = 0; i < 127; i++) {
    cmap[i][0] =
      i <= 46 ? 0. :
      i >= 111 ? -0.03125*(i - 111) + 1. :
      i >= 78 ? 1. :
      0.03125*(i - 46);
    cmap[i][1] =
      i <= 14 || i >= 111 ? 0. :
      i >= 79 ? -0.03125*(i - 111) :
      i <= 46 ? 0.03125*(i - 14) :
      1.;
    cmap[i][2] =
      i >= 79 ? 0. :
      i >= 47 ? -0.03125*(i - 79) :
      i <= 14 ? 0.03125*(i - 14) + 1.:
      1.;
  }
}

void cool_warm (double cmap[127][3])
{






  static double basemap[33][3] = {
    {0.2298057, 0.298717966, 0.753683153},
    {0.26623388, 0.353094838, 0.801466763},
    {0.30386891, 0.406535296, 0.84495867},
    {0.342804478, 0.458757618, 0.883725899},
    {0.38301334, 0.50941904, 0.917387822},
    {0.424369608, 0.558148092, 0.945619588},
    {0.46666708, 0.604562568, 0.968154911},
    {0.509635204, 0.648280772, 0.98478814},
    {0.552953156, 0.688929332, 0.995375608},
    {0.596262162, 0.726149107, 0.999836203},
    {0.639176211, 0.759599947, 0.998151185},
    {0.681291281, 0.788964712, 0.990363227},
    {0.722193294, 0.813952739, 0.976574709},
    {0.761464949, 0.834302879, 0.956945269},
    {0.798691636, 0.849786142, 0.931688648},
    {0.833466556, 0.860207984, 0.901068838},
    {0.865395197, 0.86541021, 0.865395561},
    {0.897787179, 0.848937047, 0.820880546},
    {0.924127593, 0.827384882, 0.774508472},
    {0.944468518, 0.800927443, 0.726736146},
    {0.958852946, 0.769767752, 0.678007945},
    {0.96732803, 0.734132809, 0.628751763},
    {0.969954137, 0.694266682, 0.579375448},
    {0.966811177, 0.650421156, 0.530263762},
    {0.958003065, 0.602842431, 0.481775914},
    {0.943660866, 0.551750968, 0.434243684},
    {0.923944917, 0.49730856, 0.387970225},
    {0.89904617, 0.439559467, 0.343229596},
    {0.869186849, 0.378313092, 0.300267182},
    {0.834620542, 0.312874446, 0.259301199},
    {0.795631745, 0.24128379, 0.220525627},
    {0.752534934, 0.157246067, 0.184115123},
    {0.705673158, 0.01555616, 0.150232812}
  };

  for (int i = 0; i < 127; i++) {
    double x = i*(32 - 1e-10)/(127 - 1);
    int j = x; x -= j;
    for (int k = 0; k < 3; k++)
      cmap[i][k] = (1. - x)*basemap[j][k] + x*basemap[j+1][k];
  }
}

void gray (double cmap[127][3])
{
  for (int i = 0; i < 127; i++)
    for (int k = 0; k < 3; k++)
      cmap[i][k] = i/(127 - 1.);
}

void randomap (double cmap[127][3])
{
  srand(0);
  for (int i = 0; i < 127; i++)
    for (int k = 0; k < 3; k++)
      cmap[i][k] = ((1. - 2.*rand()/(double)
# 276 "/root/mnt/basilisk/src/output.h" 3
                   2147483647
# 276 "/root/mnt/basilisk/src/output.h"
                   ) + 1.)/2.;
}

void blue_white_red (double cmap[127][3])
{
  for (int i = 0; i < (127 + 1)/2; i++) {
    cmap[i][0] = i/((127 - 1)/2.);
    cmap[i][1] = i/((127 - 1)/2.);
    cmap[i][2] = 1.;
  }
  for (int i = 0; i < (127 - 1)/2; i++) {
    cmap[i + (127 + 1)/2][0] = 1.;
    cmap[i + (127 + 1)/2][1] = cmap[(127 - 3)/2 - i][1];
    cmap[i + (127 + 1)/2][2] = cmap[(127 - 3)/2 - i][1];
  }
}





typedef struct {
  unsigned char r, g, b;
} color;

color colormap_color (double cmap[127][3],
        double val, double min, double max)
{
  color c;
  if (val == ((double)1e30)) {
    c.r = c.g = c.b = 0;
    return c;
  }
  int i;
  double coef;
  if (max != min)
    val = (val - min)/(max - min);
  else
    val = 0.;
  if (val <= 0.) i = 0, coef = 0.;
  else if (val >= 1.) i = 127 - 2, coef = 1.;
  else {
    i = val*(127 - 1);
    coef = val*(127 - 1) - i;
  }
  if (!(i < 127 - 1)) qassert ("/root/mnt/basilisk/src/output.h", 321, "i < NCMAP - 1");
  unsigned char * c1 = (unsigned char *) &c;
  for (int j = 0; j < 3; j++)
    c1[j] = 255*(cmap[i][j]*(1. - coef) + cmap[i + 1][j]*coef);
  return c;
}
# 340 "/root/mnt/basilisk/src/output.h"
static const char * extension (const char * file, const char * ext) {
  int len = strlen(file);
  return len > 4 && !strcmp (file + len - 4, ext) ? file + len - 4 : 
# 342 "/root/mnt/basilisk/src/output.h" 3 4
                                                                    ((void *)0)
# 342 "/root/mnt/basilisk/src/output.h"
                                                                        ;
}

static const char * is_animation (const char * file) {
  const char * ext;
  if ((ext = extension (file, ".mp4")) ||
      (ext = extension (file, ".ogv")) ||
      (ext = extension (file, ".gif")))
    return ext;
  return 
# 351 "/root/mnt/basilisk/src/output.h" 3 4
        ((void *)0)
# 351 "/root/mnt/basilisk/src/output.h"
            ;
}

static struct {
  FILE ** fp;
  char ** names;
  int n;
} open_image_data = {
# 358 "/root/mnt/basilisk/src/output.h" 3 4
                    ((void *)0)
# 358 "/root/mnt/basilisk/src/output.h"
                        , 
# 358 "/root/mnt/basilisk/src/output.h" 3 4
                          ((void *)0)
# 358 "/root/mnt/basilisk/src/output.h"
                              , 0};

static void open_image_cleanup()
{
  for (int i = 0; i < open_image_data.n; i++) {
    qpclose (open_image_data.fp[i]);
    free(open_image_data.names[i]);
  }
  free(open_image_data.fp);
  free(open_image_data.names);
  open_image_data.fp = 
# 368 "/root/mnt/basilisk/src/output.h" 3 4
                      ((void *)0)
# 368 "/root/mnt/basilisk/src/output.h"
                          ;
  open_image_data.names = 
# 369 "/root/mnt/basilisk/src/output.h" 3 4
                         ((void *)0)
# 369 "/root/mnt/basilisk/src/output.h"
                             ;
  open_image_data.n = 0;
}

static FILE * open_image_lookup (const char * file)
{
  for (int i = 0; i < open_image_data.n; i++)
    if (!strcmp (file, open_image_data.names[i]))
      return open_image_data.fp[i];
  return 
# 378 "/root/mnt/basilisk/src/output.h" 3 4
        ((void *)0)
# 378 "/root/mnt/basilisk/src/output.h"
            ;
}

static 
# 381 "/root/mnt/basilisk/src/output.h" 3 4
      _Bool 
# 381 "/root/mnt/basilisk/src/output.h"
           which (const char * command)
{
  char * s = getenv ("PATH");
  if (!s)
    return 
# 385 "/root/mnt/basilisk/src/output.h" 3 4
          0
# 385 "/root/mnt/basilisk/src/output.h"
               ;
  char path[strlen(s) + 1];
  strcpy (path, s);
  s = strtok (path, ":");
  while (s) {
    char f[strlen(s) + strlen(command) + 2];
    strcpy (f, s);
    strcat (f, "/");
    strcat (f, command);
    FILE * fp = fopen (f, "r");
    if (fp) {
      fclose (fp);
      return 
# 397 "/root/mnt/basilisk/src/output.h" 3 4
            1
# 397 "/root/mnt/basilisk/src/output.h"
                ;
    }
    s = strtok (
# 399 "/root/mnt/basilisk/src/output.h" 3 4
               ((void *)0)
# 399 "/root/mnt/basilisk/src/output.h"
                   , ":");
  }
  return 
# 401 "/root/mnt/basilisk/src/output.h" 3 4
        0
# 401 "/root/mnt/basilisk/src/output.h"
             ;
}

static FILE * ppm_fallback (const char * file, const char * mode)
{
  char filename[strlen(file) + 5];
  strcpy (filename, file);
  strcat (filename, ".ppm");
  FILE * fp = fopen (filename, mode);
  if (!fp) {
    perror (file);



    exit (1);
  }
  return fp;
}

FILE * open_image (const char * file, const char * options)
{
  if (!(0 == 0)) qassert ("/root/mnt/basilisk/src/output.h", 422, "pid() == 0");
  const char * ext;
  if ((ext = is_animation (file))) {
    FILE * fp = open_image_lookup (file);
    if (fp)
      return fp;

    int len = strlen ("ppm2???    ") + strlen (file) +
      (options ? strlen (options) : 0);
    char command[len];
    strcpy (command, "ppm2"); strcat (command, ext + 1);

    static int has_ffmpeg = -1;
    if (has_ffmpeg < 0) {
      if (which (command) && (which ("ffmpeg") || which ("avconv")))
 has_ffmpeg = 
# 437 "/root/mnt/basilisk/src/output.h" 3 4
             1
# 437 "/root/mnt/basilisk/src/output.h"
                 ;
      else {
 fprintf (
# 439 "/root/mnt/basilisk/src/output.h" 3
         stderr
# 439 "/root/mnt/basilisk/src/output.h"
             ,
   "open_image(): cannot find '%s' or 'ffmpeg'/'avconv'\n"
   "  falling back to raw PPM outputs\n", command);
 has_ffmpeg = 
# 442 "/root/mnt/basilisk/src/output.h" 3 4
             0
# 442 "/root/mnt/basilisk/src/output.h"
                  ;
      }
    }
    if (!has_ffmpeg)
      return ppm_fallback (file, "a");

    static 
# 448 "/root/mnt/basilisk/src/output.h" 3 4
          _Bool 
# 448 "/root/mnt/basilisk/src/output.h"
               added = 
# 448 "/root/mnt/basilisk/src/output.h" 3 4
                       0
# 448 "/root/mnt/basilisk/src/output.h"
                            ;
    if (!added) {
      free_solver_func_add (open_image_cleanup);
      added = 
# 451 "/root/mnt/basilisk/src/output.h" 3 4
             1
# 451 "/root/mnt/basilisk/src/output.h"
                 ;
    }
    open_image_data.n++;
    open_image_data.names = (char * *) realloc(open_image_data.names,(open_image_data.n)*sizeof(char *));
    open_image_data.names[open_image_data.n - 1] = strdup(file);

    if (options) {
      strcat (command, " ");
      strcat (command, options);
    }
    strcat (command, !strcmp (ext, ".mp4") ? " " : " > ");
    strcat (command, file);
    open_image_data.fp = (FILE * *) realloc(open_image_data.fp,(open_image_data.n)*sizeof(FILE *));
    return open_image_data.fp[open_image_data.n - 1] = qpopen (command, "w");
  }
  else {
    static int has_convert = -1;
    if (has_convert < 0) {
      if (which ("convert"))
 has_convert = 
# 470 "/root/mnt/basilisk/src/output.h" 3 4
              1
# 470 "/root/mnt/basilisk/src/output.h"
                  ;
      else {
 fprintf (
# 472 "/root/mnt/basilisk/src/output.h" 3
         stderr
# 472 "/root/mnt/basilisk/src/output.h"
             ,
   "open_image(): cannot find 'convert'\n"
   "  falling back to raw PPM outputs\n");
 has_convert = 
# 475 "/root/mnt/basilisk/src/output.h" 3 4
              0
# 475 "/root/mnt/basilisk/src/output.h"
                   ;
      }
    }
    if (!has_convert)
      return ppm_fallback (file, "w");

    int len = strlen ("convert ppm:-   ") + strlen (file) +
      (options ? strlen (options) : 0);
    char command[len];
    strcpy (command, "convert ppm:- ");
    if (options) {
      strcat (command, options);
      strcat (command, " ");
    }
    strcat (command, file);
    return qpopen (command, "w");
  }
}

void close_image (const char * file, FILE * fp)
{
  if (!(0 == 0)) qassert ("/root/mnt/basilisk/src/output.h", 496, "pid() == 0");
  if (is_animation (file)) {
    if (!open_image_lookup (file))
      fclose (fp);
  }
  else if (which ("convert"))
    qpclose (fp);
  else
    fclose (fp);
}
# 571 "/root/mnt/basilisk/src/output.h"
struct OutputPPM {
  scalar f;
  FILE * fp;
  int n;
  char * file;
  double min, max, spread, z;
  
# 577 "/root/mnt/basilisk/src/output.h" 3 4
 _Bool 
# 577 "/root/mnt/basilisk/src/output.h"
      linear;
  double box[2][2];
  scalar mask;
  colormap map;
  char * opt;
};


void output_ppm (struct OutputPPM p)
{;

  if (p.n == 0) p.n = N;
  if (p.min == 0 && p.max == 0) {
    stats s = statsf (p.f);
    if (p.spread < 0.)
      p.min = s.min, p.max = s.max;
    else {
      double avg = s.sum/s.volume, spread = (p.spread ? p.spread : 5.)*s.stddev;
      p.min = avg - spread; p.max = avg + spread;
    }
  }
  if (p.box[0][0] == 0. && p.box[0][1] == 0. &&
      p.box[1][0] == 0. && p.box[1][1] == 0.) {
    p.box[0][0] = X0; p.box[0][1] = Y0;
    p.box[1][0] = X0 + L0; p.box[1][1] = Y0 + L0;
  }
  if (!p.map)
    p.map = jet;
  if (p.linear) {
    scalar f = p.f, mask = p.mask;
    if (mask.i)
      boundary_internal ((scalar *)((scalar[]){f, mask,{-1}}), "/root/mnt/basilisk/src/output.h", 608);
    else
      boundary_internal ((scalar *)((scalar[]){f,{-1}}), "/root/mnt/basilisk/src/output.h", 610);
  }

  double fn = p.n;
  double Delta = (p.box[1][0] - p.box[0][0])/fn;
  int ny = (p.box[1][1] - p.box[0][1])/Delta;
  if (ny % 2) ny++;

  color ** ppm = (color **) matrix_new (ny, p.n, sizeof(color));
  double cmap[127][3];
  p.map (cmap);
  {
   
      for (int j = 0; j < ny; j++) {
 double yp = Delta*j + p.box[0][1] + Delta/2.;
 for (int i = 0; i < p.n; i++) {
   double xp = Delta*i + p.box[0][0] + Delta/2., v;
   if (p.mask.i) {
     if (p.linear) {
       double m = interpolate ((struct _interpolate){p.mask, xp, yp, p.z});
       if (m < 0.)
  v = ((double)1e30);
       else
  v = interpolate ((struct _interpolate){p.f, xp, yp, p.z});
     }
     else {
       Point point = locate ((struct _locate){xp, yp, p.z});int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
       if (point.level < 0 || ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(p.mask.i)] < 0.)
  v = ((double)1e30);
       else
  v = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(p.f.i)];
     }
   }
   else if (p.linear)
     v = interpolate ((struct _interpolate){p.f, xp, yp, p.z});
   else {
     Point point = locate ((struct _locate){xp, yp, p.z});int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
     v = point.level >= 0 ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(p.f.i)] : ((double)1e30);
   }
   ppm[ny - 1 - j][i] = colormap_color (cmap, v, p.min, p.max);
 }
      }
  }

  if (0 == 0) {




    if (!p.fp) p.fp = 
# 659 "/root/mnt/basilisk/src/output.h" 3
                     stdout
# 659 "/root/mnt/basilisk/src/output.h"
                         ;
    if (p.file)
      p.fp = open_image (p.file, p.opt);

    fprintf (p.fp, "P6\n%u %u 255\n", p.n, ny);
    fwrite (((void **) ppm)[0], sizeof(color), ny*p.n, p.fp);

    if (p.file)
      close_image (p.file, p.fp);
    else
      fflush (p.fp);
  }






  matrix_free (ppm);
;}
# 710 "/root/mnt/basilisk/src/output.h"
struct OutputGRD {
  scalar f;
  FILE * fp;
  double Delta;
  
# 714 "/root/mnt/basilisk/src/output.h" 3 4
 _Bool 
# 714 "/root/mnt/basilisk/src/output.h"
      linear;
  double box[2][2];
  scalar mask;
};


void output_grd (struct OutputGRD p)
{;

  if (!p.fp) p.fp = 
# 723 "/root/mnt/basilisk/src/output.h" 3
                   stdout
# 723 "/root/mnt/basilisk/src/output.h"
                       ;
  if (p.box[0][0] == 0. && p.box[0][1] == 0. &&
      p.box[1][0] == 0. && p.box[1][1] == 0.) {
    p.box[0][0] = X0; p.box[0][1] = Y0;
    p.box[1][0] = X0 + L0; p.box[1][1] = Y0 + L0;
    if (p.Delta == 0) p.Delta = L0/N;
  }
  if (p.linear) {
    scalar f = p.f, mask = p.mask;
    if (mask.i)
      boundary_internal ((scalar *)((scalar[]){f, mask,{-1}}), "/root/mnt/basilisk/src/output.h", 733);
    else
      boundary_internal ((scalar *)((scalar[]){f,{-1}}), "/root/mnt/basilisk/src/output.h", 735);
  }

  double Delta = p.Delta;
  int nx = (p.box[1][0] - p.box[0][0])/Delta;
  int ny = (p.box[1][1] - p.box[0][1])/Delta;


  fprintf (p.fp, "ncols          %d\n", nx);
  fprintf (p.fp, "nrows          %d\n", ny);
  fprintf (p.fp, "xllcorner      %g\n", p.box[0][0]);
  fprintf (p.fp, "yllcorner      %g\n", p.box[0][1]);
  fprintf (p.fp, "cellsize       %g\n", Delta);
  fprintf (p.fp, "nodata_value   -9999\n");


  for (int j = ny-1; j >= 0; j--) {
    double yp = Delta*j + p.box[0][1] + Delta/2.;
    for (int i = 0; i < nx; i++) {
      double xp = Delta*i + p.box[0][0] + Delta/2., v;
      if (p.mask.i) {
 if (p.linear) {
   double m = interpolate ((struct _interpolate){p.mask, xp, yp});
   if (m < 0.)
     v = ((double)1e30);
   else
     v = interpolate ((struct _interpolate){p.f, xp, yp});
 }
 else {
   Point point = locate ((struct _locate){xp, yp});int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
   if (point.level < 0 || ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(p.mask.i)] < 0.)
     v = ((double)1e30);
   else
     v = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(p.f.i)];
 }
      }
      else if (p.linear)
 v = interpolate ((struct _interpolate){p.f, xp, yp});
      else {
 Point point = locate ((struct _locate){xp, yp});int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
 v = point.level >= 0 ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(p.f.i)] : ((double)1e30);
      }
      if (v == ((double)1e30))
 fprintf (p.fp, "-9999 ");
      else
 fprintf (p.fp, "%f ", v);
    }
    fprintf (p.fp, "\n");
  }

  fflush (p.fp);
;}
# 813 "/root/mnt/basilisk/src/output.h"
struct OutputGfs {
  FILE * fp;
  scalar * list;
  double t;
  char * file;
  
# 818 "/root/mnt/basilisk/src/output.h" 3 4
 _Bool 
# 818 "/root/mnt/basilisk/src/output.h"
      translate;
};

static char * replace (const char * input, int target, int with,
         
# 822 "/root/mnt/basilisk/src/output.h" 3 4
        _Bool 
# 822 "/root/mnt/basilisk/src/output.h"
             translate)
{
  if (translate) {
    if (!strcmp (input, "u.x"))
      return strdup("U");
    if (!strcmp (input, "u.y"))
      return strdup("V");
    if (!strcmp (input, "u.z"))
      return strdup("W");
  }
  char * name = strdup(input), * i = name;
  while (*i != '\0') {
    if (*i == target)
      *i = with;
    i++;
  }
  return name;
}


void output_gfs (struct OutputGfs p)
{;
  char * fname = p.file;
# 860 "/root/mnt/basilisk/src/output.h"
  
# 860 "/root/mnt/basilisk/src/output.h" 3 4
 _Bool 
# 860 "/root/mnt/basilisk/src/output.h"
      opened = 
# 860 "/root/mnt/basilisk/src/output.h" 3 4
               0
# 860 "/root/mnt/basilisk/src/output.h"
                    ;
  if (p.fp == 
# 861 "/root/mnt/basilisk/src/output.h" 3 4
             ((void *)0)
# 861 "/root/mnt/basilisk/src/output.h"
                 ) {
    if (fname == 
# 862 "/root/mnt/basilisk/src/output.h" 3 4
                ((void *)0)
# 862 "/root/mnt/basilisk/src/output.h"
                    )
      p.fp = 
# 863 "/root/mnt/basilisk/src/output.h" 3
            stdout
# 863 "/root/mnt/basilisk/src/output.h"
                ;
    else if (!(p.fp = fopen (fname, "w"))) {
      perror (fname);
      exit (1);
    }
    else
      opened = 
# 869 "/root/mnt/basilisk/src/output.h" 3 4
              1
# 869 "/root/mnt/basilisk/src/output.h"
                  ;
  }

  scalar * list = p.list ? p.list : list_copy (all);

  restriction (list);
  fprintf (p.fp,
    "1 0 GfsSimulation GfsBox GfsGEdge { binary = 1"
    " x = %g y = %g ",
    0.5 + X0/L0, 0.5 + Y0/L0);




  if (list != 
# 883 "/root/mnt/basilisk/src/output.h" 3 4
             ((void *)0) 
# 883 "/root/mnt/basilisk/src/output.h"
                  && list[0].i != -1) {
    scalar s = list[0];
    char * name = replace (_attribute[s.i].name, '.', '_', p.translate);
    fprintf (p.fp, "variables = %s", name);
    free(name);
    for (int i = 1; i < list_len(list); i++) {
      scalar s = list[i];
      if (_attribute[s.i].name) {
 char * name = replace (_attribute[s.i].name, '.', '_', p.translate);
 fprintf (p.fp, ",%s", name);
 free(name);
      }
    }
    fprintf (p.fp, " ");
  }
  fprintf (p.fp, "} {\n");
  fprintf (p.fp, "  Time { t = %g }\n", t);
  if (L0 != 1.)
    fprintf (p.fp, "  PhysicalParams { L = %g }\n", L0);
  fprintf (p.fp, "  VariableTracerVOF f\n");
  fprintf (p.fp, "}\nGfsBox { x = 0 y = 0 z = 0 } {\n");
# 921 "/root/mnt/basilisk/src/output.h"
  {{ Point root = {2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point = {0}; struct { int l, i, j, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; }; if (!(((point.i+0) >= (((Tree *)grid)->L[point.level]->m)->r1.start && (point.i+0) < (((Tree *)grid)->L[point.level]->m->r1.end) && (((Tree *)grid)->L[point.level]->m)->b[point.i+0] && (point.j+0) >= (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].start && (point.j+0) < (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].end && (((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {



    {






      unsigned flags =
 level == 0 ? 0 :



      child.x == -1 && child.y == -1 ? 0 :
 child.x == -1 && child.y == 1 ? 1 :
 child.x == 1 && child.y == -1 ? 2 :
 3;
# 951 "/root/mnt/basilisk/src/output.h"
      if ((((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & leaf))
 flags |= (1 << 4);
      fwrite (&flags, sizeof (unsigned), 1, p.fp);
      double a = -1;
      fwrite (&a, sizeof (double), 1, p.fp);
      {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
 if (_attribute[s.i].name) {
   if (_attribute[s.i].v.x.i >= 0) {




     if (_attribute[s.i].v.x.i == s.i) {
       s = _attribute[s.i].v.y;
       a = (((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).pid == 0) && ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] != ((double)1e30) ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] : (double) ((double)1.79769313486231570814527423731704357e+308L);
     }
     else if (_attribute[s.i].v.y.i == s.i) {
       s = _attribute[s.i].v.x;
       a = (((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).pid == 0) && ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] != ((double)1e30) ? - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] : (double) ((double)1.79769313486231570814527423731704357e+308L);
     }





   }
   else
     a = (((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).pid == 0) && ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] != ((double)1e30) ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] : (double) ((double)1.79769313486231570814527423731704357e+308L);
   fwrite (&a, sizeof (double), 1, p.fp);
 }}}
    }
    if ((((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & leaf))
      continue;
  }if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; } } } };}
# 994 "/root/mnt/basilisk/src/output.h"
    fputs ("}\n", p.fp);
  fflush (p.fp);

  if (!p.list)
    free(list);
  if (opened)
    fclose (p.fp);
# 1019 "/root/mnt/basilisk/src/output.h"
;}
# 1043 "/root/mnt/basilisk/src/output.h"
struct Dump {
  char * file;
  scalar * list;
  FILE * fp;
  
# 1047 "/root/mnt/basilisk/src/output.h" 3 4
 _Bool 
# 1047 "/root/mnt/basilisk/src/output.h"
      unbuffered;
};

struct DumpHeader {
  double t;
  long len;
  int i, depth, npe, version;
  coord n;
};

static const int dump_version =

  170901;

static scalar * dump_list (scalar * lista)
{
  scalar * list = ((cm).i >= 65536) ? 
# 1063 "/root/mnt/basilisk/src/output.h" 3 4
                                   ((void *)0) 
# 1063 "/root/mnt/basilisk/src/output.h"
                                        : list_concat (((scalar[]){cm,{-1}}), 
# 1063 "/root/mnt/basilisk/src/output.h" 3 4
                                                                              ((void *)0)
# 1063 "/root/mnt/basilisk/src/output.h"
                                                                                  );
  {scalar*_i=(scalar*)( lista);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (!_attribute[s.i].face && !_attribute[s.i].nodump && s.i != cm.i)
      list = list_add (list, s);}}
  return list;
}

static void dump_header (FILE * fp, struct DumpHeader * header, scalar * list)
{
  if (fwrite (header, sizeof(struct DumpHeader), 1, fp) < 1) {
    perror ("dump(): error while writing header");
    exit (1);
  }
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
    unsigned len = strlen(_attribute[s.i].name);
    if (fwrite (&len, sizeof(unsigned), 1, fp) < 1) {
      perror ("dump(): error while writing len");
      exit (1);
    }
    if (fwrite (_attribute[s.i].name, sizeof(char), len, fp) < len) {
      perror ("dump(): error while writing s.name");
      exit (1);
    }
  }}}
  double o[4] = {X0,Y0,Z0,L0};
  if (fwrite (o, sizeof(double), 4, fp) < 4) {
    perror ("dump(): error while writing coordinates");
    exit (1);
  }
}



void dump (struct Dump p)
{;
  FILE * fp = p.fp;
  char def[] = "dump", * file = p.file ? p.file : p.fp ? 
# 1099 "/root/mnt/basilisk/src/output.h" 3 4
                                                        ((void *)0) 
# 1099 "/root/mnt/basilisk/src/output.h"
                                                             : def;

  char * name = 
# 1101 "/root/mnt/basilisk/src/output.h" 3 4
               ((void *)0)
# 1101 "/root/mnt/basilisk/src/output.h"
                   ;
  if (file) {
    name = (char *) malloc(strlen(file) + 2);
    strcpy (name, file);
    if (!p.unbuffered)
      strcat (name, "~");
    if ((fp = fopen (name, "w")) == 
# 1107 "/root/mnt/basilisk/src/output.h" 3 4
                                   ((void *)0)
# 1107 "/root/mnt/basilisk/src/output.h"
                                       ) {
      perror (name);
      exit (1);
    }
  }
  if (!(fp)) qassert ("/root/mnt/basilisk/src/output.h", 1112, "fp");

  scalar * dlist = dump_list (p.list ? p.list : all);
  scalar size=new_scalar("size");
  scalar * list = list_concat (((scalar[]){size,{-1}}), dlist); free(dlist);
  struct DumpHeader header = { t, list_len(list), iter, (grid->depth), 1,
          dump_version };
  dump_header (fp, &header, list);

  subtree_size (size, 
# 1121 "/root/mnt/basilisk/src/output.h" 3 4
                     0
# 1121 "/root/mnt/basilisk/src/output.h"
                          );

  {{ Point root = {2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point = {0}; struct { int l, i, j, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; }; if (!(((point.i+0) >= (((Tree *)grid)->L[point.level]->m)->r1.start && (point.i+0) < (((Tree *)grid)->L[point.level]->m->r1.end) && (((Tree *)grid)->L[point.level]->m)->b[point.i+0] && (point.j+0) >= (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].start && (point.j+0) < (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].end && (((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
    unsigned flags = (((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & leaf) ? leaf : 0;
    if (fwrite (&flags, sizeof(unsigned), 1, fp) < 1) {
      perror ("dump(): error while writing flags");
      exit (1);
    }
    {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      if (fwrite (&((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)], sizeof(double), 1, fp) < 1) {
 perror ("dump(): error while writing scalars");
 exit (1);
      }}}
    if ((((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & leaf))
      continue;
  }if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; } } } };}

  free(list);
  if (file) {
    fclose (fp);
    if (!p.unbuffered)
      rename (name, file);
    free(name);
  }delete((scalar*)((scalar[]){size,{-1}}));
;}
# 1223 "/root/mnt/basilisk/src/output.h"

# 1223 "/root/mnt/basilisk/src/output.h" 3 4
_Bool 
# 1223 "/root/mnt/basilisk/src/output.h"
    restore (struct Dump p)
{;
  FILE * fp = p.fp;
  char * file = p.file;
  if (file && (fp = fopen (file, "r")) == 
# 1227 "/root/mnt/basilisk/src/output.h" 3 4
                                         ((void *)0)
# 1227 "/root/mnt/basilisk/src/output.h"
                                             )
    {;return 
# 1228 "/root/mnt/basilisk/src/output.h" 3 4
                                                                         0
# 1228 "/root/mnt/basilisk/src/output.h"
                                                                              ;}
  if (!(fp)) qassert ("/root/mnt/basilisk/src/output.h", 1229, "fp");

  struct DumpHeader header;
  if (fread (&header, sizeof(header), 1, fp) < 1) {
    fprintf (
# 1233 "/root/mnt/basilisk/src/output.h" 3
            stderr
# 1233 "/root/mnt/basilisk/src/output.h"
                , "restore(): error: expecting header\n");
    exit (1);
  }


  init_grid (1);
  {{ Point root = {2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point = {0}; struct { int l, i, j, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; }; if (!(((point.i+0) >= (((Tree *)grid)->L[point.level]->m)->r1.start && (point.i+0) < (((Tree *)grid)->L[point.level]->m->r1.end) && (((Tree *)grid)->L[point.level]->m)->b[point.i+0] && (point.j+0) >= (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].start && (point.j+0) < (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].end && (((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
    (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).pid = 0;
    (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).flags |= active;
  }if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; } } } };}
  ((Tree *)grid)->dirty = 
# 1243 "/root/mnt/basilisk/src/output.h" 3 4
                         1
# 1243 "/root/mnt/basilisk/src/output.h"
                             ;
# 1264 "/root/mnt/basilisk/src/output.h"
  
# 1264 "/root/mnt/basilisk/src/output.h" 3 4
 _Bool 
# 1264 "/root/mnt/basilisk/src/output.h"
      restore_all = (p.list == all);
  scalar * list = dump_list (p.list ? p.list : all);
  if (header.version == 161020) {
    if (header.len - 1 != list_len (list)) {
      fprintf (
# 1268 "/root/mnt/basilisk/src/output.h" 3
              stderr
# 1268 "/root/mnt/basilisk/src/output.h"
                  ,
        "restore(): error: the list lengths don't match: "
        "%ld (file) != %d (code)\n",
        header.len - 1, list_len (list));
      exit (1);
    }
  }
  else {
    if (header.version != dump_version) {
      fprintf (
# 1277 "/root/mnt/basilisk/src/output.h" 3
              stderr
# 1277 "/root/mnt/basilisk/src/output.h"
                  ,
        "restore(): error: file version mismatch: "
        "%d (file) != %d (code)\n",
        header.version, dump_version);
      exit (1);
    }

    scalar * input = 
# 1284 "/root/mnt/basilisk/src/output.h" 3 4
                    ((void *)0)
# 1284 "/root/mnt/basilisk/src/output.h"
                        ;
    for (int i = 0; i < header.len; i++) {
      unsigned len;
      if (fread (&len, sizeof(unsigned), 1, fp) < 1) {
 fprintf (
# 1288 "/root/mnt/basilisk/src/output.h" 3
         stderr
# 1288 "/root/mnt/basilisk/src/output.h"
             , "restore(): error: expecting len\n");
 exit (1);
      }
      char name[len + 1];
      if (fread (name, sizeof(char), len, fp) < 1) {
 fprintf (
# 1293 "/root/mnt/basilisk/src/output.h" 3
         stderr
# 1293 "/root/mnt/basilisk/src/output.h"
             , "restore(): error: expecting s.name\n");
 exit (1);
      }
      name[len] = '\0';

      if (i > 0) {
 
# 1299 "/root/mnt/basilisk/src/output.h" 3 4
_Bool 
# 1299 "/root/mnt/basilisk/src/output.h"
     found = 
# 1299 "/root/mnt/basilisk/src/output.h" 3 4
             0
# 1299 "/root/mnt/basilisk/src/output.h"
                  ;
 {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
   if (!strcmp (_attribute[s.i].name, name)) {
     input = list_append (input, s);
     found = 
# 1303 "/root/mnt/basilisk/src/output.h" 3 4
            1
# 1303 "/root/mnt/basilisk/src/output.h"
                ; break;
   }}}
 if (!found) {
   if (restore_all) {
     scalar s = new_scalar("s");
     free(_attribute[s.i].name);
     _attribute[s.i].name = strdup(name);
     input = list_append (input, s);
   }
   else
     input = list_append (input, (scalar){0x7fffffff});
 }
      }
    }
    free(list);
    list = input;

    double o[4];
    if (fread (o, sizeof(double), 4, fp) < 4) {
      fprintf (
# 1322 "/root/mnt/basilisk/src/output.h" 3
              stderr
# 1322 "/root/mnt/basilisk/src/output.h"
                  , "restore(): error: expecting coordinates\n");
      exit (1);
    }
    origin ((struct _origin){o[0], o[1], o[2]});
    size (o[3]);
  }
# 1339 "/root/mnt/basilisk/src/output.h"
  scalar * listm = ((cm).i >= 65536) ? 
# 1339 "/root/mnt/basilisk/src/output.h" 3 4
                                    ((void *)0) 
# 1339 "/root/mnt/basilisk/src/output.h"
                                         : (scalar *)((vector[]){fm,{{-1},{-1}}});



  {{ Point root = {2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point = {0}; struct { int l, i, j, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; }; if (!(((point.i+0) >= (((Tree *)grid)->L[point.level]->m)->r1.start && (point.i+0) < (((Tree *)grid)->L[point.level]->m->r1.end) && (((Tree *)grid)->L[point.level]->m)->b[point.i+0] && (point.j+0) >= (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].start && (point.j+0) < (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].end && (((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
    unsigned flags;
    if (fread (&flags, sizeof(unsigned), 1, fp) != 1) {
      fprintf (
# 1346 "/root/mnt/basilisk/src/output.h" 3
              stderr
# 1346 "/root/mnt/basilisk/src/output.h"
                  , "restore(): error: expecting 'flags'\n");
      exit (1);
    }

    fseek (fp, sizeof(double), 
# 1350 "/root/mnt/basilisk/src/output.h" 3
                              1
# 1350 "/root/mnt/basilisk/src/output.h"
                                      );
    {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
      double val;
      if (fread (&val, sizeof(double), 1, fp) != 1) {
 fprintf (
# 1354 "/root/mnt/basilisk/src/output.h" 3
         stderr
# 1354 "/root/mnt/basilisk/src/output.h"
             , "restore(): error: expecting a scalar\n");
 exit (1);
      }
      if (s.i != 0x7fffffff)
 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] = val;
    }}}
    if (!(flags & leaf) && (((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & leaf))
      refine_cell (point, listm, 0, 
# 1361 "/root/mnt/basilisk/src/output.h" 3 4
                                   ((void *)0)
# 1361 "/root/mnt/basilisk/src/output.h"
                                       );
    if ((((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & leaf))
      continue;
  }if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; } } } };}
  {scalar*_i=(scalar*)( all);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    _attribute[s.i].dirty = 
# 1366 "/root/mnt/basilisk/src/output.h" 3 4
                           1
# 1366 "/root/mnt/basilisk/src/output.h"
                               ;}}


  scalar * other = 
# 1369 "/root/mnt/basilisk/src/output.h" 3 4
                  ((void *)0)
# 1369 "/root/mnt/basilisk/src/output.h"
                      ;
  {scalar*_i=(scalar*)( all);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (!list_lookup (list, s) && !list_lookup (listm, s))
      other = list_append (other, s);}}
  reset (other, 0.);
  free(other);

  free(list);
  if (file)
    fclose (fp);


  while (iter < header.i && events (
# 1381 "/root/mnt/basilisk/src/output.h" 3 4
                                   0
# 1381 "/root/mnt/basilisk/src/output.h"
                                        ))
    iter = inext;
  events (
# 1383 "/root/mnt/basilisk/src/output.h" 3 4
         0
# 1383 "/root/mnt/basilisk/src/output.h"
              );
  while (t < header.t && events (
# 1384 "/root/mnt/basilisk/src/output.h" 3 4
                                0
# 1384 "/root/mnt/basilisk/src/output.h"
                                     ))
    t = tnext;
  t = header.t;
  events (
# 1387 "/root/mnt/basilisk/src/output.h" 3 4
         0
# 1387 "/root/mnt/basilisk/src/output.h"
              );

  {;return 
# 1389 "/root/mnt/basilisk/src/output.h" 3 4
                                                                       1
# 1389 "/root/mnt/basilisk/src/output.h"
                                                                           ;}
;}
# 431 "/root/mnt/basilisk/src/utils.h"
# 12 "/root/mnt/basilisk/src/run.h"


void run (void)
{;
  iter = 0, t = 0., dt = 1.;
  init_grid (N);

  perf.nc = perf.tnc = 0;
  perf.gt = timer_start();
  while (events (
# 21 "/root/mnt/basilisk/src/run.h" 3 4
                1
# 21 "/root/mnt/basilisk/src/run.h"
                    )) {





    update_perf();
    iter = inext, t = tnext;
  }




  timer_print (perf.gt, iter, perf.tnc);

  free_grid();
;}




static int defaults_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i = 0);*ip=i;*tp=t;return ret;} static int defaults(const int i,const double t,Event *_ev){; {
  display ((struct _display){"box();"});
}{;return 0;};}





static int cleanup_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(t = 1234567890);*ip=i;*tp=t;return ret;} static int cleanup(const int i,const double t,Event *_ev){; {
  display ((struct _display){"", 
# 51 "/root/mnt/basilisk/src/run.h" 3 4
                                1
# 51 "/root/mnt/basilisk/src/run.h"
                                    });
}{;return 0;};}
# 28 "/root/mnt/basilisk/src/navier-stokes/centered.h"
# 1 "./timestep.h"
# 1 "/root/mnt/basilisk/src/timestep.h"

double timestep (const vector u, double dtmax)
{
  static double previous = 0.;
  dtmax /= CFL;
  { static ForeachData _loop = { "/root/mnt/basilisk/src/timestep.h", 6, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 6 "/root/mnt/basilisk/src/timestep.h" 3 4
 0
# 6 "/root/mnt/basilisk/src/timestep.h"
 ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point);{{ _loop.face |= (1 << 0);{
    {stencil_val (point, u.x, 0, 0, 0, "/root/mnt/basilisk/src/timestep.h", 7, 
# 7 "/root/mnt/basilisk/src/timestep.h" 3 4
    0
# 7 "/root/mnt/basilisk/src/timestep.h"
    ); {
      stencil_val (point, u.x, 0, 0, 0, "/root/mnt/basilisk/src/timestep.h", 8, 
# 8 "/root/mnt/basilisk/src/timestep.h" 3 4
     0
# 8 "/root/mnt/basilisk/src/timestep.h"
     );




stencil_val (point, cm, 0, 0, 0, "/root/mnt/basilisk/src/timestep.h", 13, 
# 13 "/root/mnt/basilisk/src/timestep.h" 3 4
0
# 13 "/root/mnt/basilisk/src/timestep.h"
);
# 16 "/root/mnt/basilisk/src/timestep.h"
} }}}
# 6 "/root/mnt/basilisk/src/timestep.h"
{ _loop.face |= (1 << 1);{
    {stencil_val (point, u.y, 0, 0, 0, "/root/mnt/basilisk/src/timestep.h", 7, 
# 7 "/root/mnt/basilisk/src/timestep.h" 3 4
    0
# 7 "/root/mnt/basilisk/src/timestep.h"
    ); {
      stencil_val (point, u.y, 0, 0, 0, "/root/mnt/basilisk/src/timestep.h", 8, 
# 8 "/root/mnt/basilisk/src/timestep.h" 3 4
     0
# 8 "/root/mnt/basilisk/src/timestep.h"
     );




stencil_val (point, cm, 0, 0, 0, "/root/mnt/basilisk/src/timestep.h", 13, 
# 13 "/root/mnt/basilisk/src/timestep.h" 3 4
0
# 13 "/root/mnt/basilisk/src/timestep.h"
);
# 16 "/root/mnt/basilisk/src/timestep.h"
} }}}}end_stencil (&_loop); _loop.first = 0;};
# 6 "/root/mnt/basilisk/src/timestep.h"
if(!((cm).i >= 65536)){


{
# 6 "/root/mnt/basilisk/src/timestep.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{
    if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.x.i)] != 0.) {
      double dt = Delta/fabs(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.x.i)]);




      dt *= ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(cm.i)];

      if (dt < dtmax) dtmax = dt;
    }}}}
# 6 "/root/mnt/basilisk/src/timestep.h"
{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{
    if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] != 0.) {
      double dt = Delta/fabs(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.y.i)]);




      dt *= ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(cm.i)];

      if (dt < dtmax) dtmax = dt;
    }}}}}} } };;


}
# 16 "/root/mnt/basilisk/src/timestep.h"
}else {double _const_cm=_constant[cm.i-65536];(void)(_const_cm);



{
# 6 "/root/mnt/basilisk/src/timestep.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{
    if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.x.i)] != 0.) {
      double dt = Delta/fabs(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.x.i)]);




      dt *= _const_cm;

      if (dt < dtmax) dtmax = dt;
    }}}}
# 6 "/root/mnt/basilisk/src/timestep.h"
{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{
    if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] != 0.) {
      double dt = Delta/fabs(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.y.i)]);




      dt *= _const_cm;

      if (dt < dtmax) dtmax = dt;
    }}}}}} } };;


}
# 16 "/root/mnt/basilisk/src/timestep.h"
}
  dtmax *= CFL;
  if (dtmax > previous)
    dtmax = (previous + 0.1*dtmax)/1.1;
  previous = dtmax;
  return dtmax;
}
# 29 "/root/mnt/basilisk/src/navier-stokes/centered.h"
# 1 "./bcg.h"
# 1 "/root/mnt/basilisk/src/bcg.h"
# 11 "/root/mnt/basilisk/src/bcg.h"
void tracer_fluxes (scalar f,
      vector uf,
      vector flux,
      double dt,
              scalar src)
{





  vector g=new_vector("g");
  gradients (((scalar[]){f,{-1}}), ((vector[]){g,{{-1},{-1}}}));




  { static ForeachData _loop = { "/root/mnt/basilisk/src/bcg.h", 28, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 28 "/root/mnt/basilisk/src/bcg.h" 3 4
 0
# 28 "/root/mnt/basilisk/src/bcg.h"
 ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point);{{ _loop.face |= (1 << 0);{ {







    stencil_val (point, fm.x, 0, 0, 0, "/root/mnt/basilisk/src/bcg.h", 36, 
# 36 "/root/mnt/basilisk/src/bcg.h" 3 4
   0
# 36 "/root/mnt/basilisk/src/bcg.h"
   );stencil_val (point, uf.x, 0, 0, 0, "/root/mnt/basilisk/src/bcg.h", 36, 
# 36 "/root/mnt/basilisk/src/bcg.h" 3 4
                            0
# 36 "/root/mnt/basilisk/src/bcg.h"
                            );

    stencil_val (point, g.x, -2, 0, 0, "/root/mnt/basilisk/src/bcg.h", 38, 
# 38 "/root/mnt/basilisk/src/bcg.h" 3 4
   0
# 38 "/root/mnt/basilisk/src/bcg.h"
   ); stencil_val (point, src, -1, 0, 0, "/root/mnt/basilisk/src/bcg.h", 38, 
# 38 "/root/mnt/basilisk/src/bcg.h" 3 4
                                    0
# 38 "/root/mnt/basilisk/src/bcg.h"
                                    );stencil_val (point, src, 0, 0, 0, "/root/mnt/basilisk/src/bcg.h", 38, 
# 38 "/root/mnt/basilisk/src/bcg.h" 3 4
                                                             0
# 38 "/root/mnt/basilisk/src/bcg.h"
                                                             );stencil_val (point, f, -2, 0, 0, "/root/mnt/basilisk/src/bcg.h", 38, 
# 38 "/root/mnt/basilisk/src/bcg.h" 3 4
                                                                                     0
# 38 "/root/mnt/basilisk/src/bcg.h"
                                                                                     );





stencil_val (point, fm.y, -2, 0, 0, "/root/mnt/basilisk/src/bcg.h", 44, 
# 44 "/root/mnt/basilisk/src/bcg.h" 3 4
0
# 44 "/root/mnt/basilisk/src/bcg.h"
); stencil_val (point, fm.y, -2, 1, 0, "/root/mnt/basilisk/src/bcg.h", 44, 
# 44 "/root/mnt/basilisk/src/bcg.h" 3 4
                                 0
# 44 "/root/mnt/basilisk/src/bcg.h"
                                 ); {
       stencil_val (point, fm.y, -2, 1, 0, "/root/mnt/basilisk/src/bcg.h", 45, 
# 45 "/root/mnt/basilisk/src/bcg.h" 3 4
      0
# 45 "/root/mnt/basilisk/src/bcg.h"
      );stencil_val (point, fm.y, -2, 0, 0, "/root/mnt/basilisk/src/bcg.h", 45, 
# 45 "/root/mnt/basilisk/src/bcg.h" 3 4
                                       0
# 45 "/root/mnt/basilisk/src/bcg.h"
                                       ); stencil_val (point, uf.y, -2, 1, 0, "/root/mnt/basilisk/src/bcg.h", 45, 
# 45 "/root/mnt/basilisk/src/bcg.h" 3 4
                                                                         0
# 45 "/root/mnt/basilisk/src/bcg.h"
                                                                         );stencil_val (point, uf.y, -2, 0, 0, "/root/mnt/basilisk/src/bcg.h", 45, 
# 45 "/root/mnt/basilisk/src/bcg.h" 3 4
                                                                                                          0
# 45 "/root/mnt/basilisk/src/bcg.h"
                                                                                                          );
       stencil_val (point, f, -2, -1, 0, "/root/mnt/basilisk/src/bcg.h", 46, 
# 46 "/root/mnt/basilisk/src/bcg.h" 3 4
      0
# 46 "/root/mnt/basilisk/src/bcg.h"
      );stencil_val (point, f, -2, 0, 0, "/root/mnt/basilisk/src/bcg.h", 46, 
# 46 "/root/mnt/basilisk/src/bcg.h" 3 4
                                     0
# 46 "/root/mnt/basilisk/src/bcg.h"
                                     );stencil_val (point, f, -2, 0, 0, "/root/mnt/basilisk/src/bcg.h", 46, 
# 46 "/root/mnt/basilisk/src/bcg.h" 3 4
                                                                    0
# 46 "/root/mnt/basilisk/src/bcg.h"
                                                                    ); stencil_val (point, f, -2, 1, 0, "/root/mnt/basilisk/src/bcg.h", 46, 
# 46 "/root/mnt/basilisk/src/bcg.h" 3 4
                                                                                                    0
# 46 "/root/mnt/basilisk/src/bcg.h"
                                                                                                    );

    }
# 58 "/root/mnt/basilisk/src/bcg.h"
    stencil_val_a (point, flux.x, 0, 0, 0, 
# 58 "/root/mnt/basilisk/src/bcg.h" 3 4
   0
# 58 "/root/mnt/basilisk/src/bcg.h"
   , "/root/mnt/basilisk/src/bcg.h", 58);stencil_val (point, uf.x, 0, 0, 0, "/root/mnt/basilisk/src/bcg.h", 58, 
# 58 "/root/mnt/basilisk/src/bcg.h" 3 4
                                0
# 58 "/root/mnt/basilisk/src/bcg.h"
                                );
  }}}
# 28 "/root/mnt/basilisk/src/bcg.h"
{ _loop.face |= (1 << 1);{ {







    stencil_val (point, fm.y, 0, 0, 0, "/root/mnt/basilisk/src/bcg.h", 36, 
# 36 "/root/mnt/basilisk/src/bcg.h" 3 4
   0
# 36 "/root/mnt/basilisk/src/bcg.h"
   );stencil_val (point, uf.y, 0, 0, 0, "/root/mnt/basilisk/src/bcg.h", 36, 
# 36 "/root/mnt/basilisk/src/bcg.h" 3 4
                            0
# 36 "/root/mnt/basilisk/src/bcg.h"
                            );

    stencil_val (point, g.y, 0, -2, 0, "/root/mnt/basilisk/src/bcg.h", 38, 
# 38 "/root/mnt/basilisk/src/bcg.h" 3 4
   0
# 38 "/root/mnt/basilisk/src/bcg.h"
   ); stencil_val (point, src, 0, -1, 0, "/root/mnt/basilisk/src/bcg.h", 38, 
# 38 "/root/mnt/basilisk/src/bcg.h" 3 4
                                    0
# 38 "/root/mnt/basilisk/src/bcg.h"
                                    );stencil_val (point, src, 0, 0, 0, "/root/mnt/basilisk/src/bcg.h", 38, 
# 38 "/root/mnt/basilisk/src/bcg.h" 3 4
                                                             0
# 38 "/root/mnt/basilisk/src/bcg.h"
                                                             );stencil_val (point, f, 0, -2, 0, "/root/mnt/basilisk/src/bcg.h", 38, 
# 38 "/root/mnt/basilisk/src/bcg.h" 3 4
                                                                                     0
# 38 "/root/mnt/basilisk/src/bcg.h"
                                                                                     );





stencil_val (point, fm.x, 0, -2, 0, "/root/mnt/basilisk/src/bcg.h", 44, 
# 44 "/root/mnt/basilisk/src/bcg.h" 3 4
0
# 44 "/root/mnt/basilisk/src/bcg.h"
); stencil_val (point, fm.x, 1, -2, 0, "/root/mnt/basilisk/src/bcg.h", 44, 
# 44 "/root/mnt/basilisk/src/bcg.h" 3 4
                                 0
# 44 "/root/mnt/basilisk/src/bcg.h"
                                 ); {
       stencil_val (point, fm.x, 1, -2, 0, "/root/mnt/basilisk/src/bcg.h", 45, 
# 45 "/root/mnt/basilisk/src/bcg.h" 3 4
      0
# 45 "/root/mnt/basilisk/src/bcg.h"
      );stencil_val (point, fm.x, 0, -2, 0, "/root/mnt/basilisk/src/bcg.h", 45, 
# 45 "/root/mnt/basilisk/src/bcg.h" 3 4
                                       0
# 45 "/root/mnt/basilisk/src/bcg.h"
                                       ); stencil_val (point, uf.x, 1, -2, 0, "/root/mnt/basilisk/src/bcg.h", 45, 
# 45 "/root/mnt/basilisk/src/bcg.h" 3 4
                                                                         0
# 45 "/root/mnt/basilisk/src/bcg.h"
                                                                         );stencil_val (point, uf.x, 0, -2, 0, "/root/mnt/basilisk/src/bcg.h", 45, 
# 45 "/root/mnt/basilisk/src/bcg.h" 3 4
                                                                                                          0
# 45 "/root/mnt/basilisk/src/bcg.h"
                                                                                                          );
       stencil_val (point, f, -1, -2, 0, "/root/mnt/basilisk/src/bcg.h", 46, 
# 46 "/root/mnt/basilisk/src/bcg.h" 3 4
      0
# 46 "/root/mnt/basilisk/src/bcg.h"
      );stencil_val (point, f, 0, -2, 0, "/root/mnt/basilisk/src/bcg.h", 46, 
# 46 "/root/mnt/basilisk/src/bcg.h" 3 4
                                     0
# 46 "/root/mnt/basilisk/src/bcg.h"
                                     );stencil_val (point, f, 0, -2, 0, "/root/mnt/basilisk/src/bcg.h", 46, 
# 46 "/root/mnt/basilisk/src/bcg.h" 3 4
                                                                    0
# 46 "/root/mnt/basilisk/src/bcg.h"
                                                                    ); stencil_val (point, f, 1, -2, 0, "/root/mnt/basilisk/src/bcg.h", 46, 
# 46 "/root/mnt/basilisk/src/bcg.h" 3 4
                                                                                                    0
# 46 "/root/mnt/basilisk/src/bcg.h"
                                                                                                    );

    }
# 58 "/root/mnt/basilisk/src/bcg.h"
    stencil_val_a (point, flux.y, 0, 0, 0, 
# 58 "/root/mnt/basilisk/src/bcg.h" 3 4
   0
# 58 "/root/mnt/basilisk/src/bcg.h"
   , "/root/mnt/basilisk/src/bcg.h", 58);stencil_val (point, uf.y, 0, 0, 0, "/root/mnt/basilisk/src/bcg.h", 58, 
# 58 "/root/mnt/basilisk/src/bcg.h" 3 4
                                0
# 58 "/root/mnt/basilisk/src/bcg.h"
                                );
  }}}}end_stencil (&_loop); _loop.first = 0;};
# 28 "/root/mnt/basilisk/src/bcg.h"
if(!((fm.x).i >= 65536) && !((src).i >= 65536)){{{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{ {







    double un = dt*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.x.i)]/(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)]*Delta + 0.), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;
    double f2 = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(f.i)] + (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(src.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(src.i)])*dt/4. + s*(1. - s*un)*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(g.x.i)]*Delta/2.;





    if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)] && ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+1]) ) + sizeof(Cell)))[(fm.y.i)]) {
      double vn = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(uf.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+1]) ) + sizeof(Cell)))[(uf.y.i)])/(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+1]) ) + sizeof(Cell)))[(fm.y.i)]);
      double fyy = vn < 0. ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+1]) ) + sizeof(Cell)))[(f.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(f.i)] : ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(f.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+-1]) ) + sizeof(Cell)))[(f.i)];
      f2 -= dt*vn*fyy/(2.*Delta);
    }
# 58 "/root/mnt/basilisk/src/bcg.h"
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(flux.x.i)] = f2*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.x.i)];
  }}}}
# 28 "/root/mnt/basilisk/src/bcg.h"
{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{ {







    double un = dt*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.y.i)]/(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)]*Delta + 0.), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;
    double f2 = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(f.i)] + (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(src.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(src.i)])*dt/4. + s*(1. - s*un)*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(g.y.i)]*Delta/2.;





    if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(fm.x.i)] && ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+i]) ) + sizeof(Cell)))[(fm.x.i)]) {
      double vn = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(uf.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+i]) ) + sizeof(Cell)))[(uf.x.i)])/(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(fm.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+i]) ) + sizeof(Cell)))[(fm.x.i)]);
      double fyy = vn < 0. ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+i]) ) + sizeof(Cell)))[(f.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(f.i)] : ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(f.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+i]) ) + sizeof(Cell)))[(f.i)];
      f2 -= dt*vn*fyy/(2.*Delta);
    }
# 58 "/root/mnt/basilisk/src/bcg.h"
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(flux.y.i)] = f2*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.y.i)];
  }}}}}} } };}}else if(((fm.x).i >= 65536) && !((src).i >= 65536)){struct{double x,y;}_const_fm={_constant[fm.x.i-65536],_constant[fm.y.i-65536]};(void)(_const_fm);




  {
# 28 "/root/mnt/basilisk/src/bcg.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{ {







    double un = dt*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.x.i)]/(_const_fm.x*Delta + 0.), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;
    double f2 = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(f.i)] + (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(src.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(src.i)])*dt/4. + s*(1. - s*un)*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(g.x.i)]*Delta/2.;





    if (_const_fm.y && _const_fm.y) {
      double vn = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(uf.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+1]) ) + sizeof(Cell)))[(uf.y.i)])/(_const_fm.y + _const_fm.y);
      double fyy = vn < 0. ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+1]) ) + sizeof(Cell)))[(f.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(f.i)] : ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(f.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+-1]) ) + sizeof(Cell)))[(f.i)];
      f2 -= dt*vn*fyy/(2.*Delta);
    }
# 58 "/root/mnt/basilisk/src/bcg.h"
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(flux.x.i)] = f2*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.x.i)];
  }}}}
# 28 "/root/mnt/basilisk/src/bcg.h"
{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{ {







    double un = dt*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.y.i)]/(_const_fm.y*Delta + 0.), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;
    double f2 = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(f.i)] + (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(src.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(src.i)])*dt/4. + s*(1. - s*un)*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(g.y.i)]*Delta/2.;





    if (_const_fm.x && _const_fm.x) {
      double vn = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(uf.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+i]) ) + sizeof(Cell)))[(uf.x.i)])/(_const_fm.x + _const_fm.x);
      double fyy = vn < 0. ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+i]) ) + sizeof(Cell)))[(f.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(f.i)] : ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(f.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+i]) ) + sizeof(Cell)))[(f.i)];
      f2 -= dt*vn*fyy/(2.*Delta);
    }
# 58 "/root/mnt/basilisk/src/bcg.h"
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(flux.y.i)] = f2*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.y.i)];
  }}}}}} } };}}else if(!((fm.x).i >= 65536) && ((src).i >= 65536)){double _const_src=_constant[src.i-65536];(void)(_const_src);




  {
# 28 "/root/mnt/basilisk/src/bcg.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{ {







    double un = dt*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.x.i)]/(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)]*Delta + 0.), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;
    double f2 = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(f.i)] + (_const_src + _const_src)*dt/4. + s*(1. - s*un)*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(g.x.i)]*Delta/2.;





    if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)] && ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+1]) ) + sizeof(Cell)))[(fm.y.i)]) {
      double vn = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(uf.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+1]) ) + sizeof(Cell)))[(uf.y.i)])/(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+1]) ) + sizeof(Cell)))[(fm.y.i)]);
      double fyy = vn < 0. ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+1]) ) + sizeof(Cell)))[(f.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(f.i)] : ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(f.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+-1]) ) + sizeof(Cell)))[(f.i)];
      f2 -= dt*vn*fyy/(2.*Delta);
    }
# 58 "/root/mnt/basilisk/src/bcg.h"
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(flux.x.i)] = f2*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.x.i)];
  }}}}
# 28 "/root/mnt/basilisk/src/bcg.h"
{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{ {







    double un = dt*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.y.i)]/(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)]*Delta + 0.), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;
    double f2 = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(f.i)] + (_const_src + _const_src)*dt/4. + s*(1. - s*un)*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(g.y.i)]*Delta/2.;





    if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(fm.x.i)] && ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+i]) ) + sizeof(Cell)))[(fm.x.i)]) {
      double vn = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(uf.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+i]) ) + sizeof(Cell)))[(uf.x.i)])/(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(fm.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+i]) ) + sizeof(Cell)))[(fm.x.i)]);
      double fyy = vn < 0. ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+i]) ) + sizeof(Cell)))[(f.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(f.i)] : ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(f.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+i]) ) + sizeof(Cell)))[(f.i)];
      f2 -= dt*vn*fyy/(2.*Delta);
    }
# 58 "/root/mnt/basilisk/src/bcg.h"
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(flux.y.i)] = f2*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.y.i)];
  }}}}}} } };}}else {struct{double x,y;}_const_fm={_constant[fm.x.i-65536],_constant[fm.y.i-65536]};(void)(_const_fm);double _const_src=_constant[src.i-65536];(void)(_const_src);




  {
# 28 "/root/mnt/basilisk/src/bcg.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{ {







    double un = dt*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.x.i)]/(_const_fm.x*Delta + 0.), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;
    double f2 = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(f.i)] + (_const_src + _const_src)*dt/4. + s*(1. - s*un)*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(g.x.i)]*Delta/2.;





    if (_const_fm.y && _const_fm.y) {
      double vn = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(uf.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+1]) ) + sizeof(Cell)))[(uf.y.i)])/(_const_fm.y + _const_fm.y);
      double fyy = vn < 0. ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+1]) ) + sizeof(Cell)))[(f.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(f.i)] : ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(f.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+-1]) ) + sizeof(Cell)))[(f.i)];
      f2 -= dt*vn*fyy/(2.*Delta);
    }
# 58 "/root/mnt/basilisk/src/bcg.h"
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(flux.x.i)] = f2*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.x.i)];
  }}}}
# 28 "/root/mnt/basilisk/src/bcg.h"
{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{ {







    double un = dt*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.y.i)]/(_const_fm.y*Delta + 0.), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;
    double f2 = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(f.i)] + (_const_src + _const_src)*dt/4. + s*(1. - s*un)*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(g.y.i)]*Delta/2.;





    if (_const_fm.x && _const_fm.x) {
      double vn = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(uf.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+i]) ) + sizeof(Cell)))[(uf.x.i)])/(_const_fm.x + _const_fm.x);
      double fyy = vn < 0. ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+i]) ) + sizeof(Cell)))[(f.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(f.i)] : ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(f.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+i]) ) + sizeof(Cell)))[(f.i)];
      f2 -= dt*vn*fyy/(2.*Delta);
    }
# 58 "/root/mnt/basilisk/src/bcg.h"
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(flux.y.i)] = f2*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.y.i)];
  }}}}}} } };}}delete((scalar*)((vector[]){g,{{-1},{-1}}}));
}






struct Advection {
  scalar * tracers;
  vector u;
  double dt;
  scalar * src;
};

void advection (struct Advection p)
{




  scalar * lsrc = p.src;
  if (!lsrc)
    {scalar*_i=(scalar*)( p.tracers);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      lsrc = list_append (lsrc, zeroc);}}
  if (!(list_len(p.tracers) == list_len(lsrc))) qassert ("/root/mnt/basilisk/src/bcg.h", 84, "list_len(p.tracers) == list_len(lsrc)");

  scalar f, src;
  {scalar*_i0=lsrc;scalar*_i1= p.tracers;if(_i0)for(src=*_i0,f=*_i1;_i0->i>= 0;src=*++_i0,f=*++_i1){ {
    vector flux=new_face_vector("flux");
    tracer_fluxes (f, p.u, flux, p.dt, src);

    { static ForeachData _loop = { "/root/mnt/basilisk/src/bcg.h", 91, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 91 "/root/mnt/basilisk/src/bcg.h" 3 4
   0
# 91 "/root/mnt/basilisk/src/bcg.h"
   ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point);
      {
        {stencil_val_a (point, f, 0, 0, 0, 
# 93 "/root/mnt/basilisk/src/bcg.h" 3 4
        1
# 93 "/root/mnt/basilisk/src/bcg.h"
        , "/root/mnt/basilisk/src/bcg.h", 93);stencil_val (point, flux.x, 0, 0, 0, "/root/mnt/basilisk/src/bcg.h", 93, 
# 93 "/root/mnt/basilisk/src/bcg.h" 3 4
                                0
# 93 "/root/mnt/basilisk/src/bcg.h"
                                ); stencil_val (point, flux.x, 1, 0, 0, "/root/mnt/basilisk/src/bcg.h", 93, 
# 93 "/root/mnt/basilisk/src/bcg.h" 3 4
                                                            0
# 93 "/root/mnt/basilisk/src/bcg.h"
                                                            );stencil_val (point, cm, 0, 0, 0, "/root/mnt/basilisk/src/bcg.h", 93, 
# 93 "/root/mnt/basilisk/src/bcg.h" 3 4
                                                                                       0
# 93 "/root/mnt/basilisk/src/bcg.h"
                                                                                       ); }
# 93 "/root/mnt/basilisk/src/bcg.h"
{stencil_val_a (point, f, 0, 0, 0, 
# 93 "/root/mnt/basilisk/src/bcg.h" 3 4
1
# 93 "/root/mnt/basilisk/src/bcg.h"
, "/root/mnt/basilisk/src/bcg.h", 93);stencil_val (point, flux.y, 0, 0, 0, "/root/mnt/basilisk/src/bcg.h", 93, 
# 93 "/root/mnt/basilisk/src/bcg.h" 3 4
                        0
# 93 "/root/mnt/basilisk/src/bcg.h"
                        ); stencil_val (point, flux.y, 0, 1, 0, "/root/mnt/basilisk/src/bcg.h", 93, 
# 93 "/root/mnt/basilisk/src/bcg.h" 3 4
                                                    0
# 93 "/root/mnt/basilisk/src/bcg.h"
                                                    );stencil_val (point, cm, 0, 0, 0, "/root/mnt/basilisk/src/bcg.h", 93, 
# 93 "/root/mnt/basilisk/src/bcg.h" 3 4
                                                                               0
# 93 "/root/mnt/basilisk/src/bcg.h"
                                                                               ); }}end_stencil (&_loop); _loop.first = 0;};
# 91 "/root/mnt/basilisk/src/bcg.h"
if(!((cm).i >= 65536)){{{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
      {
        ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)] += p.dt*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(flux.x.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(flux.x.i)])/(Delta*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(cm.i)]);
# 93 "/root/mnt/basilisk/src/bcg.h"
((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)] += p.dt*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(flux.y.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(flux.y.i)])/(Delta*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(cm.i)]);}} } };}}else {double _const_cm=_constant[cm.i-65536];(void)(_const_cm);

    {
# 91 "/root/mnt/basilisk/src/bcg.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
      {
        ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)] += p.dt*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(flux.x.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(flux.x.i)])/(Delta*_const_cm);
# 93 "/root/mnt/basilisk/src/bcg.h"
((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)] += p.dt*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(flux.y.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(flux.y.i)])/(Delta*_const_cm);}} } };}}delete((scalar*)((vector[]){flux,{{-1},{-1}}}));



  }}}

  if (!p.src)
    free(lsrc);
}
# 30 "/root/mnt/basilisk/src/navier-stokes/centered.h"
# 1 "./viscosity.h"
# 1 "/root/mnt/basilisk/src/viscosity.h"
# 1 "./poisson.h"
# 1 "/root/mnt/basilisk/src/poisson.h"
# 32 "/root/mnt/basilisk/src/poisson.h"
void mg_cycle (scalar * a, scalar * res, scalar * da,
        void (* relax) (scalar * da, scalar * res,
          int depth, void * data),
        void * data,
        int nrelax, int minlevel, int maxlevel)
{




  restriction (res);





  minlevel = ((minlevel) < (maxlevel) ? (minlevel) : (maxlevel));
  for (int l = minlevel; l <= maxlevel; l++) {




    if (l == minlevel)
      {{ for (int _l1 = l; _l1 >= 0; _l1--) { if (_l1 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[_l1]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.level = _l1; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; if (_l1 == l || (((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & leaf)) {
 {scalar*_i=(scalar*)( da);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){

     ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] = 0.;}}} } } }; }}; };}





    else
      {{ if (l <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[l]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.level = l; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
 {scalar*_i=(scalar*)( da);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){

     ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] = bilinear (point, s);}}} } }; }};}





    boundary_level (da, l);
    for (int i = 0; i < nrelax; i++) {
      relax (da, res, l, data);
      boundary_level (da, l);
    }
  }




  { static ForeachData _loop = { "/root/mnt/basilisk/src/poisson.h", 84, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 84 "/root/mnt/basilisk/src/poisson.h" 3 4
 0
# 84 "/root/mnt/basilisk/src/poisson.h"
 ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point); {
    scalar s, ds;
    {scalar*_i0= da;scalar*_i1= a;if(_i0)for(ds=*_i0,s=*_i1;_i0->i>= 0;ds=*++_i0,s=*++_i1){

 {stencil_val_a (point, s, 0, 0, 0, 
# 88 "/root/mnt/basilisk/src/poisson.h" 3 4
 1
# 88 "/root/mnt/basilisk/src/poisson.h"
 , "/root/mnt/basilisk/src/poisson.h", 88); stencil_val (point, ds, 0, 0, 0, "/root/mnt/basilisk/src/poisson.h", 88, 
# 88 "/root/mnt/basilisk/src/poisson.h" 3 4
                          0
# 88 "/root/mnt/basilisk/src/poisson.h"
                          ); }}}
  }end_stencil (&_loop); _loop.first = 0;};




  {
# 84 "/root/mnt/basilisk/src/poisson.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
    scalar s, ds;
    {scalar*_i0= da;scalar*_i1= a;if(_i0)for(ds=*_i0,s=*_i1;_i0->i>= 0;ds=*++_i0,s=*++_i1){

 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] += ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(ds.i)];}}
  }} } };}
}
# 102 "/root/mnt/basilisk/src/poisson.h"
int NITERMAX = 100, NITERMIN = 1;
double TOLERANCE = 1e-3;




typedef struct {
  int i;
  double resb, resa;
  double sum;
  int nrelax;
  int minlevel;
} mgstats;
# 125 "/root/mnt/basilisk/src/poisson.h"
struct MGSolve {
  scalar * a, * b;
  double (* residual) (scalar * a, scalar * b, scalar * res,
         void * data);
  void (* relax) (scalar * da, scalar * res, int depth,
    void * data);
  void * data;

  int nrelax;
  scalar * res;
  int minlevel;
  double tolerance;
};

mgstats mg_solve (struct MGSolve p)
{





  scalar * da = list_clone (p.a), * res = p.res;
  if (!res)
    res = list_clone (p.b);






  for (int b = 0; b < nboundary; b++)
    {scalar*_i=(scalar*)( da);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      _attribute[s.i].boundary[b] = _attribute[s.i].boundary_homogeneous[b];}}




  mgstats s = {0};
  double sum = 0.;
  { static ForeachData _loop = { "/root/mnt/basilisk/src/poisson.h", 164, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 164 "/root/mnt/basilisk/src/poisson.h" 3 4
 0
# 164 "/root/mnt/basilisk/src/poisson.h"
 ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point);
    {scalar*_i=(scalar*)( p.b);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      { stencil_val (point, s, 0, 0, 0, "/root/mnt/basilisk/src/poisson.h", 166, 
# 166 "/root/mnt/basilisk/src/poisson.h" 3 4
       0
# 166 "/root/mnt/basilisk/src/poisson.h"
       ); }}}end_stencil (&_loop); _loop.first = 0;};



{
# 164 "/root/mnt/basilisk/src/poisson.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    {scalar*_i=(scalar*)( p.b);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      sum += ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)];}}} } };;


}
# 167 "/root/mnt/basilisk/src/poisson.h"
s.sum = sum;
  s.nrelax = p.nrelax > 0 ? p.nrelax : 4;




  double resb;
  resb = s.resb = s.resa = p.residual (p.a, p.b, res, p.data);






  if (p.tolerance == 0.)
    p.tolerance = TOLERANCE;
  for (s.i = 0;
       s.i < NITERMAX && (s.i < NITERMIN || s.resa > p.tolerance);
       s.i++) {
    mg_cycle (p.a, res, da, p.relax, p.data,
       s.nrelax,
       p.minlevel,
       grid->maxdepth);
    s.resa = p.residual (p.a, p.b, res, p.data);
# 199 "/root/mnt/basilisk/src/poisson.h"
    if (s.resa > p.tolerance) {
      if (resb/s.resa < 1.2 && s.nrelax < 100)
 s.nrelax++;
      else if (resb/s.resa > 10 && s.nrelax > 2)
 s.nrelax--;
    }







    resb = s.resa;
  }
  s.minlevel = p.minlevel;




  if (s.resa > p.tolerance) {
    scalar v = p.a[0];
    fprintf (
# 221 "/root/mnt/basilisk/src/poisson.h" 3
            stderr
# 221 "/root/mnt/basilisk/src/poisson.h"
                ,
      "WARNING: convergence for %s not reached after %d iterations\n"
      "  res: %g sum: %g nrelax: %d\n", _attribute[v.i].name,
      s.i, s.resa, s.sum, s.nrelax), fflush (
# 224 "/root/mnt/basilisk/src/poisson.h" 3
                                            stderr
# 224 "/root/mnt/basilisk/src/poisson.h"
                                                );
  }




  if (!p.res)
    delete (res), free(res);
  delete (da), free(da);

  return s;
}
# 258 "/root/mnt/basilisk/src/poisson.h"
struct Poisson {
  scalar a, b;
          vector alpha;
          scalar lambda;
  double tolerance;
  int nrelax, minlevel;
  scalar * res;



};





static void relax (scalar * al, scalar * bl, int l, void * data)
{
  scalar a = al[0], b = bl[0];
  struct Poisson * p = (struct Poisson *) data;
          vector alpha = p->alpha;
          scalar lambda = p->lambda;
# 296 "/root/mnt/basilisk/src/poisson.h"
  scalar c = a;






  if(!((lambda).i >= 65536) && !((alpha.x).i >= 65536)){{{ for (int _l1 = l; _l1 >= 0; _l1--) { if (_l1 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[_l1]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.level = _l1; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; if (_l1 == l || (((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & leaf)) { {
    double n = - ((Delta)*(Delta))*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(b.i)], d = - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(lambda.i)]*((Delta)*(Delta));
     {
      n += ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(alpha.x.i)]*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(a.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.x.i)]*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(a.i)];
      d += ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(alpha.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.x.i)];
    }
# 305 "/root/mnt/basilisk/src/poisson.h"
{
      n += ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(alpha.y.i)]*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(a.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.y.i)]*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(a.i)];
      d += ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(alpha.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.y.i)];
    }
# 319 "/root/mnt/basilisk/src/poisson.h"
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(c.i)] = n/d;
  }} } } }; }}; };}}else if(((lambda).i >= 65536) && !((alpha.x).i >= 65536)){double _const_lambda=_constant[lambda.i-65536];(void)(_const_lambda);






  {
# 303 "/root/mnt/basilisk/src/poisson.h"
{ for (int _l1 = l; _l1 >= 0; _l1--) { if (_l1 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[_l1]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.level = _l1; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; if (_l1 == l || (((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & leaf)) { {
    double n = - ((Delta)*(Delta))*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(b.i)], d = - _const_lambda*((Delta)*(Delta));
     {
      n += ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(alpha.x.i)]*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(a.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.x.i)]*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(a.i)];
      d += ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(alpha.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.x.i)];
    }
# 305 "/root/mnt/basilisk/src/poisson.h"
{
      n += ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(alpha.y.i)]*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(a.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.y.i)]*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(a.i)];
      d += ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(alpha.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.y.i)];
    }
# 319 "/root/mnt/basilisk/src/poisson.h"
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(c.i)] = n/d;
  }} } } }; }}; };}}else if(!((lambda).i >= 65536) && ((alpha.x).i >= 65536)){struct{double x,y;}_const_alpha={_constant[alpha.x.i-65536],_constant[alpha.y.i-65536]};(void)(_const_alpha);






  {
# 303 "/root/mnt/basilisk/src/poisson.h"
{ for (int _l1 = l; _l1 >= 0; _l1--) { if (_l1 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[_l1]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.level = _l1; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; if (_l1 == l || (((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & leaf)) { {
    double n = - ((Delta)*(Delta))*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(b.i)], d = - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(lambda.i)]*((Delta)*(Delta));
     {
      n += _const_alpha.x*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(a.i)] + _const_alpha.x*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(a.i)];
      d += _const_alpha.x + _const_alpha.x;
    }
# 305 "/root/mnt/basilisk/src/poisson.h"
{
      n += _const_alpha.y*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(a.i)] + _const_alpha.y*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(a.i)];
      d += _const_alpha.y + _const_alpha.y;
    }
# 319 "/root/mnt/basilisk/src/poisson.h"
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(c.i)] = n/d;
  }} } } }; }}; };}}else {double _const_lambda=_constant[lambda.i-65536];(void)(_const_lambda);struct{double x,y;}_const_alpha={_constant[alpha.x.i-65536],_constant[alpha.y.i-65536]};(void)(_const_alpha);






  {
# 303 "/root/mnt/basilisk/src/poisson.h"
{ for (int _l1 = l; _l1 >= 0; _l1--) { if (_l1 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[_l1]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.level = _l1; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; if (_l1 == l || (((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & leaf)) { {
    double n = - ((Delta)*(Delta))*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(b.i)], d = - _const_lambda*((Delta)*(Delta));
     {
      n += _const_alpha.x*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(a.i)] + _const_alpha.x*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(a.i)];
      d += _const_alpha.x + _const_alpha.x;
    }
# 305 "/root/mnt/basilisk/src/poisson.h"
{
      n += _const_alpha.y*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(a.i)] + _const_alpha.y*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(a.i)];
      d += _const_alpha.y + _const_alpha.y;
    }
# 319 "/root/mnt/basilisk/src/poisson.h"
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(c.i)] = n/d;
  }} } } }; }}; };}}
# 338 "/root/mnt/basilisk/src/poisson.h"
}






static double residual (scalar * al, scalar * bl, scalar * resl, void * data)
{
  scalar a = al[0], b = bl[0], res = resl[0];
  struct Poisson * p = (struct Poisson *) data;
          vector alpha = p->alpha;
          scalar lambda = p->lambda;
  double maxres = 0.;


  vector g=new_face_vector("g");
  { static ForeachData _loop = { "/root/mnt/basilisk/src/poisson.h", 355, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 355 "/root/mnt/basilisk/src/poisson.h" 3 4
 0
# 355 "/root/mnt/basilisk/src/poisson.h"
 ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point);{{ _loop.face |= (1 << 0);{
    {stencil_val_a (point, g.x, 0, 0, 0, 
# 356 "/root/mnt/basilisk/src/poisson.h" 3 4
    0
# 356 "/root/mnt/basilisk/src/poisson.h"
    , "/root/mnt/basilisk/src/poisson.h", 356); stencil_val (point, alpha.x, 0, 0, 0, "/root/mnt/basilisk/src/poisson.h", 356, 
# 356 "/root/mnt/basilisk/src/poisson.h" 3 4
                               0
# 356 "/root/mnt/basilisk/src/poisson.h"
                               );stencil_val (point, a, 0, 0, 0, "/root/mnt/basilisk/src/poisson.h", 356, 
# 356 "/root/mnt/basilisk/src/poisson.h" 3 4
                                                           0
# 356 "/root/mnt/basilisk/src/poisson.h"
                                                           ); stencil_val (point, a, 0 -1, 0, 0, "/root/mnt/basilisk/src/poisson.h", 356, 
# 356 "/root/mnt/basilisk/src/poisson.h" 3 4
                                                                                  0
# 356 "/root/mnt/basilisk/src/poisson.h"
                                                                                  ); }}}
# 355 "/root/mnt/basilisk/src/poisson.h"
{ _loop.face |= (1 << 1);{
    {stencil_val_a (point, g.y, 0, 0, 0, 
# 356 "/root/mnt/basilisk/src/poisson.h" 3 4
    0
# 356 "/root/mnt/basilisk/src/poisson.h"
    , "/root/mnt/basilisk/src/poisson.h", 356); stencil_val (point, alpha.y, 0, 0, 0, "/root/mnt/basilisk/src/poisson.h", 356, 
# 356 "/root/mnt/basilisk/src/poisson.h" 3 4
                               0
# 356 "/root/mnt/basilisk/src/poisson.h"
                               );stencil_val (point, a, 0, 0, 0, "/root/mnt/basilisk/src/poisson.h", 356, 
# 356 "/root/mnt/basilisk/src/poisson.h" 3 4
                                                           0
# 356 "/root/mnt/basilisk/src/poisson.h"
                                                           ); stencil_val (point, a, 0, 0 -1, 0, "/root/mnt/basilisk/src/poisson.h", 356, 
# 356 "/root/mnt/basilisk/src/poisson.h" 3 4
                                                                                  0
# 356 "/root/mnt/basilisk/src/poisson.h"
                                                                                  ); }}}}end_stencil (&_loop); _loop.first = 0;};
# 355 "/root/mnt/basilisk/src/poisson.h"
if(!((alpha.x).i >= 65536)){{{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(g.x.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.x.i)]*((((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(a.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0 -1][point.j+0]) ) + sizeof(Cell)))[(a.i)])/Delta);}}}
# 355 "/root/mnt/basilisk/src/poisson.h"
{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(g.y.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.y.i)]*((((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(a.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0 -1]) ) + sizeof(Cell)))[(a.i)])/Delta);}}}}} } };}}else {struct{double x,y;}_const_alpha={_constant[alpha.x.i-65536],_constant[alpha.y.i-65536]};(void)(_const_alpha);
  {
# 355 "/root/mnt/basilisk/src/poisson.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(g.x.i)] = _const_alpha.x*((((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(a.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0 -1][point.j+0]) ) + sizeof(Cell)))[(a.i)])/Delta);}}}
# 355 "/root/mnt/basilisk/src/poisson.h"
{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(g.y.i)] = _const_alpha.y*((((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(a.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0 -1]) ) + sizeof(Cell)))[(a.i)])/Delta);}}}}} } };}}
  { static ForeachData _loop = { "/root/mnt/basilisk/src/poisson.h", 357, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 357 "/root/mnt/basilisk/src/poisson.h" 3 4
 0
# 357 "/root/mnt/basilisk/src/poisson.h"
 ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point); {
    stencil_val_a (point, res, 0, 0, 0, 
# 358 "/root/mnt/basilisk/src/poisson.h" 3 4
   0
# 358 "/root/mnt/basilisk/src/poisson.h"
   , "/root/mnt/basilisk/src/poisson.h", 358); stencil_val (point, b, 0, 0, 0, "/root/mnt/basilisk/src/poisson.h", 358, 
# 358 "/root/mnt/basilisk/src/poisson.h" 3 4
                              0
# 358 "/root/mnt/basilisk/src/poisson.h"
                              ); stencil_val (point, lambda, 0, 0, 0, "/root/mnt/basilisk/src/poisson.h", 358, 
# 358 "/root/mnt/basilisk/src/poisson.h" 3 4
                                                     0
# 358 "/root/mnt/basilisk/src/poisson.h"
                                                     );stencil_val (point, a, 0, 0, 0, "/root/mnt/basilisk/src/poisson.h", 358, 
# 358 "/root/mnt/basilisk/src/poisson.h" 3 4
                                                                                0
# 358 "/root/mnt/basilisk/src/poisson.h"
                                                                                );

      {stencil_val_a (point, res, 0, 0, 0, 
# 360 "/root/mnt/basilisk/src/poisson.h" 3 4
      1
# 360 "/root/mnt/basilisk/src/poisson.h"
      , "/root/mnt/basilisk/src/poisson.h", 360);stencil_val (point, g.x, 1, 0, 0, "/root/mnt/basilisk/src/poisson.h", 360, 
# 360 "/root/mnt/basilisk/src/poisson.h" 3 4
                                0
# 360 "/root/mnt/basilisk/src/poisson.h"
                                ); stencil_val (point, g.x, 0, 0, 0, "/root/mnt/basilisk/src/poisson.h", 360, 
# 360 "/root/mnt/basilisk/src/poisson.h" 3 4
                                                         0
# 360 "/root/mnt/basilisk/src/poisson.h"
                                                         ); }
# 360 "/root/mnt/basilisk/src/poisson.h"
{stencil_val_a (point, res, 0, 0, 0, 
# 360 "/root/mnt/basilisk/src/poisson.h" 3 4
1
# 360 "/root/mnt/basilisk/src/poisson.h"
, "/root/mnt/basilisk/src/poisson.h", 360);stencil_val (point, g.y, 0, 1, 0, "/root/mnt/basilisk/src/poisson.h", 360, 
# 360 "/root/mnt/basilisk/src/poisson.h" 3 4
                          0
# 360 "/root/mnt/basilisk/src/poisson.h"
                          ); stencil_val (point, g.y, 0, 0, 0, "/root/mnt/basilisk/src/poisson.h", 360, 
# 360 "/root/mnt/basilisk/src/poisson.h" 3 4
                                                   0
# 360 "/root/mnt/basilisk/src/poisson.h"
                                                   ); }






stencil_val (point, res, 0, 0, 0, "/root/mnt/basilisk/src/poisson.h", 367, 
# 367 "/root/mnt/basilisk/src/poisson.h" 3 4
0
# 367 "/root/mnt/basilisk/src/poisson.h"
);
      {stencil_val (point, res, 0, 0, 0, "/root/mnt/basilisk/src/poisson.h", 368, 
# 368 "/root/mnt/basilisk/src/poisson.h" 3 4
      0
# 368 "/root/mnt/basilisk/src/poisson.h"
      ); }
# 369 "/root/mnt/basilisk/src/poisson.h"
}end_stencil (&_loop); _loop.first = 0;};
# 357 "/root/mnt/basilisk/src/poisson.h"
if(!((lambda).i >= 65536)){


{
# 357 "/root/mnt/basilisk/src/poisson.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(res.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(b.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(lambda.i)]*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(a.i)];

      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(res.i)] -= (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(g.x.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(g.x.i)])/Delta;
# 360 "/root/mnt/basilisk/src/poisson.h"
((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(res.i)] -= (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(g.y.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(g.y.i)])/Delta;






    if (fabs (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(res.i)]) > maxres)
      maxres = fabs (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(res.i)]);
  }} } };;


}
# 369 "/root/mnt/basilisk/src/poisson.h"
}else {double _const_lambda=_constant[lambda.i-65536];(void)(_const_lambda);



{
# 357 "/root/mnt/basilisk/src/poisson.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(res.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(b.i)] - _const_lambda*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(a.i)];

      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(res.i)] -= (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(g.x.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(g.x.i)])/Delta;
# 360 "/root/mnt/basilisk/src/poisson.h"
((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(res.i)] -= (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(g.y.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(g.y.i)])/Delta;






    if (fabs (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(res.i)]) > maxres)
      maxres = fabs (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(res.i)]);
  }} } };;


}
# 369 "/root/mnt/basilisk/src/poisson.h"
}
# 387 "/root/mnt/basilisk/src/poisson.h"
  {delete((scalar*)((vector[]){g,{{-1},{-1}}}));return maxres;}delete((scalar*)((vector[]){g,{{-1},{-1}}}));
}
# 399 "/root/mnt/basilisk/src/poisson.h"
mgstats poisson (struct Poisson p)
{






  if (!p.alpha.x.i)
    p.alpha = unityf;
  if (!p.lambda.i)
    p.lambda = zeroc;




  vector alpha = p.alpha;
  scalar lambda = p.lambda;
  restriction (((scalar[]){alpha.x,alpha.y,lambda,{-1}}));





  double defaultol = TOLERANCE;
  if (p.tolerance)
    TOLERANCE = p.tolerance;

  scalar a = p.a, b = p.b;




  mgstats s = mg_solve ((struct MGSolve){((scalar[]){a,{-1}}), ((scalar[]){b,{-1}}), residual, relax,
   &p, p.nrelax, p.res, .minlevel = ((1) > (p.minlevel) ? (1) : (p.minlevel))});




  if (p.tolerance)
    TOLERANCE = defaultol;

  return s;
}
# 461 "/root/mnt/basilisk/src/poisson.h"
struct Project {
  vector uf;
  scalar p;
  vector alpha;
  double dt;
  int nrelax;
};


mgstats project (struct Project q)
{;
  vector uf = q.uf;
  scalar p = q.p;
          vector alpha = q.alpha.x.i ? q.alpha : unityf;
  double dt = q.dt ? q.dt : 1.;
  int nrelax = q.nrelax ? q.nrelax : 4;






  scalar div=new_scalar("div");
  { static ForeachData _loop = { "/root/mnt/basilisk/src/poisson.h", 484, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 484 "/root/mnt/basilisk/src/poisson.h" 3 4
 0
# 484 "/root/mnt/basilisk/src/poisson.h"
 ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point); {
    stencil_val_a (point, div, 0, 0, 0, 
# 485 "/root/mnt/basilisk/src/poisson.h" 3 4
   0
# 485 "/root/mnt/basilisk/src/poisson.h"
   , "/root/mnt/basilisk/src/poisson.h", 485);

      {stencil_val_a (point, div, 0, 0, 0, 
# 487 "/root/mnt/basilisk/src/poisson.h" 3 4
      1
# 487 "/root/mnt/basilisk/src/poisson.h"
      , "/root/mnt/basilisk/src/poisson.h", 487); stencil_val (point, uf.x, 1, 0, 0, "/root/mnt/basilisk/src/poisson.h", 487, 
# 487 "/root/mnt/basilisk/src/poisson.h" 3 4
                                 0
# 487 "/root/mnt/basilisk/src/poisson.h"
                                 ); stencil_val (point, uf.x, 0, 0, 0, "/root/mnt/basilisk/src/poisson.h", 487, 
# 487 "/root/mnt/basilisk/src/poisson.h" 3 4
                                                           0
# 487 "/root/mnt/basilisk/src/poisson.h"
                                                           ); }
# 487 "/root/mnt/basilisk/src/poisson.h"
{stencil_val_a (point, div, 0, 0, 0, 
# 487 "/root/mnt/basilisk/src/poisson.h" 3 4
1
# 487 "/root/mnt/basilisk/src/poisson.h"
, "/root/mnt/basilisk/src/poisson.h", 487); stencil_val (point, uf.y, 0, 1, 0, "/root/mnt/basilisk/src/poisson.h", 487, 
# 487 "/root/mnt/basilisk/src/poisson.h" 3 4
                           0
# 487 "/root/mnt/basilisk/src/poisson.h"
                           ); stencil_val (point, uf.y, 0, 0, 0, "/root/mnt/basilisk/src/poisson.h", 487, 
# 487 "/root/mnt/basilisk/src/poisson.h" 3 4
                                                     0
# 487 "/root/mnt/basilisk/src/poisson.h"
                                                     ); }
    stencil_val_a (point, div, 0, 0, 0, 
# 488 "/root/mnt/basilisk/src/poisson.h" 3 4
   1
# 488 "/root/mnt/basilisk/src/poisson.h"
   , "/root/mnt/basilisk/src/poisson.h", 488);
  }end_stencil (&_loop); _loop.first = 0;};
  {
# 484 "/root/mnt/basilisk/src/poisson.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(div.i)] = 0.;

      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(div.i)] += ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(uf.x.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.x.i)];
# 487 "/root/mnt/basilisk/src/poisson.h"
((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(div.i)] += ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(uf.y.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.y.i)];
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(div.i)] /= dt*Delta;
  }} } };}
# 500 "/root/mnt/basilisk/src/poisson.h"
  mgstats mgp = poisson ((struct Poisson){p, div, alpha,
    .tolerance = TOLERANCE/((dt)*(dt)), .nrelax = nrelax});




  { static ForeachData _loop = { "/root/mnt/basilisk/src/poisson.h", 506, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 506 "/root/mnt/basilisk/src/poisson.h" 3 4
 0
# 506 "/root/mnt/basilisk/src/poisson.h"
 ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point);{{ _loop.face |= (1 << 0);{
    {stencil_val_a (point, uf.x, 0, 0, 0, 
# 507 "/root/mnt/basilisk/src/poisson.h" 3 4
    1
# 507 "/root/mnt/basilisk/src/poisson.h"
    , "/root/mnt/basilisk/src/poisson.h", 507);stencil_val (point, alpha.x, 0, 0, 0, "/root/mnt/basilisk/src/poisson.h", 507, 
# 507 "/root/mnt/basilisk/src/poisson.h" 3 4
                               0
# 507 "/root/mnt/basilisk/src/poisson.h"
                               );stencil_val (point, p, 0, 0, 0, "/root/mnt/basilisk/src/poisson.h", 507, 
# 507 "/root/mnt/basilisk/src/poisson.h" 3 4
                                                           0
# 507 "/root/mnt/basilisk/src/poisson.h"
                                                           ); stencil_val (point, p, 0 -1, 0, 0, "/root/mnt/basilisk/src/poisson.h", 507, 
# 507 "/root/mnt/basilisk/src/poisson.h" 3 4
                                                                                  0
# 507 "/root/mnt/basilisk/src/poisson.h"
                                                                                  ); }}}
# 506 "/root/mnt/basilisk/src/poisson.h"
{ _loop.face |= (1 << 1);{
    {stencil_val_a (point, uf.y, 0, 0, 0, 
# 507 "/root/mnt/basilisk/src/poisson.h" 3 4
    1
# 507 "/root/mnt/basilisk/src/poisson.h"
    , "/root/mnt/basilisk/src/poisson.h", 507);stencil_val (point, alpha.y, 0, 0, 0, "/root/mnt/basilisk/src/poisson.h", 507, 
# 507 "/root/mnt/basilisk/src/poisson.h" 3 4
                               0
# 507 "/root/mnt/basilisk/src/poisson.h"
                               );stencil_val (point, p, 0, 0, 0, "/root/mnt/basilisk/src/poisson.h", 507, 
# 507 "/root/mnt/basilisk/src/poisson.h" 3 4
                                                           0
# 507 "/root/mnt/basilisk/src/poisson.h"
                                                           ); stencil_val (point, p, 0, 0 -1, 0, "/root/mnt/basilisk/src/poisson.h", 507, 
# 507 "/root/mnt/basilisk/src/poisson.h" 3 4
                                                                                  0
# 507 "/root/mnt/basilisk/src/poisson.h"
                                                                                  ); }}}}end_stencil (&_loop); _loop.first = 0;};
# 506 "/root/mnt/basilisk/src/poisson.h"
if(!((alpha.x).i >= 65536)){{{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.x.i)] -= dt*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.x.i)]*((((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(p.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0 -1][point.j+0]) ) + sizeof(Cell)))[(p.i)])/Delta);}}}
# 506 "/root/mnt/basilisk/src/poisson.h"
{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.y.i)] -= dt*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.y.i)]*((((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(p.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0 -1]) ) + sizeof(Cell)))[(p.i)])/Delta);}}}}} } };}}else {struct{double x,y;}_const_alpha={_constant[alpha.x.i-65536],_constant[alpha.y.i-65536]};(void)(_const_alpha);




  {
# 506 "/root/mnt/basilisk/src/poisson.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.x.i)] -= dt*_const_alpha.x*((((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(p.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0 -1][point.j+0]) ) + sizeof(Cell)))[(p.i)])/Delta);}}}
# 506 "/root/mnt/basilisk/src/poisson.h"
{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.y.i)] -= dt*_const_alpha.y*((((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(p.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0 -1]) ) + sizeof(Cell)))[(p.i)])/Delta);}}}}} } };}}

  {delete((scalar*)((scalar[]){div,{-1}}));{;return mgp;}}delete((scalar*)((scalar[]){div,{-1}}));
;}
# 2 "/root/mnt/basilisk/src/viscosity.h"

struct Viscosity {
  vector u;
  vector mu;
  scalar rho;
  double dt;
  int nrelax;
  scalar * res;
};
# 25 "/root/mnt/basilisk/src/viscosity.h"
static void relax_viscosity (scalar * a, scalar * b, int l, void * data)
{
  struct Viscosity * p = (struct Viscosity *) data;
          vector mu = p->mu;
          scalar rho = p->rho;
  double dt = p->dt;
  vector u = (*((vector *)&(a[0]))), r = (*((vector *)&(b[0])));




  vector w = u;


  if(!((rho).i >= 65536) && !((mu.x).i >= 65536)){{{ for (int _l1 = l; _l1 >= 0; _l1--) { if (_l1 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[_l1]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.level = _l1; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; if (_l1 == l || (((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & leaf)) { {

      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(w.x.i)] = (dt/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(rho.i)]*(2.*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(mu.x.i)]*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(u.x.i)] + 2.*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(mu.x.i)]*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(u.x.i)]

      + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(mu.y.i)]*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(u.x.i)] +
     (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+1]) ) + sizeof(Cell)))[(u.y.i)])/4. -
     (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+1]) ) + sizeof(Cell)))[(u.y.i)])/4.)
      - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(mu.y.i)]*(- ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(u.x.i)] +
         (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+-1]) ) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(u.y.i)])/4. -
         (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+-1]) ) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(u.y.i)])/4.)
# 58 "/root/mnt/basilisk/src/viscosity.h"
      ) + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(r.x.i)]*((Delta)*(Delta)))/
    (((Delta)*(Delta))*((coord){1.,1.}).x + dt/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(rho.i)]*(2.*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(mu.x.i)] + 2.*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(mu.x.i)]

          + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(mu.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(mu.y.i)]




        ));
# 41 "/root/mnt/basilisk/src/viscosity.h"
((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(w.y.i)] = (dt/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(rho.i)]*(2.*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(mu.y.i)]*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(u.y.i)] + 2.*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(mu.y.i)]*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(u.y.i)]

      + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(mu.x.i)]*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] +
     (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+1]) ) + sizeof(Cell)))[(u.x.i)])/4. -
     (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+-1]) ) + sizeof(Cell)))[(u.x.i)])/4.)
      - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(mu.x.i)]*(- ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] +
         (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+1]) ) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(u.x.i)])/4. -
         (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+-1]) ) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(u.x.i)])/4.)
# 58 "/root/mnt/basilisk/src/viscosity.h"
      ) + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(r.y.i)]*((Delta)*(Delta)))/
    (((Delta)*(Delta))*((coord){1.,1.}).y + dt/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(rho.i)]*(2.*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(mu.y.i)] + 2.*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(mu.y.i)]

          + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(mu.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(mu.x.i)]




        ));
  }} } } }; }}; };}}else if(((rho).i >= 65536) && !((mu.x).i >= 65536)){double _const_rho=_constant[rho.i-65536];(void)(_const_rho);


  {
# 39 "/root/mnt/basilisk/src/viscosity.h"
{ for (int _l1 = l; _l1 >= 0; _l1--) { if (_l1 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[_l1]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.level = _l1; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; if (_l1 == l || (((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & leaf)) { {

      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(w.x.i)] = (dt/_const_rho*(2.*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(mu.x.i)]*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(u.x.i)] + 2.*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(mu.x.i)]*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(u.x.i)]

      + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(mu.y.i)]*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(u.x.i)] +
     (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+1]) ) + sizeof(Cell)))[(u.y.i)])/4. -
     (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+1]) ) + sizeof(Cell)))[(u.y.i)])/4.)
      - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(mu.y.i)]*(- ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(u.x.i)] +
         (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+-1]) ) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(u.y.i)])/4. -
         (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+-1]) ) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(u.y.i)])/4.)
# 58 "/root/mnt/basilisk/src/viscosity.h"
      ) + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(r.x.i)]*((Delta)*(Delta)))/
    (((Delta)*(Delta))*((coord){1.,1.}).x + dt/_const_rho*(2.*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(mu.x.i)] + 2.*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(mu.x.i)]

          + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(mu.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(mu.y.i)]




        ));
# 41 "/root/mnt/basilisk/src/viscosity.h"
((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(w.y.i)] = (dt/_const_rho*(2.*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(mu.y.i)]*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(u.y.i)] + 2.*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(mu.y.i)]*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(u.y.i)]

      + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(mu.x.i)]*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] +
     (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+1]) ) + sizeof(Cell)))[(u.x.i)])/4. -
     (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+-1]) ) + sizeof(Cell)))[(u.x.i)])/4.)
      - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(mu.x.i)]*(- ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] +
         (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+1]) ) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(u.x.i)])/4. -
         (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+-1]) ) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(u.x.i)])/4.)
# 58 "/root/mnt/basilisk/src/viscosity.h"
      ) + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(r.y.i)]*((Delta)*(Delta)))/
    (((Delta)*(Delta))*((coord){1.,1.}).y + dt/_const_rho*(2.*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(mu.y.i)] + 2.*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(mu.y.i)]

          + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(mu.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(mu.x.i)]




        ));
  }} } } }; }}; };}}else if(!((rho).i >= 65536) && ((mu.x).i >= 65536)){struct{double x,y;}_const_mu={_constant[mu.x.i-65536],_constant[mu.y.i-65536]};(void)(_const_mu);


  {
# 39 "/root/mnt/basilisk/src/viscosity.h"
{ for (int _l1 = l; _l1 >= 0; _l1--) { if (_l1 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[_l1]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.level = _l1; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; if (_l1 == l || (((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & leaf)) { {

      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(w.x.i)] = (dt/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(rho.i)]*(2.*_const_mu.x*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(u.x.i)] + 2.*_const_mu.x*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(u.x.i)]

      + _const_mu.y*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(u.x.i)] +
     (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+1]) ) + sizeof(Cell)))[(u.y.i)])/4. -
     (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+1]) ) + sizeof(Cell)))[(u.y.i)])/4.)
      - _const_mu.y*(- ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(u.x.i)] +
         (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+-1]) ) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(u.y.i)])/4. -
         (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+-1]) ) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(u.y.i)])/4.)
# 58 "/root/mnt/basilisk/src/viscosity.h"
      ) + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(r.x.i)]*((Delta)*(Delta)))/
    (((Delta)*(Delta))*((coord){1.,1.}).x + dt/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(rho.i)]*(2.*_const_mu.x + 2.*_const_mu.x

          + _const_mu.y + _const_mu.y




        ));
# 41 "/root/mnt/basilisk/src/viscosity.h"
((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(w.y.i)] = (dt/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(rho.i)]*(2.*_const_mu.y*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(u.y.i)] + 2.*_const_mu.y*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(u.y.i)]

      + _const_mu.x*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] +
     (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+1]) ) + sizeof(Cell)))[(u.x.i)])/4. -
     (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+-1]) ) + sizeof(Cell)))[(u.x.i)])/4.)
      - _const_mu.x*(- ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] +
         (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+1]) ) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(u.x.i)])/4. -
         (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+-1]) ) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(u.x.i)])/4.)
# 58 "/root/mnt/basilisk/src/viscosity.h"
      ) + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(r.y.i)]*((Delta)*(Delta)))/
    (((Delta)*(Delta))*((coord){1.,1.}).y + dt/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(rho.i)]*(2.*_const_mu.y + 2.*_const_mu.y

          + _const_mu.x + _const_mu.x




        ));
  }} } } }; }}; };}}else {double _const_rho=_constant[rho.i-65536];(void)(_const_rho);struct{double x,y;}_const_mu={_constant[mu.x.i-65536],_constant[mu.y.i-65536]};(void)(_const_mu);


  {
# 39 "/root/mnt/basilisk/src/viscosity.h"
{ for (int _l1 = l; _l1 >= 0; _l1--) { if (_l1 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[_l1]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.level = _l1; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; if (_l1 == l || (((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & leaf)) { {

      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(w.x.i)] = (dt/_const_rho*(2.*_const_mu.x*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(u.x.i)] + 2.*_const_mu.x*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(u.x.i)]

      + _const_mu.y*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(u.x.i)] +
     (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+1]) ) + sizeof(Cell)))[(u.y.i)])/4. -
     (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+1]) ) + sizeof(Cell)))[(u.y.i)])/4.)
      - _const_mu.y*(- ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(u.x.i)] +
         (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+-1]) ) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(u.y.i)])/4. -
         (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+-1]) ) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(u.y.i)])/4.)
# 58 "/root/mnt/basilisk/src/viscosity.h"
      ) + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(r.x.i)]*((Delta)*(Delta)))/
    (((Delta)*(Delta))*((coord){1.,1.}).x + dt/_const_rho*(2.*_const_mu.x + 2.*_const_mu.x

          + _const_mu.y + _const_mu.y




        ));
# 41 "/root/mnt/basilisk/src/viscosity.h"
((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(w.y.i)] = (dt/_const_rho*(2.*_const_mu.y*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(u.y.i)] + 2.*_const_mu.y*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(u.y.i)]

      + _const_mu.x*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] +
     (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+1]) ) + sizeof(Cell)))[(u.x.i)])/4. -
     (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+-1]) ) + sizeof(Cell)))[(u.x.i)])/4.)
      - _const_mu.x*(- ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] +
         (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+1]) ) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(u.x.i)])/4. -
         (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+-1]) ) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(u.x.i)])/4.)
# 58 "/root/mnt/basilisk/src/viscosity.h"
      ) + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(r.y.i)]*((Delta)*(Delta)))/
    (((Delta)*(Delta))*((coord){1.,1.}).y + dt/_const_rho*(2.*_const_mu.y + 2.*_const_mu.y

          + _const_mu.x + _const_mu.x




        ));
  }} } } }; }}; };}}
# 85 "/root/mnt/basilisk/src/viscosity.h"
}

static double residual_viscosity (scalar * a, scalar * b, scalar * resl,
      void * data)
{
  struct Viscosity * p = (struct Viscosity *) data;
          vector mu = p->mu;
          scalar rho = p->rho;
  double dt = p->dt;
  vector u = (*((vector *)&(a[0]))), r = (*((vector *)&(b[0]))), res = (*((vector *)&(resl[0])));
  double maxres = 0.;
# 104 "/root/mnt/basilisk/src/viscosity.h"
  boundary_internal ((scalar *)((vector[]){u,{{-1},{-1}}}), "/root/mnt/basilisk/src/viscosity.h", 104);

   {
    vector taux=new_face_vector("taux");
    { static ForeachData _loop = { "/root/mnt/basilisk/src/viscosity.h", 108, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 108 "/root/mnt/basilisk/src/viscosity.h" 3 4
   0
# 108 "/root/mnt/basilisk/src/viscosity.h"
   ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point);{ _loop.face |= (1 << 0);{
      {stencil_val_a (point, taux.x, 0, 0, 0, 
# 109 "/root/mnt/basilisk/src/viscosity.h" 3 4
      0
# 109 "/root/mnt/basilisk/src/viscosity.h"
      , "/root/mnt/basilisk/src/viscosity.h", 109);stencil_val (point, mu.x, 0, 0, 0, "/root/mnt/basilisk/src/viscosity.h", 109, 
# 109 "/root/mnt/basilisk/src/viscosity.h" 3 4
                                   0
# 109 "/root/mnt/basilisk/src/viscosity.h"
                                   );stencil_val (point, u.x, 0, 0, 0, "/root/mnt/basilisk/src/viscosity.h", 109, 
# 109 "/root/mnt/basilisk/src/viscosity.h" 3 4
                                                            0
# 109 "/root/mnt/basilisk/src/viscosity.h"
                                                            ); stencil_val (point, u.x, -1, 0, 0, "/root/mnt/basilisk/src/viscosity.h", 109, 
# 109 "/root/mnt/basilisk/src/viscosity.h" 3 4
                                                                                     0
# 109 "/root/mnt/basilisk/src/viscosity.h"
                                                                                     ); }}}end_stencil (&_loop); _loop.first = 0;};
# 108 "/root/mnt/basilisk/src/viscosity.h"
if(!((mu.x).i >= 65536)){{{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(taux.x.i)] = 2.*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(mu.x.i)]*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(u.x.i)])/Delta;}}}} } };}}else {struct{double x,y;}_const_mu={_constant[mu.x.i-65536],_constant[mu.y.i-65536]};(void)(_const_mu);
    {
# 108 "/root/mnt/basilisk/src/viscosity.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(taux.x.i)] = 2.*_const_mu.x*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(u.x.i)])/Delta;}}}} } };}}

      { static ForeachData _loop = { "/root/mnt/basilisk/src/viscosity.h", 111, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 111 "/root/mnt/basilisk/src/viscosity.h" 3 4
     0
# 111 "/root/mnt/basilisk/src/viscosity.h"
     ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point);{ _loop.face |= (1 << 1);{
 {stencil_val_a (point, taux.y, 0, 0, 0, 
# 112 "/root/mnt/basilisk/src/viscosity.h" 3 4
 0
# 112 "/root/mnt/basilisk/src/viscosity.h"
 , "/root/mnt/basilisk/src/viscosity.h", 112); stencil_val (point, mu.y, 0, 0, 0, "/root/mnt/basilisk/src/viscosity.h", 112, 
# 112 "/root/mnt/basilisk/src/viscosity.h" 3 4
                               0
# 112 "/root/mnt/basilisk/src/viscosity.h"
                               );stencil_val (point, u.x, 0, 0, 0, "/root/mnt/basilisk/src/viscosity.h", 112, 
# 112 "/root/mnt/basilisk/src/viscosity.h" 3 4
                                                        0
# 112 "/root/mnt/basilisk/src/viscosity.h"
                                                        ); stencil_val (point, u.x, 0, -1, 0, "/root/mnt/basilisk/src/viscosity.h", 112, 
# 112 "/root/mnt/basilisk/src/viscosity.h" 3 4
                                                                                 0
# 112 "/root/mnt/basilisk/src/viscosity.h"
                                                                                 );
stencil_val (point, u.y, 1, -1, 0, "/root/mnt/basilisk/src/viscosity.h", 113, 
# 113 "/root/mnt/basilisk/src/viscosity.h" 3 4
0
# 113 "/root/mnt/basilisk/src/viscosity.h"
); stencil_val (point, u.y, 1, 0, 0, "/root/mnt/basilisk/src/viscosity.h", 113, 
# 113 "/root/mnt/basilisk/src/viscosity.h" 3 4
                         0
# 113 "/root/mnt/basilisk/src/viscosity.h"
                         );
stencil_val (point, u.y, -1, -1, 0, "/root/mnt/basilisk/src/viscosity.h", 114, 
# 114 "/root/mnt/basilisk/src/viscosity.h" 3 4
0
# 114 "/root/mnt/basilisk/src/viscosity.h"
); stencil_val (point, u.y, -1, 0, 0, "/root/mnt/basilisk/src/viscosity.h", 114, 
# 114 "/root/mnt/basilisk/src/viscosity.h" 3 4
                          0
# 114 "/root/mnt/basilisk/src/viscosity.h"
                          );
# 114 "/root/mnt/basilisk/src/viscosity.h"
}}}end_stencil (&_loop); _loop.first = 0;};
# 111 "/root/mnt/basilisk/src/viscosity.h"
if(!((mu.x).i >= 65536)){{{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{
 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(taux.y.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(mu.y.i)]*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(u.x.i)] +
      (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+-1]) ) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(u.y.i)])/4. -
      (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+-1]) ) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(u.y.i)])/4.)/Delta;}}}} } };}}else {struct{double x,y;}_const_mu={_constant[mu.x.i-65536],_constant[mu.y.i-65536]};(void)(_const_mu);

      {
# 111 "/root/mnt/basilisk/src/viscosity.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{
 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(taux.y.i)] = _const_mu.y*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(u.x.i)] +
      (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+-1]) ) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(u.y.i)])/4. -
      (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+-1]) ) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(u.y.i)])/4.)/Delta;}}}} } };}}







    { static ForeachData _loop = { "/root/mnt/basilisk/src/viscosity.h", 122, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 122 "/root/mnt/basilisk/src/viscosity.h" 3 4
   0
# 122 "/root/mnt/basilisk/src/viscosity.h"
   ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point); {


 { stencil_val (point, taux.x, 1, 0, 0, "/root/mnt/basilisk/src/viscosity.h", 125, 
# 125 "/root/mnt/basilisk/src/viscosity.h" 3 4
  0
# 125 "/root/mnt/basilisk/src/viscosity.h"
  ); stencil_val (point, taux.x, 0, 0, 0, "/root/mnt/basilisk/src/viscosity.h", 125, 
# 125 "/root/mnt/basilisk/src/viscosity.h" 3 4
                              0
# 125 "/root/mnt/basilisk/src/viscosity.h"
                              ); }
# 125 "/root/mnt/basilisk/src/viscosity.h"
{ stencil_val (point, taux.y, 0, 1, 0, "/root/mnt/basilisk/src/viscosity.h", 125, 
# 125 "/root/mnt/basilisk/src/viscosity.h" 3 4
 0
# 125 "/root/mnt/basilisk/src/viscosity.h"
 ); stencil_val (point, taux.y, 0, 0, 0, "/root/mnt/basilisk/src/viscosity.h", 125, 
# 125 "/root/mnt/basilisk/src/viscosity.h" 3 4
                             0
# 125 "/root/mnt/basilisk/src/viscosity.h"
                             ); }
      stencil_val_a (point, res.x, 0, 0, 0, 
# 126 "/root/mnt/basilisk/src/viscosity.h" 3 4
     0
# 126 "/root/mnt/basilisk/src/viscosity.h"
     , "/root/mnt/basilisk/src/viscosity.h", 126); stencil_val (point, r.x, 0, 0, 0, "/root/mnt/basilisk/src/viscosity.h", 126, 
# 126 "/root/mnt/basilisk/src/viscosity.h" 3 4
                                  0
# 126 "/root/mnt/basilisk/src/viscosity.h"
                                  );stencil_val (point, u.x, 0, 0, 0, "/root/mnt/basilisk/src/viscosity.h", 126, 
# 126 "/root/mnt/basilisk/src/viscosity.h" 3 4
                                                          0
# 126 "/root/mnt/basilisk/src/viscosity.h"
                                                          );stencil_val (point, rho, 0, 0, 0, "/root/mnt/basilisk/src/viscosity.h", 126, 
# 126 "/root/mnt/basilisk/src/viscosity.h" 3 4
                                                                                  0
# 126 "/root/mnt/basilisk/src/viscosity.h"
                                                                                  );
stencil_val (point, res.x, 0, 0, 0, "/root/mnt/basilisk/src/viscosity.h", 127, 
# 127 "/root/mnt/basilisk/src/viscosity.h" 3 4
0
# 127 "/root/mnt/basilisk/src/viscosity.h"
);
 {stencil_val (point, res.x, 0, 0, 0, "/root/mnt/basilisk/src/viscosity.h", 128, 
# 128 "/root/mnt/basilisk/src/viscosity.h" 3 4
 0
# 128 "/root/mnt/basilisk/src/viscosity.h"
 ); }
# 129 "/root/mnt/basilisk/src/viscosity.h"
}end_stencil (&_loop); _loop.first = 0;};
# 122 "/root/mnt/basilisk/src/viscosity.h"
if(!((rho).i >= 65536)){


{
# 122 "/root/mnt/basilisk/src/viscosity.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
      double d = 0.;

 d += ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(taux.x.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(taux.x.i)];
# 125 "/root/mnt/basilisk/src/viscosity.h"
d += ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(taux.y.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(taux.y.i)];
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(res.x.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(r.x.i)] - ((coord){1.,1.}).x*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.x.i)] + dt/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(rho.i)]*d/Delta;
      if (fabs (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(res.x.i)]) > maxres)
 maxres = fabs (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(res.x.i)]);
    }} } };;


}
# 129 "/root/mnt/basilisk/src/viscosity.h"
}else {double _const_rho=_constant[rho.i-65536];(void)(_const_rho);
# 140 "/root/mnt/basilisk/src/viscosity.h"
{
# 122 "/root/mnt/basilisk/src/viscosity.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
      double d = 0.;

 d += ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(taux.x.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(taux.x.i)];
# 125 "/root/mnt/basilisk/src/viscosity.h"
d += ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(taux.y.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(taux.y.i)];
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(res.x.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(r.x.i)] - ((coord){1.,1.}).x*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.x.i)] + dt/_const_rho*d/Delta;
      if (fabs (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(res.x.i)]) > maxres)
 maxres = fabs (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(res.x.i)]);
    }} } };;


}
# 129 "/root/mnt/basilisk/src/viscosity.h"
}delete((scalar*)((vector[]){taux,{{-1},{-1}}}));
  }
# 106 "/root/mnt/basilisk/src/viscosity.h"
{
    vector taux=new_face_vector("taux");
    { static ForeachData _loop = { "/root/mnt/basilisk/src/viscosity.h", 108, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 108 "/root/mnt/basilisk/src/viscosity.h" 3 4
   0
# 108 "/root/mnt/basilisk/src/viscosity.h"
   ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point);{ _loop.face |= (1 << 1);{
      {stencil_val_a (point, taux.y, 0, 0, 0, 
# 109 "/root/mnt/basilisk/src/viscosity.h" 3 4
      0
# 109 "/root/mnt/basilisk/src/viscosity.h"
      , "/root/mnt/basilisk/src/viscosity.h", 109);stencil_val (point, mu.y, 0, 0, 0, "/root/mnt/basilisk/src/viscosity.h", 109, 
# 109 "/root/mnt/basilisk/src/viscosity.h" 3 4
                                   0
# 109 "/root/mnt/basilisk/src/viscosity.h"
                                   );stencil_val (point, u.y, 0, 0, 0, "/root/mnt/basilisk/src/viscosity.h", 109, 
# 109 "/root/mnt/basilisk/src/viscosity.h" 3 4
                                                            0
# 109 "/root/mnt/basilisk/src/viscosity.h"
                                                            ); stencil_val (point, u.y, 0, -1, 0, "/root/mnt/basilisk/src/viscosity.h", 109, 
# 109 "/root/mnt/basilisk/src/viscosity.h" 3 4
                                                                                     0
# 109 "/root/mnt/basilisk/src/viscosity.h"
                                                                                     ); }}}end_stencil (&_loop); _loop.first = 0;};
# 108 "/root/mnt/basilisk/src/viscosity.h"
if(!((mu.y).i >= 65536)){{{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(taux.y.i)] = 2.*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(mu.y.i)]*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(u.y.i)])/Delta;}}}} } };}}else {struct{double x,y;}_const_mu={_constant[mu.y.i-65536],_constant[mu.x.i-65536]};(void)(_const_mu);
    {
# 108 "/root/mnt/basilisk/src/viscosity.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(taux.y.i)] = 2.*_const_mu.y*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(u.y.i)])/Delta;}}}} } };}}

      { static ForeachData _loop = { "/root/mnt/basilisk/src/viscosity.h", 111, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 111 "/root/mnt/basilisk/src/viscosity.h" 3 4
     0
# 111 "/root/mnt/basilisk/src/viscosity.h"
     ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point);{ _loop.face |= (1 << 0);{
 {stencil_val_a (point, taux.x, 0, 0, 0, 
# 112 "/root/mnt/basilisk/src/viscosity.h" 3 4
 0
# 112 "/root/mnt/basilisk/src/viscosity.h"
 , "/root/mnt/basilisk/src/viscosity.h", 112); stencil_val (point, mu.x, 0, 0, 0, "/root/mnt/basilisk/src/viscosity.h", 112, 
# 112 "/root/mnt/basilisk/src/viscosity.h" 3 4
                               0
# 112 "/root/mnt/basilisk/src/viscosity.h"
                               );stencil_val (point, u.y, 0, 0, 0, "/root/mnt/basilisk/src/viscosity.h", 112, 
# 112 "/root/mnt/basilisk/src/viscosity.h" 3 4
                                                        0
# 112 "/root/mnt/basilisk/src/viscosity.h"
                                                        ); stencil_val (point, u.y, -1, 0, 0, "/root/mnt/basilisk/src/viscosity.h", 112, 
# 112 "/root/mnt/basilisk/src/viscosity.h" 3 4
                                                                                 0
# 112 "/root/mnt/basilisk/src/viscosity.h"
                                                                                 );
stencil_val (point, u.x, -1, 1, 0, "/root/mnt/basilisk/src/viscosity.h", 113, 
# 113 "/root/mnt/basilisk/src/viscosity.h" 3 4
0
# 113 "/root/mnt/basilisk/src/viscosity.h"
); stencil_val (point, u.x, 0, 1, 0, "/root/mnt/basilisk/src/viscosity.h", 113, 
# 113 "/root/mnt/basilisk/src/viscosity.h" 3 4
                         0
# 113 "/root/mnt/basilisk/src/viscosity.h"
                         );
stencil_val (point, u.x, -1, -1, 0, "/root/mnt/basilisk/src/viscosity.h", 114, 
# 114 "/root/mnt/basilisk/src/viscosity.h" 3 4
0
# 114 "/root/mnt/basilisk/src/viscosity.h"
); stencil_val (point, u.x, 0, -1, 0, "/root/mnt/basilisk/src/viscosity.h", 114, 
# 114 "/root/mnt/basilisk/src/viscosity.h" 3 4
                          0
# 114 "/root/mnt/basilisk/src/viscosity.h"
                          );
# 114 "/root/mnt/basilisk/src/viscosity.h"
}}}end_stencil (&_loop); _loop.first = 0;};
# 111 "/root/mnt/basilisk/src/viscosity.h"
if(!((mu.y).i >= 65536)){{{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{
 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(taux.x.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(mu.x.i)]*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] +
      (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+1]) ) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(u.x.i)])/4. -
      (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+-1]) ) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(u.x.i)])/4.)/Delta;}}}} } };}}else {struct{double x,y;}_const_mu={_constant[mu.y.i-65536],_constant[mu.x.i-65536]};(void)(_const_mu);

      {
# 111 "/root/mnt/basilisk/src/viscosity.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{
 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(taux.x.i)] = _const_mu.x*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] +
      (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+1]) ) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(u.x.i)])/4. -
      (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+-1]) ) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(u.x.i)])/4.)/Delta;}}}} } };}}







    { static ForeachData _loop = { "/root/mnt/basilisk/src/viscosity.h", 122, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 122 "/root/mnt/basilisk/src/viscosity.h" 3 4
   0
# 122 "/root/mnt/basilisk/src/viscosity.h"
   ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point); {


 { stencil_val (point, taux.y, 0, 1, 0, "/root/mnt/basilisk/src/viscosity.h", 125, 
# 125 "/root/mnt/basilisk/src/viscosity.h" 3 4
  0
# 125 "/root/mnt/basilisk/src/viscosity.h"
  ); stencil_val (point, taux.y, 0, 0, 0, "/root/mnt/basilisk/src/viscosity.h", 125, 
# 125 "/root/mnt/basilisk/src/viscosity.h" 3 4
                              0
# 125 "/root/mnt/basilisk/src/viscosity.h"
                              ); }
# 125 "/root/mnt/basilisk/src/viscosity.h"
{ stencil_val (point, taux.x, 1, 0, 0, "/root/mnt/basilisk/src/viscosity.h", 125, 
# 125 "/root/mnt/basilisk/src/viscosity.h" 3 4
 0
# 125 "/root/mnt/basilisk/src/viscosity.h"
 ); stencil_val (point, taux.x, 0, 0, 0, "/root/mnt/basilisk/src/viscosity.h", 125, 
# 125 "/root/mnt/basilisk/src/viscosity.h" 3 4
                             0
# 125 "/root/mnt/basilisk/src/viscosity.h"
                             ); }
      stencil_val_a (point, res.y, 0, 0, 0, 
# 126 "/root/mnt/basilisk/src/viscosity.h" 3 4
     0
# 126 "/root/mnt/basilisk/src/viscosity.h"
     , "/root/mnt/basilisk/src/viscosity.h", 126); stencil_val (point, r.y, 0, 0, 0, "/root/mnt/basilisk/src/viscosity.h", 126, 
# 126 "/root/mnt/basilisk/src/viscosity.h" 3 4
                                  0
# 126 "/root/mnt/basilisk/src/viscosity.h"
                                  );stencil_val (point, u.y, 0, 0, 0, "/root/mnt/basilisk/src/viscosity.h", 126, 
# 126 "/root/mnt/basilisk/src/viscosity.h" 3 4
                                                          0
# 126 "/root/mnt/basilisk/src/viscosity.h"
                                                          );stencil_val (point, rho, 0, 0, 0, "/root/mnt/basilisk/src/viscosity.h", 126, 
# 126 "/root/mnt/basilisk/src/viscosity.h" 3 4
                                                                                  0
# 126 "/root/mnt/basilisk/src/viscosity.h"
                                                                                  );
stencil_val (point, res.y, 0, 0, 0, "/root/mnt/basilisk/src/viscosity.h", 127, 
# 127 "/root/mnt/basilisk/src/viscosity.h" 3 4
0
# 127 "/root/mnt/basilisk/src/viscosity.h"
);
 {stencil_val (point, res.y, 0, 0, 0, "/root/mnt/basilisk/src/viscosity.h", 128, 
# 128 "/root/mnt/basilisk/src/viscosity.h" 3 4
 0
# 128 "/root/mnt/basilisk/src/viscosity.h"
 ); }
# 129 "/root/mnt/basilisk/src/viscosity.h"
}end_stencil (&_loop); _loop.first = 0;};
# 122 "/root/mnt/basilisk/src/viscosity.h"
if(!((rho).i >= 65536)){


{
# 122 "/root/mnt/basilisk/src/viscosity.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
      double d = 0.;

 d += ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(taux.y.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(taux.y.i)];
# 125 "/root/mnt/basilisk/src/viscosity.h"
d += ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(taux.x.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(taux.x.i)];
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(res.y.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(r.y.i)] - ((coord){1.,1.}).y*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] + dt/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(rho.i)]*d/Delta;
      if (fabs (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(res.y.i)]) > maxres)
 maxres = fabs (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(res.y.i)]);
    }} } };;


}
# 129 "/root/mnt/basilisk/src/viscosity.h"
}else {double _const_rho=_constant[rho.i-65536];(void)(_const_rho);
# 140 "/root/mnt/basilisk/src/viscosity.h"
{
# 122 "/root/mnt/basilisk/src/viscosity.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
      double d = 0.;

 d += ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(taux.y.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(taux.y.i)];
# 125 "/root/mnt/basilisk/src/viscosity.h"
d += ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(taux.x.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(taux.x.i)];
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(res.y.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(r.y.i)] - ((coord){1.,1.}).y*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] + dt/_const_rho*d/Delta;
      if (fabs (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(res.y.i)]) > maxres)
 maxres = fabs (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(res.y.i)]);
    }} } };;


}
# 129 "/root/mnt/basilisk/src/viscosity.h"
}delete((scalar*)((vector[]){taux,{{-1},{-1}}}));
  }
# 159 "/root/mnt/basilisk/src/viscosity.h"
  return maxres;
}




mgstats viscosity (struct Viscosity p)
{;
  vector u = p.u, r=new_vector("r");
  { static ForeachData _loop = { "/root/mnt/basilisk/src/viscosity.h", 168, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 168 "/root/mnt/basilisk/src/viscosity.h" 3 4
 0
# 168 "/root/mnt/basilisk/src/viscosity.h"
 ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point);
    {
      {stencil_val_a (point, r.x, 0, 0, 0, 
# 170 "/root/mnt/basilisk/src/viscosity.h" 3 4
      0
# 170 "/root/mnt/basilisk/src/viscosity.h"
      , "/root/mnt/basilisk/src/viscosity.h", 170); stencil_val (point, u.x, 0, 0, 0, "/root/mnt/basilisk/src/viscosity.h", 170, 
# 170 "/root/mnt/basilisk/src/viscosity.h" 3 4
                                 0
# 170 "/root/mnt/basilisk/src/viscosity.h"
                                 ); }
# 170 "/root/mnt/basilisk/src/viscosity.h"
{stencil_val_a (point, r.y, 0, 0, 0, 
# 170 "/root/mnt/basilisk/src/viscosity.h" 3 4
0
# 170 "/root/mnt/basilisk/src/viscosity.h"
, "/root/mnt/basilisk/src/viscosity.h", 170); stencil_val (point, u.y, 0, 0, 0, "/root/mnt/basilisk/src/viscosity.h", 170, 
# 170 "/root/mnt/basilisk/src/viscosity.h" 3 4
                           0
# 170 "/root/mnt/basilisk/src/viscosity.h"
                           ); }}end_stencil (&_loop); _loop.first = 0;};
  {
# 168 "/root/mnt/basilisk/src/viscosity.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    {
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(r.x.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.x.i)];
# 170 "/root/mnt/basilisk/src/viscosity.h"
((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(r.y.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.y.i)];}} } };}

  vector mu = p.mu;
  scalar rho = p.rho;
  restriction (((scalar[]){mu.x,mu.y,rho,{-1}}));

  { mgstats _ret= mg_solve ((struct MGSolve){(scalar *)((vector[]){u,{{-1},{-1}}}), (scalar *)((vector[]){r,{{-1},{-1}}}),
     residual_viscosity, relax_viscosity, &p, p.nrelax, p.res});delete((scalar*)((vector[]){r,{{-1},{-1}}}));{;return _ret;}}delete((scalar*)((vector[]){r,{{-1},{-1}}}));
;}


mgstats viscosity_explicit (struct Viscosity p)
{;
  vector u = p.u, r=new_vector("r");
  mgstats mg = {0};
  mg.resb = residual_viscosity ((scalar *)((vector[]){u,{{-1},{-1}}}), (scalar *)((vector[]){u,{{-1},{-1}}}), (scalar *)((vector[]){r,{{-1},{-1}}}), &p);
  { static ForeachData _loop = { "/root/mnt/basilisk/src/viscosity.h", 186, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 186 "/root/mnt/basilisk/src/viscosity.h" 3 4
 0
# 186 "/root/mnt/basilisk/src/viscosity.h"
 ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point);
    {
      {stencil_val_a (point, u.x, 0, 0, 0, 
# 188 "/root/mnt/basilisk/src/viscosity.h" 3 4
      1
# 188 "/root/mnt/basilisk/src/viscosity.h"
      , "/root/mnt/basilisk/src/viscosity.h", 188); stencil_val (point, r.x, 0, 0, 0, "/root/mnt/basilisk/src/viscosity.h", 188, 
# 188 "/root/mnt/basilisk/src/viscosity.h" 3 4
                                 0
# 188 "/root/mnt/basilisk/src/viscosity.h"
                                 ); }
# 188 "/root/mnt/basilisk/src/viscosity.h"
{stencil_val_a (point, u.y, 0, 0, 0, 
# 188 "/root/mnt/basilisk/src/viscosity.h" 3 4
1
# 188 "/root/mnt/basilisk/src/viscosity.h"
, "/root/mnt/basilisk/src/viscosity.h", 188); stencil_val (point, r.y, 0, 0, 0, "/root/mnt/basilisk/src/viscosity.h", 188, 
# 188 "/root/mnt/basilisk/src/viscosity.h" 3 4
                           0
# 188 "/root/mnt/basilisk/src/viscosity.h"
                           ); }}end_stencil (&_loop); _loop.first = 0;};
  {
# 186 "/root/mnt/basilisk/src/viscosity.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    {
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.x.i)] += ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(r.x.i)];
# 188 "/root/mnt/basilisk/src/viscosity.h"
((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] += ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(r.y.i)];}} } };}
  {delete((scalar*)((vector[]){r,{{-1},{-1}}}));{;return mg;}}delete((scalar*)((vector[]){r,{{-1},{-1}}}));
;}
# 34 "/root/mnt/basilisk/src/navier-stokes/centered.h"
# 44 "/root/mnt/basilisk/src/navier-stokes/centered.h"
scalar p={0};
vector u={{1},{2}}, g={{3},{4}};
scalar pf={5};
vector uf={{6},{7}};
# 70 "/root/mnt/basilisk/src/navier-stokes/centered.h"
        vector mu = {{65536 +0},{65536 +1}}, a = {{65536 +0},{65536 +1}}, alpha = {{65536 +2},{65536 +3}};
        scalar rho = {65536 +4};
mgstats mgp, mgpf, mgu;

# 73 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
_Bool 
# 73 "/root/mnt/basilisk/src/navier-stokes/centered.h"
    stokes = 
# 73 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
             0
# 73 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                  ;
# 91 "/root/mnt/basilisk/src/navier-stokes/centered.h"
static double _boundary0(Point point,Point neighbor,scalar _s,void *data){int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;if(!((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)){{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;(void)(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;return (Delta*((((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(a.x.i)]*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)]/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(alpha.x.i)])) + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(_s.i)]);}}}else if(((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)){struct{double x,y;}_const_a={_constant[a.x.i-65536],_constant[a.y.i-65536]};(void)(_const_a);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;(void)(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;return (Delta*((_const_a.x*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)]/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(alpha.x.i)])) + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(_s.i)]);}}}else if(!((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)){struct{double x,y;}_const_fm={_constant[fm.x.i-65536],_constant[fm.y.i-65536]};(void)(_const_fm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;(void)(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;return (Delta*((((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(a.x.i)]*_const_fm.x/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(alpha.x.i)])) + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(_s.i)]);}}}else if(((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)){struct{double x,y;}_const_a={_constant[a.x.i-65536],_constant[a.y.i-65536]};(void)(_const_a);struct{double x,y;}_const_fm={_constant[fm.x.i-65536],_constant[fm.y.i-65536]};(void)(_const_fm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;(void)(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;return (Delta*((_const_a.x*_const_fm.x/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(alpha.x.i)])) + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(_s.i)]);}}}else if(!((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)){struct{double x,y;}_const_alpha={_constant[alpha.x.i-65536],_constant[alpha.y.i-65536]};(void)(_const_alpha);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;(void)(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;return (Delta*((((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(a.x.i)]*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)]/_const_alpha.x)) + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(_s.i)]);}}}else if(((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)){struct{double x,y;}_const_a={_constant[a.x.i-65536],_constant[a.y.i-65536]};(void)(_const_a);struct{double x,y;}_const_alpha={_constant[alpha.x.i-65536],_constant[alpha.y.i-65536]};(void)(_const_alpha);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;(void)(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;return (Delta*((_const_a.x*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)]/_const_alpha.x)) + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(_s.i)]);}}}else if(!((a.x).i >= 65536) && ((fm.x).i >= 65536) && ((alpha.x).i >= 65536)){struct{double x,y;}_const_fm={_constant[fm.x.i-65536],_constant[fm.y.i-65536]};(void)(_const_fm);struct{double x,y;}_const_alpha={_constant[alpha.x.i-65536],_constant[alpha.y.i-65536]};(void)(_const_alpha);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;(void)(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;return (Delta*((((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(a.x.i)]*_const_fm.x/_const_alpha.x)) + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(_s.i)]);}}}else {struct{double x,y;}_const_a={_constant[a.x.i-65536],_constant[a.y.i-65536]};(void)(_const_a);struct{double x,y;}_const_fm={_constant[fm.x.i-65536],_constant[fm.y.i-65536]};(void)(_const_fm);struct{double x,y;}_const_alpha={_constant[alpha.x.i-65536],_constant[alpha.y.i-65536]};(void)(_const_alpha);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;(void)(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;return (Delta*((_const_a.x*_const_fm.x/_const_alpha.x)) + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(_s.i)]);}}}}static double _boundary0_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;(void)(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;return (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(_s.i)]);}}
static double _boundary1(Point point,Point neighbor,scalar _s,void *data){int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;if(!((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)){{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;(void)(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;return (Delta*(- (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(a.x.i)]*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)]/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.x.i)])) + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(_s.i)]);}}}else if(((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)){struct{double x,y;}_const_a={_constant[a.x.i-65536],_constant[a.y.i-65536]};(void)(_const_a);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;(void)(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;return (Delta*(- (_const_a.x*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)]/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.x.i)])) + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(_s.i)]);}}}else if(!((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)){struct{double x,y;}_const_fm={_constant[fm.x.i-65536],_constant[fm.y.i-65536]};(void)(_const_fm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;(void)(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;return (Delta*(- (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(a.x.i)]*_const_fm.x/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.x.i)])) + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(_s.i)]);}}}else if(((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)){struct{double x,y;}_const_a={_constant[a.x.i-65536],_constant[a.y.i-65536]};(void)(_const_a);struct{double x,y;}_const_fm={_constant[fm.x.i-65536],_constant[fm.y.i-65536]};(void)(_const_fm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;(void)(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;return (Delta*(- (_const_a.x*_const_fm.x/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.x.i)])) + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(_s.i)]);}}}else if(!((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)){struct{double x,y;}_const_alpha={_constant[alpha.x.i-65536],_constant[alpha.y.i-65536]};(void)(_const_alpha);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;(void)(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;return (Delta*(- (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(a.x.i)]*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)]/_const_alpha.x)) + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(_s.i)]);}}}else if(((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)){struct{double x,y;}_const_a={_constant[a.x.i-65536],_constant[a.y.i-65536]};(void)(_const_a);struct{double x,y;}_const_alpha={_constant[alpha.x.i-65536],_constant[alpha.y.i-65536]};(void)(_const_alpha);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;(void)(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;return (Delta*(- (_const_a.x*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)]/_const_alpha.x)) + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(_s.i)]);}}}else if(!((a.x).i >= 65536) && ((fm.x).i >= 65536) && ((alpha.x).i >= 65536)){struct{double x,y;}_const_fm={_constant[fm.x.i-65536],_constant[fm.y.i-65536]};(void)(_const_fm);struct{double x,y;}_const_alpha={_constant[alpha.x.i-65536],_constant[alpha.y.i-65536]};(void)(_const_alpha);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;(void)(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;return (Delta*(- (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(a.x.i)]*_const_fm.x/_const_alpha.x)) + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(_s.i)]);}}}else {struct{double x,y;}_const_a={_constant[a.x.i-65536],_constant[a.y.i-65536]};(void)(_const_a);struct{double x,y;}_const_fm={_constant[fm.x.i-65536],_constant[fm.y.i-65536]};(void)(_const_fm);struct{double x,y;}_const_alpha={_constant[alpha.x.i-65536],_constant[alpha.y.i-65536]};(void)(_const_alpha);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;(void)(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;return (Delta*(- (_const_a.x*_const_fm.x/_const_alpha.x)) + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(_s.i)]);}}}}static double _boundary1_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;(void)(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;return (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(_s.i)]);}}
# 101 "/root/mnt/basilisk/src/navier-stokes/centered.h"
static double _boundary2(Point point,Point neighbor,scalar _s,void *data){int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;if(!((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)){{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;(void)(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;return (Delta*((((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(a.y.i)]*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(fm.y.i)]/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(alpha.y.i)])) + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(_s.i)]);}}}else if(((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)){struct{double x,y;}_const_a={_constant[a.x.i-65536],_constant[a.y.i-65536]};(void)(_const_a);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;(void)(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;return (Delta*((_const_a.y*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(fm.y.i)]/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(alpha.y.i)])) + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(_s.i)]);}}}else if(!((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)){struct{double x,y;}_const_fm={_constant[fm.x.i-65536],_constant[fm.y.i-65536]};(void)(_const_fm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;(void)(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;return (Delta*((((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(a.y.i)]*_const_fm.y/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(alpha.y.i)])) + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(_s.i)]);}}}else if(((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)){struct{double x,y;}_const_a={_constant[a.x.i-65536],_constant[a.y.i-65536]};(void)(_const_a);struct{double x,y;}_const_fm={_constant[fm.x.i-65536],_constant[fm.y.i-65536]};(void)(_const_fm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;(void)(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;return (Delta*((_const_a.y*_const_fm.y/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(alpha.y.i)])) + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(_s.i)]);}}}else if(!((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)){struct{double x,y;}_const_alpha={_constant[alpha.x.i-65536],_constant[alpha.y.i-65536]};(void)(_const_alpha);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;(void)(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;return (Delta*((((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(a.y.i)]*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(fm.y.i)]/_const_alpha.y)) + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(_s.i)]);}}}else if(((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)){struct{double x,y;}_const_a={_constant[a.x.i-65536],_constant[a.y.i-65536]};(void)(_const_a);struct{double x,y;}_const_alpha={_constant[alpha.x.i-65536],_constant[alpha.y.i-65536]};(void)(_const_alpha);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;(void)(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;return (Delta*((_const_a.y*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(fm.y.i)]/_const_alpha.y)) + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(_s.i)]);}}}else if(!((a.x).i >= 65536) && ((fm.x).i >= 65536) && ((alpha.x).i >= 65536)){struct{double x,y;}_const_fm={_constant[fm.x.i-65536],_constant[fm.y.i-65536]};(void)(_const_fm);struct{double x,y;}_const_alpha={_constant[alpha.x.i-65536],_constant[alpha.y.i-65536]};(void)(_const_alpha);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;(void)(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;return (Delta*((((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(a.y.i)]*_const_fm.y/_const_alpha.y)) + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(_s.i)]);}}}else {struct{double x,y;}_const_a={_constant[a.x.i-65536],_constant[a.y.i-65536]};(void)(_const_a);struct{double x,y;}_const_fm={_constant[fm.x.i-65536],_constant[fm.y.i-65536]};(void)(_const_fm);struct{double x,y;}_const_alpha={_constant[alpha.x.i-65536],_constant[alpha.y.i-65536]};(void)(_const_alpha);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;(void)(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;return (Delta*((_const_a.y*_const_fm.y/_const_alpha.y)) + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(_s.i)]);}}}}static double _boundary2_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;(void)(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;return (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(_s.i)]);}}
static double _boundary3(Point point,Point neighbor,scalar _s,void *data){int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;if(!((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)){{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;(void)(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;return (Delta*(- (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(a.y.i)]*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)]/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.y.i)])) + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(_s.i)]);}}}else if(((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)){struct{double x,y;}_const_a={_constant[a.x.i-65536],_constant[a.y.i-65536]};(void)(_const_a);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;(void)(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;return (Delta*(- (_const_a.y*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)]/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.y.i)])) + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(_s.i)]);}}}else if(!((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)){struct{double x,y;}_const_fm={_constant[fm.x.i-65536],_constant[fm.y.i-65536]};(void)(_const_fm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;(void)(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;return (Delta*(- (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(a.y.i)]*_const_fm.y/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.y.i)])) + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(_s.i)]);}}}else if(((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)){struct{double x,y;}_const_a={_constant[a.x.i-65536],_constant[a.y.i-65536]};(void)(_const_a);struct{double x,y;}_const_fm={_constant[fm.x.i-65536],_constant[fm.y.i-65536]};(void)(_const_fm);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;(void)(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;return (Delta*(- (_const_a.y*_const_fm.y/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.y.i)])) + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(_s.i)]);}}}else if(!((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)){struct{double x,y;}_const_alpha={_constant[alpha.x.i-65536],_constant[alpha.y.i-65536]};(void)(_const_alpha);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;(void)(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;return (Delta*(- (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(a.y.i)]*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)]/_const_alpha.y)) + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(_s.i)]);}}}else if(((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)){struct{double x,y;}_const_a={_constant[a.x.i-65536],_constant[a.y.i-65536]};(void)(_const_a);struct{double x,y;}_const_alpha={_constant[alpha.x.i-65536],_constant[alpha.y.i-65536]};(void)(_const_alpha);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;(void)(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;return (Delta*(- (_const_a.y*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)]/_const_alpha.y)) + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(_s.i)]);}}}else if(!((a.x).i >= 65536) && ((fm.x).i >= 65536) && ((alpha.x).i >= 65536)){struct{double x,y;}_const_fm={_constant[fm.x.i-65536],_constant[fm.y.i-65536]};(void)(_const_fm);struct{double x,y;}_const_alpha={_constant[alpha.x.i-65536],_constant[alpha.y.i-65536]};(void)(_const_alpha);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;(void)(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;return (Delta*(- (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(a.y.i)]*_const_fm.y/_const_alpha.y)) + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(_s.i)]);}}}else {struct{double x,y;}_const_a={_constant[a.x.i-65536],_constant[a.y.i-65536]};(void)(_const_a);struct{double x,y;}_const_fm={_constant[fm.x.i-65536],_constant[fm.y.i-65536]};(void)(_const_fm);struct{double x,y;}_const_alpha={_constant[alpha.x.i-65536],_constant[alpha.y.i-65536]};(void)(_const_alpha);{{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;(void)(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;return (Delta*(- (_const_a.y*_const_fm.y/_const_alpha.y)) + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(_s.i)]);}}}}static double _boundary3_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;(void)(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;return (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(_s.i)]);}}
# 126 "/root/mnt/basilisk/src/navier-stokes/centered.h"
static int defaults_0_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i = 0);*ip=i;*tp=t;return ret;} static int defaults_0(const int i,const double t,Event *_ev){;
{

  CFL = 0.8;




  _attribute[p.i].nodump = _attribute[pf.i].nodump = 
# 134 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                                    1
# 134 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                                        ;




  if (alpha.x.i == unityf.x.i) {
    alpha = fm;
    rho = cm;
  }
  else if (!((alpha.x).i >= 65536)) {
    vector alphav = alpha;
    { static ForeachData _loop = { "/root/mnt/basilisk/src/navier-stokes/centered.h", 145, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 145 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
   0
# 145 "/root/mnt/basilisk/src/navier-stokes/centered.h"
   ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point);{{ _loop.face |= (1 << 0);{
      {stencil_val_a (point, alphav.x, 0, 0, 0, 
# 146 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
      0
# 146 "/root/mnt/basilisk/src/navier-stokes/centered.h"
      , "/root/mnt/basilisk/src/navier-stokes/centered.h", 146); stencil_val (point, fm.x, 0, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 146, 
# 146 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                      0
# 146 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                      ); }}}
# 145 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{ _loop.face |= (1 << 1);{
      {stencil_val_a (point, alphav.y, 0, 0, 0, 
# 146 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
      0
# 146 "/root/mnt/basilisk/src/navier-stokes/centered.h"
      , "/root/mnt/basilisk/src/navier-stokes/centered.h", 146); stencil_val (point, fm.y, 0, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 146, 
# 146 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                      0
# 146 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                      ); }}}}end_stencil (&_loop); _loop.first = 0;};
# 145 "/root/mnt/basilisk/src/navier-stokes/centered.h"
if(!((fm.x).i >= 65536)){{{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alphav.x.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)];}}}
# 145 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alphav.y.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)];}}}}} } };}}else {struct{double x,y;}_const_fm={_constant[fm.x.i-65536],_constant[fm.y.i-65536]};(void)(_const_fm);
    {
# 145 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alphav.x.i)] = _const_fm.x;}}}
# 145 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alphav.y.i)] = _const_fm.y;}}}}} } };}}
  }






  _attribute[uf.x.i].refine = refine_face_solenoidal;
# 173 "/root/mnt/basilisk/src/navier-stokes/centered.h"
}{;return 0;};}





static int default_display_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i = 0);*ip=i;*tp=t;return ret;} static int default_display(const int i,const double t,Event *_ev){;
  display ((struct _display){"squares (color = 'u.x', spread = -1);"});{;return 0;};}





double dtmax;

static int init_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i = 0);*ip=i;*tp=t;return ret;} static int init(const int i,const double t,Event *_ev){;
{
  ;
  { static ForeachData _loop = { "/root/mnt/basilisk/src/navier-stokes/centered.h", 191, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 191 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
 0
# 191 "/root/mnt/basilisk/src/navier-stokes/centered.h"
 ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point);{{ _loop.face |= (1 << 0);{
    {stencil_val_a (point, uf.x, 0, 0, 0, 
# 192 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
    0
# 192 "/root/mnt/basilisk/src/navier-stokes/centered.h"
    , "/root/mnt/basilisk/src/navier-stokes/centered.h", 192); stencil_val (point, fm.x, 0, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 192, 
# 192 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                0
# 192 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                );stencil_val (point, u.x, 0, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 192, 
# 192 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                                         0
# 192 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                                         ); stencil_val (point, u.x, 0 -1, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 192, 
# 192 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                                                                  0
# 192 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                                                                  ); }}}
# 191 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{ _loop.face |= (1 << 1);{
    {stencil_val_a (point, uf.y, 0, 0, 0, 
# 192 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
    0
# 192 "/root/mnt/basilisk/src/navier-stokes/centered.h"
    , "/root/mnt/basilisk/src/navier-stokes/centered.h", 192); stencil_val (point, fm.y, 0, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 192, 
# 192 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                0
# 192 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                );stencil_val (point, u.y, 0, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 192, 
# 192 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                                         0
# 192 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                                         ); stencil_val (point, u.y, 0, 0 -1, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 192, 
# 192 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                                                                  0
# 192 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                                                                  ); }}}}end_stencil (&_loop); _loop.first = 0;};
# 191 "/root/mnt/basilisk/src/navier-stokes/centered.h"
if(!((fm.x).i >= 65536)){{{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.x.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)]*((((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0 -1][point.j+0]) ) + sizeof(Cell)))[(u.x.i)])/2.);}}}
# 191 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.y.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)]*((((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0 -1]) ) + sizeof(Cell)))[(u.y.i)])/2.);}}}}} } };}}else {struct{double x,y;}_const_fm={_constant[fm.x.i-65536],_constant[fm.y.i-65536]};(void)(_const_fm);
  {
# 191 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.x.i)] = _const_fm.x*((((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0 -1][point.j+0]) ) + sizeof(Cell)))[(u.x.i)])/2.);}}}
# 191 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.y.i)] = _const_fm.y*((((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0 -1]) ) + sizeof(Cell)))[(u.y.i)])/2.);}}}}} } };}}




  event ("properties");





  dtmax = DT;
  event ("stability");
}{;return 0;};}
# 214 "/root/mnt/basilisk/src/navier-stokes/centered.h"
static int set_dtmax_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;} static int set_dtmax(const int i,const double t,Event *_ev){; dtmax = DT;{;return 0;};}

static int stability_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;} static int stability(const int i,const double t,Event *_ev){; {
  dt = dtnext (stokes ? dtmax : timestep (uf, dtmax));
}{;return 0;};}







static int vof_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;}static int vof(const int i,const double t,Event *_ev){;return 0;}
static int tracer_advection_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;}static int tracer_advection(const int i,const double t,Event *_ev){;return 0;}
static int tracer_diffusion_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;}static int tracer_diffusion(const int i,const double t,Event *_ev){;return 0;}






static int properties_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;}static int properties(const int i,const double t,Event *_ev){;return 0;}
# 247 "/root/mnt/basilisk/src/navier-stokes/centered.h"
void prediction()
{
  vector du;
   {
    scalar s = new_scalar("s");
    du.x = s;
  }
# 250 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{
    scalar s = new_scalar("s");
    du.y = s;
  }

  if (_attribute[u.x.i].gradient)
    {
# 256 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{ static ForeachData _loop = { "/root/mnt/basilisk/src/navier-stokes/centered.h", 256, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 256 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
0
# 256 "/root/mnt/basilisk/src/navier-stokes/centered.h"
; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point);
      { {





   stencil_val_a (point, du.x, 0, 0, 0, 
# 263 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
  0
# 263 "/root/mnt/basilisk/src/navier-stokes/centered.h"
  , "/root/mnt/basilisk/src/navier-stokes/centered.h", 263);stencil_val (point, u.x, -1, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 263, 
# 263 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                             0
# 263 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                             ); stencil_val (point, u.x, 0, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 263, 
# 263 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                                       0
# 263 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                                       ); stencil_val (point, u.x, 1, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 263, 
# 263 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                                                                0
# 263 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                                                                );
      }
# 257 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{





   stencil_val_a (point, du.y, 0, 0, 0, 
# 263 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
  0
# 263 "/root/mnt/basilisk/src/navier-stokes/centered.h"
  , "/root/mnt/basilisk/src/navier-stokes/centered.h", 263);stencil_val (point, u.y, 0, -1, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 263, 
# 263 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                             0
# 263 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                             ); stencil_val (point, u.y, 0, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 263, 
# 263 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                                       0
# 263 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                                       ); stencil_val (point, u.y, 0, 1, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 263, 
# 263 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                                                                0
# 263 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                                                                );
      }}end_stencil (&_loop); _loop.first = 0;};{
# 256 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
      { {





   ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(du.x.i)] = _attribute[u.x.i].gradient (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(u.x.i)], ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.x.i)], ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(u.x.i)])/Delta;
      }
# 257 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{





   ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(du.y.i)] = _attribute[u.y.i].gradient (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(u.y.i)], ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.y.i)], ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(u.y.i)])/Delta;
      }}} } };}}
  else
    {
# 266 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{ static ForeachData _loop = { "/root/mnt/basilisk/src/navier-stokes/centered.h", 266, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 266 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
0
# 266 "/root/mnt/basilisk/src/navier-stokes/centered.h"
; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point);
      { {





   stencil_val_a (point, du.x, 0, 0, 0, 
# 273 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
  0
# 273 "/root/mnt/basilisk/src/navier-stokes/centered.h"
  , "/root/mnt/basilisk/src/navier-stokes/centered.h", 273);stencil_val (point, u.x, 1, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 273, 
# 273 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                             0
# 273 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                             ); stencil_val (point, u.x, -1, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 273, 
# 273 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                                      0
# 273 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                                      );
    }
# 267 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{





   stencil_val_a (point, du.y, 0, 0, 0, 
# 273 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
  0
# 273 "/root/mnt/basilisk/src/navier-stokes/centered.h"
  , "/root/mnt/basilisk/src/navier-stokes/centered.h", 273);stencil_val (point, u.y, 0, 1, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 273, 
# 273 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                             0
# 273 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                             ); stencil_val (point, u.y, 0, -1, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 273, 
# 273 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                                      0
# 273 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                                      );
    }}end_stencil (&_loop); _loop.first = 0;};{
# 266 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
      { {





   ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(du.x.i)] = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(u.x.i)])/(2.*Delta);
    }
# 267 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{





   ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(du.y.i)] = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(u.y.i)])/(2.*Delta);
    }}} } };}}

  ;
  { static ForeachData _loop = { "/root/mnt/basilisk/src/navier-stokes/centered.h", 277, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 277 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
 0
# 277 "/root/mnt/basilisk/src/navier-stokes/centered.h"
 ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point);{{ _loop.face |= (1 << 0);{ {
     stencil_val (point, u.x, -1, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 278, 
# 278 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
    0
# 278 "/root/mnt/basilisk/src/navier-stokes/centered.h"
    );stencil_val (point, u.x, 0, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 278, 
# 278 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                             0
# 278 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                             );

    stencil_val_a (point, uf.x, 0, 0, 0, 
# 280 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
   0
# 280 "/root/mnt/basilisk/src/navier-stokes/centered.h"
   , "/root/mnt/basilisk/src/navier-stokes/centered.h", 280);stencil_val (point, u.x, -2, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 280, 
# 280 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                              0
# 280 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                              );stencil_val (point, g.x, 0, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 280, 
# 280 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                                               0
# 280 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                                               ); stencil_val (point, g.x, -1, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 280, 
# 280 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                                                                        0
# 280 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                                                                        );stencil_val (point, du.x, -2, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 280, 
# 280 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                                                                                                 0
# 280 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                                                                                                 );

stencil_val (point, fm.y, -2, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 282, 
# 282 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
0
# 282 "/root/mnt/basilisk/src/navier-stokes/centered.h"
); stencil_val (point, fm.y, -2, 1, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 282, 
# 282 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                 0
# 282 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                 ); {
       stencil_val (point, u.x, -2, -1, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 283, 
# 283 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
      0
# 283 "/root/mnt/basilisk/src/navier-stokes/centered.h"
      );stencil_val (point, u.x, -2, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 283, 
# 283 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                       0
# 283 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                       );stencil_val (point, u.x, -2, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 283, 
# 283 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                                                        0
# 283 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                                                        ); stencil_val (point, u.x, -2, 1, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 283, 
# 283 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                                                                                          0
# 283 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                                                                                          );stencil_val (point, u.y, -2, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 283, 
# 283 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                                                                                                                          0
# 283 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                                                                                                                          );
      stencil_val_a (point, uf.x, 0, 0, 0, 
# 284 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
     1
# 284 "/root/mnt/basilisk/src/navier-stokes/centered.h"
     , "/root/mnt/basilisk/src/navier-stokes/centered.h", 284);stencil_val (point, u.y, -2, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 284, 
# 284 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                0
# 284 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                );
    }
# 293 "/root/mnt/basilisk/src/navier-stokes/centered.h"
stencil_val_a (point, uf.x, 0, 0, 0, 
# 293 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
1
# 293 "/root/mnt/basilisk/src/navier-stokes/centered.h"
, "/root/mnt/basilisk/src/navier-stokes/centered.h", 293); stencil_val (point, fm.x, 0, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 293, 
# 293 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                           0
# 293 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                           );
  }}}
# 277 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{ _loop.face |= (1 << 1);{ {
     stencil_val (point, u.y, 0, -1, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 278, 
# 278 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
    0
# 278 "/root/mnt/basilisk/src/navier-stokes/centered.h"
    );stencil_val (point, u.y, 0, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 278, 
# 278 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                             0
# 278 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                             );

    stencil_val_a (point, uf.y, 0, 0, 0, 
# 280 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
   0
# 280 "/root/mnt/basilisk/src/navier-stokes/centered.h"
   , "/root/mnt/basilisk/src/navier-stokes/centered.h", 280);stencil_val (point, u.y, 0, -2, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 280, 
# 280 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                              0
# 280 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                              );stencil_val (point, g.y, 0, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 280, 
# 280 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                                               0
# 280 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                                               ); stencil_val (point, g.y, 0, -1, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 280, 
# 280 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                                                                        0
# 280 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                                                                        );stencil_val (point, du.y, 0, -2, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 280, 
# 280 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                                                                                                 0
# 280 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                                                                                                 );

stencil_val (point, fm.x, 0, -2, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 282, 
# 282 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
0
# 282 "/root/mnt/basilisk/src/navier-stokes/centered.h"
); stencil_val (point, fm.x, 1, -2, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 282, 
# 282 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                 0
# 282 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                 ); {
       stencil_val (point, u.y, -1, -2, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 283, 
# 283 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
      0
# 283 "/root/mnt/basilisk/src/navier-stokes/centered.h"
      );stencil_val (point, u.y, 0, -2, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 283, 
# 283 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                       0
# 283 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                       );stencil_val (point, u.y, 0, -2, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 283, 
# 283 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                                                        0
# 283 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                                                        ); stencil_val (point, u.y, 1, -2, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 283, 
# 283 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                                                                                          0
# 283 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                                                                                          );stencil_val (point, u.x, 0, -2, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 283, 
# 283 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                                                                                                                          0
# 283 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                                                                                                                          );
      stencil_val_a (point, uf.y, 0, 0, 0, 
# 284 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
     1
# 284 "/root/mnt/basilisk/src/navier-stokes/centered.h"
     , "/root/mnt/basilisk/src/navier-stokes/centered.h", 284);stencil_val (point, u.x, 0, -2, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 284, 
# 284 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                0
# 284 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                );
    }
# 293 "/root/mnt/basilisk/src/navier-stokes/centered.h"
stencil_val_a (point, uf.y, 0, 0, 0, 
# 293 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
1
# 293 "/root/mnt/basilisk/src/navier-stokes/centered.h"
, "/root/mnt/basilisk/src/navier-stokes/centered.h", 293); stencil_val (point, fm.y, 0, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 293, 
# 293 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                           0
# 293 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                           );
  }}}}end_stencil (&_loop); _loop.first = 0;};
# 277 "/root/mnt/basilisk/src/navier-stokes/centered.h"
if(!((fm.x).i >= 65536)){{{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{ {
    double un = dt*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(u.x.i)])/(2.*Delta), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.x.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(u.x.i)] + (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(g.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(g.x.i)])*dt/4. + s*(1. - s*un)*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(du.x.i)]*Delta/2.;

    if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)] && ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+1]) ) + sizeof(Cell)))[(fm.y.i)]) {
      double fyy = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] < 0. ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+1]) ) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(u.x.i)] : ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+-1]) ) + sizeof(Cell)))[(u.x.i)];
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.x.i)] -= dt*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(u.y.i)]*fyy/(2.*Delta);
    }







    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.x.i)] *= ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)];
  }}}}
# 277 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{ {
    double un = dt*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(u.y.i)])/(2.*Delta), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.y.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(u.y.i)] + (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(g.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(g.y.i)])*dt/4. + s*(1. - s*un)*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(du.y.i)]*Delta/2.;

    if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(fm.x.i)] && ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+i]) ) + sizeof(Cell)))[(fm.x.i)]) {
      double fyy = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(u.x.i)] < 0. ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+i]) ) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(u.y.i)] : ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+i]) ) + sizeof(Cell)))[(u.y.i)];
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.y.i)] -= dt*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(u.x.i)]*fyy/(2.*Delta);
    }







    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.y.i)] *= ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)];
  }}}}}} } };}}else {struct{double x,y;}_const_fm={_constant[fm.x.i-65536],_constant[fm.y.i-65536]};(void)(_const_fm);
  {
# 277 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{ {
    double un = dt*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(u.x.i)])/(2.*Delta), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.x.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(u.x.i)] + (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(g.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(g.x.i)])*dt/4. + s*(1. - s*un)*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(du.x.i)]*Delta/2.;

    if (_const_fm.y && _const_fm.y) {
      double fyy = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] < 0. ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+1]) ) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(u.x.i)] : ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+-1]) ) + sizeof(Cell)))[(u.x.i)];
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.x.i)] -= dt*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(u.y.i)]*fyy/(2.*Delta);
    }







    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.x.i)] *= _const_fm.x;
  }}}}
# 277 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{ {
    double un = dt*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(u.y.i)])/(2.*Delta), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.y.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(u.y.i)] + (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(g.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(g.y.i)])*dt/4. + s*(1. - s*un)*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(du.y.i)]*Delta/2.;

    if (_const_fm.x && _const_fm.x) {
      double fyy = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(u.x.i)] < 0. ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+i]) ) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(u.y.i)] : ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+i]) ) + sizeof(Cell)))[(u.y.i)];
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.y.i)] -= dt*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(u.x.i)]*fyy/(2.*Delta);
    }







    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.y.i)] *= _const_fm.y;
  }}}}}} } };}}

  delete ((scalar *)((vector[]){du,{{-1},{-1}}}));
}
# 308 "/root/mnt/basilisk/src/navier-stokes/centered.h"
static int advection_term_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;} static int advection_term(const int i,const double t,Event *_ev){;
{
  if (!stokes) {
    prediction();
    mgpf = project ((struct Project){uf, pf, alpha, dt/2., mgpf.nrelax});
    advection ((struct Advection){(scalar *)((vector[]){u,{{-1},{-1}}}), uf, dt, (scalar *)((vector[]){g,{{-1},{-1}}})});
  }
}{;return 0;};}







static void correction (double dt)
{
  { static ForeachData _loop = { "/root/mnt/basilisk/src/navier-stokes/centered.h", 325, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 325 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
 0
# 325 "/root/mnt/basilisk/src/navier-stokes/centered.h"
 ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point);
    {
      {stencil_val_a (point, u.x, 0, 0, 0, 
# 327 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
      1
# 327 "/root/mnt/basilisk/src/navier-stokes/centered.h"
      , "/root/mnt/basilisk/src/navier-stokes/centered.h", 327);stencil_val (point, g.x, 0, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 327, 
# 327 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                0
# 327 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                ); }
# 327 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{stencil_val_a (point, u.y, 0, 0, 0, 
# 327 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
1
# 327 "/root/mnt/basilisk/src/navier-stokes/centered.h"
, "/root/mnt/basilisk/src/navier-stokes/centered.h", 327);stencil_val (point, g.y, 0, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 327, 
# 327 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                          0
# 327 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                          ); }}end_stencil (&_loop); _loop.first = 0;};
  {
# 325 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    {
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.x.i)] += dt*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(g.x.i)];
# 327 "/root/mnt/basilisk/src/navier-stokes/centered.h"
((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] += dt*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(g.y.i)];}} } };}
}
# 337 "/root/mnt/basilisk/src/navier-stokes/centered.h"
static int viscous_term_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;} static int viscous_term(const int i,const double t,Event *_ev){;
{
  if ((((mu.x).i >= 65536) ? _constant[(mu.x).i - 65536] : ((double)1e30)) != 0.) {
    correction (dt);
    mgu = viscosity ((struct Viscosity){u, mu, rho, dt, mgu.nrelax});
    correction (-dt);
  }




  if (!((a.x).i >= 65536)) {
    vector af = a;
    ;
    { static ForeachData _loop = { "/root/mnt/basilisk/src/navier-stokes/centered.h", 351, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 351 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
   0
# 351 "/root/mnt/basilisk/src/navier-stokes/centered.h"
   ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point);{{ _loop.face |= (1 << 0);{
      {stencil_val_a (point, af.x, 0, 0, 0, 
# 352 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
      0
# 352 "/root/mnt/basilisk/src/navier-stokes/centered.h"
      , "/root/mnt/basilisk/src/navier-stokes/centered.h", 352); }}}
# 351 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{ _loop.face |= (1 << 1);{
      {stencil_val_a (point, af.y, 0, 0, 0, 
# 352 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
      0
# 352 "/root/mnt/basilisk/src/navier-stokes/centered.h"
      , "/root/mnt/basilisk/src/navier-stokes/centered.h", 352); }}}}end_stencil (&_loop); _loop.first = 0;};
    {
# 351 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(af.x.i)] = 0.;}}}
# 351 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(af.y.i)] = 0.;}}}}} } };}
  }
}{;return 0;};}
# 373 "/root/mnt/basilisk/src/navier-stokes/centered.h"
static int acceleration_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;} static int acceleration(const int i,const double t,Event *_ev){;
{
  ;
  { static ForeachData _loop = { "/root/mnt/basilisk/src/navier-stokes/centered.h", 376, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 376 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
 0
# 376 "/root/mnt/basilisk/src/navier-stokes/centered.h"
 ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point);{{ _loop.face |= (1 << 0);{
    {stencil_val_a (point, uf.x, 0, 0, 0, 
# 377 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
    0
# 377 "/root/mnt/basilisk/src/navier-stokes/centered.h"
    , "/root/mnt/basilisk/src/navier-stokes/centered.h", 377); stencil_val (point, fm.x, 0, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 377, 
# 377 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                0
# 377 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                );stencil_val (point, u.x, 0, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 377, 
# 377 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                                         0
# 377 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                                         ); stencil_val (point, u.x, 0 -1, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 377, 
# 377 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                                                                  0
# 377 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                                                                  );stencil_val (point, a.x, 0, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 377, 
# 377 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                                                                                             0
# 377 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                                                                                             ); }}}
# 376 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{ _loop.face |= (1 << 1);{
    {stencil_val_a (point, uf.y, 0, 0, 0, 
# 377 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
    0
# 377 "/root/mnt/basilisk/src/navier-stokes/centered.h"
    , "/root/mnt/basilisk/src/navier-stokes/centered.h", 377); stencil_val (point, fm.y, 0, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 377, 
# 377 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                0
# 377 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                );stencil_val (point, u.y, 0, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 377, 
# 377 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                                         0
# 377 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                                         ); stencil_val (point, u.y, 0, 0 -1, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 377, 
# 377 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                                                                  0
# 377 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                                                                  );stencil_val (point, a.y, 0, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 377, 
# 377 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                                                                                             0
# 377 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                                                                                             ); }}}}end_stencil (&_loop); _loop.first = 0;};
# 376 "/root/mnt/basilisk/src/navier-stokes/centered.h"
if(!((fm.x).i >= 65536) && !((a.x).i >= 65536)){{{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.x.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)]*(((((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0 -1][point.j+0]) ) + sizeof(Cell)))[(u.x.i)])/2.) + dt*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(a.x.i)]);}}}
# 376 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.y.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)]*(((((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0 -1]) ) + sizeof(Cell)))[(u.y.i)])/2.) + dt*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(a.y.i)]);}}}}} } };}}else if(((fm.x).i >= 65536) && !((a.x).i >= 65536)){struct{double x,y;}_const_fm={_constant[fm.x.i-65536],_constant[fm.y.i-65536]};(void)(_const_fm);
  {
# 376 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.x.i)] = _const_fm.x*(((((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0 -1][point.j+0]) ) + sizeof(Cell)))[(u.x.i)])/2.) + dt*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(a.x.i)]);}}}
# 376 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.y.i)] = _const_fm.y*(((((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0 -1]) ) + sizeof(Cell)))[(u.y.i)])/2.) + dt*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(a.y.i)]);}}}}} } };}}else if(!((fm.x).i >= 65536) && ((a.x).i >= 65536)){struct{double x,y;}_const_a={_constant[a.x.i-65536],_constant[a.y.i-65536]};(void)(_const_a);
  {
# 376 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.x.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)]*(((((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0 -1][point.j+0]) ) + sizeof(Cell)))[(u.x.i)])/2.) + dt*_const_a.x);}}}
# 376 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.y.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)]*(((((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0 -1]) ) + sizeof(Cell)))[(u.y.i)])/2.) + dt*_const_a.y);}}}}} } };}}else {struct{double x,y;}_const_fm={_constant[fm.x.i-65536],_constant[fm.y.i-65536]};(void)(_const_fm);struct{double x,y;}_const_a={_constant[a.x.i-65536],_constant[a.y.i-65536]};(void)(_const_a);
  {
# 376 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.x.i)] = _const_fm.x*(((((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0 -1][point.j+0]) ) + sizeof(Cell)))[(u.x.i)])/2.) + dt*_const_a.x);}}}
# 376 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.y.i)] = _const_fm.y*(((((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0 -1]) ) + sizeof(Cell)))[(u.y.i)])/2.) + dt*_const_a.y);}}}}} } };}}
}{;return 0;};}
# 387 "/root/mnt/basilisk/src/navier-stokes/centered.h"
void centered_gradient (scalar p, vector g)
{





  vector gf=new_face_vector("gf");
  { static ForeachData _loop = { "/root/mnt/basilisk/src/navier-stokes/centered.h", 395, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 395 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
 0
# 395 "/root/mnt/basilisk/src/navier-stokes/centered.h"
 ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point);{{ _loop.face |= (1 << 0);{
    {stencil_val_a (point, gf.x, 0, 0, 0, 
# 396 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
    0
# 396 "/root/mnt/basilisk/src/navier-stokes/centered.h"
    , "/root/mnt/basilisk/src/navier-stokes/centered.h", 396); stencil_val (point, fm.x, 0, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 396, 
# 396 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                0
# 396 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                );stencil_val (point, a.x, 0, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 396, 
# 396 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                                         0
# 396 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                                         ); stencil_val (point, alpha.x, 0, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 396, 
# 396 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                                                                  0
# 396 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                                                                  );stencil_val (point, p, 0, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 396, 
# 396 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                                                                                              0
# 396 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                                                                                              ); stencil_val (point, p, -1, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 396, 
# 396 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                                                                                                                     0
# 396 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                                                                                                                     ); }}}
# 395 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{ _loop.face |= (1 << 1);{
    {stencil_val_a (point, gf.y, 0, 0, 0, 
# 396 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
    0
# 396 "/root/mnt/basilisk/src/navier-stokes/centered.h"
    , "/root/mnt/basilisk/src/navier-stokes/centered.h", 396); stencil_val (point, fm.y, 0, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 396, 
# 396 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                0
# 396 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                );stencil_val (point, a.y, 0, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 396, 
# 396 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                                         0
# 396 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                                         ); stencil_val (point, alpha.y, 0, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 396, 
# 396 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                                                                  0
# 396 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                                                                  );stencil_val (point, p, 0, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 396, 
# 396 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                                                                                              0
# 396 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                                                                                              ); stencil_val (point, p, 0, -1, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 396, 
# 396 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                                                                                                                     0
# 396 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                                                                                                                     ); }}}}end_stencil (&_loop); _loop.first = 0;};
# 395 "/root/mnt/basilisk/src/navier-stokes/centered.h"
if(!((fm.x).i >= 65536) && !((a.x).i >= 65536) && !((alpha.x).i >= 65536)){{{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(gf.x.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)]*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(a.x.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.x.i)]*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(p.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(p.i)])/Delta;}}}
# 395 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(gf.y.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)]*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(a.y.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.y.i)]*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(p.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(p.i)])/Delta;}}}}} } };}}else if(((fm.x).i >= 65536) && !((a.x).i >= 65536) && !((alpha.x).i >= 65536)){struct{double x,y;}_const_fm={_constant[fm.x.i-65536],_constant[fm.y.i-65536]};(void)(_const_fm);
  {
# 395 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(gf.x.i)] = _const_fm.x*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(a.x.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.x.i)]*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(p.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(p.i)])/Delta;}}}
# 395 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(gf.y.i)] = _const_fm.y*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(a.y.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.y.i)]*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(p.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(p.i)])/Delta;}}}}} } };}}else if(!((fm.x).i >= 65536) && ((a.x).i >= 65536) && !((alpha.x).i >= 65536)){struct{double x,y;}_const_a={_constant[a.x.i-65536],_constant[a.y.i-65536]};(void)(_const_a);
  {
# 395 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(gf.x.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)]*_const_a.x - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.x.i)]*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(p.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(p.i)])/Delta;}}}
# 395 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(gf.y.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)]*_const_a.y - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.y.i)]*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(p.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(p.i)])/Delta;}}}}} } };}}else if(((fm.x).i >= 65536) && ((a.x).i >= 65536) && !((alpha.x).i >= 65536)){struct{double x,y;}_const_fm={_constant[fm.x.i-65536],_constant[fm.y.i-65536]};(void)(_const_fm);struct{double x,y;}_const_a={_constant[a.x.i-65536],_constant[a.y.i-65536]};(void)(_const_a);
  {
# 395 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(gf.x.i)] = _const_fm.x*_const_a.x - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.x.i)]*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(p.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(p.i)])/Delta;}}}
# 395 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(gf.y.i)] = _const_fm.y*_const_a.y - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.y.i)]*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(p.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(p.i)])/Delta;}}}}} } };}}else if(!((fm.x).i >= 65536) && !((a.x).i >= 65536) && ((alpha.x).i >= 65536)){struct{double x,y;}_const_alpha={_constant[alpha.x.i-65536],_constant[alpha.y.i-65536]};(void)(_const_alpha);
  {
# 395 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(gf.x.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)]*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(a.x.i)] - _const_alpha.x*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(p.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(p.i)])/Delta;}}}
# 395 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(gf.y.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)]*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(a.y.i)] - _const_alpha.y*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(p.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(p.i)])/Delta;}}}}} } };}}else if(((fm.x).i >= 65536) && !((a.x).i >= 65536) && ((alpha.x).i >= 65536)){struct{double x,y;}_const_fm={_constant[fm.x.i-65536],_constant[fm.y.i-65536]};(void)(_const_fm);struct{double x,y;}_const_alpha={_constant[alpha.x.i-65536],_constant[alpha.y.i-65536]};(void)(_const_alpha);
  {
# 395 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(gf.x.i)] = _const_fm.x*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(a.x.i)] - _const_alpha.x*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(p.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(p.i)])/Delta;}}}
# 395 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(gf.y.i)] = _const_fm.y*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(a.y.i)] - _const_alpha.y*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(p.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(p.i)])/Delta;}}}}} } };}}else if(!((fm.x).i >= 65536) && ((a.x).i >= 65536) && ((alpha.x).i >= 65536)){struct{double x,y;}_const_a={_constant[a.x.i-65536],_constant[a.y.i-65536]};(void)(_const_a);struct{double x,y;}_const_alpha={_constant[alpha.x.i-65536],_constant[alpha.y.i-65536]};(void)(_const_alpha);
  {
# 395 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(gf.x.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)]*_const_a.x - _const_alpha.x*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(p.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(p.i)])/Delta;}}}
# 395 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(gf.y.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)]*_const_a.y - _const_alpha.y*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(p.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(p.i)])/Delta;}}}}} } };}}else {struct{double x,y;}_const_fm={_constant[fm.x.i-65536],_constant[fm.y.i-65536]};(void)(_const_fm);struct{double x,y;}_const_a={_constant[a.x.i-65536],_constant[a.y.i-65536]};(void)(_const_a);struct{double x,y;}_const_alpha={_constant[alpha.x.i-65536],_constant[alpha.y.i-65536]};(void)(_const_alpha);
  {
# 395 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(gf.x.i)] = _const_fm.x*_const_a.x - _const_alpha.x*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(p.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(p.i)])/Delta;}}}
# 395 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(gf.y.i)] = _const_fm.y*_const_a.y - _const_alpha.y*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(p.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(p.i)])/Delta;}}}}} } };}}





  ;
  { static ForeachData _loop = { "/root/mnt/basilisk/src/navier-stokes/centered.h", 403, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 403 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
 0
# 403 "/root/mnt/basilisk/src/navier-stokes/centered.h"
 ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point);
    {
      {stencil_val_a (point, g.x, 0, 0, 0, 
# 405 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
      0
# 405 "/root/mnt/basilisk/src/navier-stokes/centered.h"
      , "/root/mnt/basilisk/src/navier-stokes/centered.h", 405);stencil_val (point, gf.x, 0, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 405, 
# 405 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                0
# 405 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                ); stencil_val (point, gf.x, 1, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 405, 
# 405 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                                          0
# 405 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                                          );stencil_val (point, fm.x, 0, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 405, 
# 405 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                                                                   0
# 405 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                                                                   ); stencil_val (point, fm.x, 1, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 405, 
# 405 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                                                                                             0
# 405 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                                                                                             ); }
# 405 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{stencil_val_a (point, g.y, 0, 0, 0, 
# 405 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
0
# 405 "/root/mnt/basilisk/src/navier-stokes/centered.h"
, "/root/mnt/basilisk/src/navier-stokes/centered.h", 405);stencil_val (point, gf.y, 0, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 405, 
# 405 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                          0
# 405 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                          ); stencil_val (point, gf.y, 0, 1, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 405, 
# 405 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                                    0
# 405 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                                    );stencil_val (point, fm.y, 0, 0, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 405, 
# 405 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                                                             0
# 405 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                                                             ); stencil_val (point, fm.y, 0, 1, 0, "/root/mnt/basilisk/src/navier-stokes/centered.h", 405, 
# 405 "/root/mnt/basilisk/src/navier-stokes/centered.h" 3 4
                                                                                                       0
# 405 "/root/mnt/basilisk/src/navier-stokes/centered.h"
                                                                                                       ); }}end_stencil (&_loop); _loop.first = 0;};
# 403 "/root/mnt/basilisk/src/navier-stokes/centered.h"
if(!((fm.x).i >= 65536)){{{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    {
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(g.x.i)] = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(gf.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(gf.x.i)])/(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)] + 0.);
# 405 "/root/mnt/basilisk/src/navier-stokes/centered.h"
((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(g.y.i)] = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(gf.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(gf.y.i)])/(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(fm.y.i)] + 0.);}} } };}}else {struct{double x,y;}_const_fm={_constant[fm.x.i-65536],_constant[fm.y.i-65536]};(void)(_const_fm);
  {
# 403 "/root/mnt/basilisk/src/navier-stokes/centered.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    {
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(g.x.i)] = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(gf.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(gf.x.i)])/(_const_fm.x + _const_fm.x + 0.);
# 405 "/root/mnt/basilisk/src/navier-stokes/centered.h"
((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(g.y.i)] = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(gf.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(gf.y.i)])/(_const_fm.y + _const_fm.y + 0.);}} } };}}delete((scalar*)((vector[]){gf,{{-1},{-1}}}));
}






static int projection_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;} static int projection(const int i,const double t,Event *_ev){;
{
  mgp = project ((struct Project){uf, p, alpha, dt, mgp.nrelax});
  centered_gradient (p, g);




  correction (dt);
}{;return 0;};}





static int end_timestep_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;}static int end_timestep(const int i,const double t,Event *_ev){;return 0;}
# 438 "/root/mnt/basilisk/src/navier-stokes/centered.h"
static int adapt_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;} static int adapt(const int i,const double t,Event *_ev){; {






  event ("properties");
}{;return 0;};}
# 19 "rising.c"
# 1 "two-phase.h"
# 1 "/root/mnt/basilisk/src/two-phase.h"
# 13 "/root/mnt/basilisk/src/two-phase.h"
# 1 "vof.h"
# 1 "/root/mnt/basilisk/src/vof.h"
# 27 "/root/mnt/basilisk/src/vof.h"
# 1 "fractions.h"
# 1 "/root/mnt/basilisk/src/fractions.h"
# 12 "/root/mnt/basilisk/src/fractions.h"
# 1 "geometry.h"
# 1 "/root/mnt/basilisk/src/geometry.h"
# 28 "/root/mnt/basilisk/src/geometry.h"
double line_alpha (double c, coord n)
{
  double alpha, n1, n2;

  n1 = fabs (n.x); n2 = fabs (n.y);
  if (n1 > n2)
    do { double __tmp = n1; n1 = n2; n2 = __tmp; } while(0);

  c = ((c) < (0.) ? (0.) : (c) > (1.) ? (1.) : (c));
  double v1 = n1/2.;
  if (c <= v1/n2)
    alpha = sqrt (2.*c*n1*n2);
  else if (c <= 1. - v1/n2)
    alpha = c*n2 + v1;
  else
    alpha = n1 + n2 - sqrt (2.*n1*n2*(1. - c));

  if (n.x < 0.)
    alpha += n.x;
  if (n.y < 0.)
    alpha += n.y;

  return alpha - (n.x + n.y)/2.;
}
# 133 "/root/mnt/basilisk/src/geometry.h"
double line_area (double nx, double ny, double alpha)
{
  double a, v, area;

  alpha += (nx + ny)/2.;
  if (nx < 0.) {
    alpha -= nx;
    nx = - nx;
  }
  if (ny < 0.) {
    alpha -= ny;
    ny = - ny;
  }

  if (alpha <= 0.)
    return 0.;

  if (alpha >= nx + ny)
    return 1.;

  if (nx < 1e-10)
    area = alpha/ny;
  else if (ny < 1e-10)
    area = alpha/nx;
  else {
    v = ((alpha)*(alpha));

    a = alpha - nx;
    if (a > 0.)
      v -= a*a;

    a = alpha - ny;
    if (a > 0.)
      v -= a*a;

    area = v/(2.*nx*ny);
  }

  return ((area) < (0.) ? (0.) : (area) > (1.) ? (1.) : (area));
}
# 237 "/root/mnt/basilisk/src/geometry.h"
double rectangle_fraction (coord n, double alpha, coord a, coord b)
{
  coord n1;
   {
    alpha -= n.x*(b.x + a.x)/2.;
    n1.x = n.x*(b.x - a.x);
  }
# 240 "/root/mnt/basilisk/src/geometry.h"
{
    alpha -= n.y*(b.y + a.y)/2.;
    n1.y = n.y*(b.y - a.y);
  }
  return line_area(n1.x, n1.y, alpha);
}
# 262 "/root/mnt/basilisk/src/geometry.h"
int facets (coord n, double alpha, coord p[2])
{
  int i = 0;
  for (double s = -0.5; s <= 0.5; s += 1.)
    {
      if (fabs (n.y) > 1e-4 && i < 2) {
 double a = (alpha - s*n.x)/n.y;
 if (a >= -0.5 && a <= 0.5) {
   p[i].x = s;
   p[i++].y = a;
 }
      }
# 267 "/root/mnt/basilisk/src/geometry.h"
if (fabs (n.x) > 1e-4 && i < 2) {
 double a = (alpha - s*n.y)/n.x;
 if (a >= -0.5 && a <= 0.5) {
   p[i].y = s;
   p[i++].x = a;
 }
      }}
  return i;
}
# 352 "/root/mnt/basilisk/src/geometry.h"
double line_length_center (coord m, double alpha, coord * p)
{
  alpha += (m.x + m.y)/2.;

  coord n = m;

    if (n.x < 0.) {
      alpha -= n.x;
      n.x = - n.x;
    }
# 358 "/root/mnt/basilisk/src/geometry.h"
if (n.y < 0.) {
      alpha -= n.y;
      n.y = - n.y;
    }

  p->x = p->y = p->z = 0.;

  if (alpha <= 0. || alpha >= n.x + n.y)
    return 0.;


    if (n.x < 1e-4) {
      p->x = 0.;
      p->y = (m.y < 0. ? 1. - alpha : alpha) - 0.5;
      return 1.;
    }
# 369 "/root/mnt/basilisk/src/geometry.h"
if (n.y < 1e-4) {
      p->y = 0.;
      p->x = (m.x < 0. ? 1. - alpha : alpha) - 0.5;
      return 1.;
    }

  if (alpha >= n.x) {
    p->x += 1.;
    p->y += (alpha - n.x)/n.y;
  }
  else
    p->x += alpha/n.x;

  double ax = p->x, ay = p->y;
  if (alpha >= n.y) {
    p->y += 1.;
    ay -= 1.;
    p->x += (alpha - n.y)/n.x;
    ax -= (alpha - n.y)/n.x;
  }
  else {
    p->y += alpha/n.y;
    ay -= alpha/n.y;
  }

   {
    p->x /= 2.;
    p->x = ((p->x) < (0.) ? (0.) : (p->x) > (1.) ? (1.) : (p->x));
    if (m.x < 0.)
      p->x = 1. - p->x;
    p->x -= 0.5;
  }
# 394 "/root/mnt/basilisk/src/geometry.h"
{
    p->y /= 2.;
    p->y = ((p->y) < (0.) ? (0.) : (p->y) > (1.) ? (1.) : (p->y));
    if (m.y < 0.)
      p->y = 1. - p->y;
    p->y -= 0.5;
  }

  return sqrt (ax*ax + ay*ay);
}
# 482 "/root/mnt/basilisk/src/geometry.h"
void line_center (coord m, double alpha, double a, coord * p)
{
  alpha += (m.x + m.y)/2.;

  coord n = m;

    if (n.x < 0.) {
      alpha -= n.x;
      n.x = - n.x;
    }
# 488 "/root/mnt/basilisk/src/geometry.h"
if (n.y < 0.) {
      alpha -= n.y;
      n.y = - n.y;
    }

  p->z = 0.;
  if (alpha <= 0.) {
    p->x = p->y = -0.5;
    return;
  }

  if (alpha >= n.x + n.y) {
    p->x = p->y = 0.;
    return;
  }


    if (n.x < 1e-4) {
      p->x = 0.;
      p->y = ((m.y) > 0 ? 1 : -1)*(a/2. - 0.5);
      return;
    }
# 505 "/root/mnt/basilisk/src/geometry.h"
if (n.y < 1e-4) {
      p->y = 0.;
      p->x = ((m.x) > 0 ? 1 : -1)*(a/2. - 0.5);
      return;
    }

  p->x = p->y = ((alpha)*(alpha)*(alpha));

   {
    double b = alpha - n.x;
    if (b > 0.) {
      p->x -= ((b)*(b))*(alpha + 2.*n.x);
      p->y -= ((b)*(b)*(b));
    }
  }
# 513 "/root/mnt/basilisk/src/geometry.h"
{
    double b = alpha - n.y;
    if (b > 0.) {
      p->y -= ((b)*(b))*(alpha + 2.*n.y);
      p->x -= ((b)*(b)*(b));
    }
  }

   {
    p->x /= 6.*((n.x)*(n.x))*n.y*a;
    p->x = ((m.x) > 0 ? 1 : -1)*(p->x - 0.5);
  }
# 521 "/root/mnt/basilisk/src/geometry.h"
{
    p->y /= 6.*((n.y)*(n.y))*n.x*a;
    p->y = ((m.y) > 0 ? 1 : -1)*(p->y - 0.5);
  }
}
# 13 "/root/mnt/basilisk/src/fractions.h"
# 1 "myc2d.h"
# 1 "/root/mnt/basilisk/src/myc2d.h"





coord mycs (Point point, scalar c)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  int ix;
  double c_t,c_b,c_r,c_l;
  double mx0,my0,mx1,my1,mm1,mm2;


  c_t = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+1]) ) + sizeof(Cell)))[(c.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(c.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+1]) ) + sizeof(Cell)))[(c.i)];
  c_b = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+-1]) ) + sizeof(Cell)))[(c.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(c.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+-1]) ) + sizeof(Cell)))[(c.i)];
  c_r = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+-1]) ) + sizeof(Cell)))[(c.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(c.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+1]) ) + sizeof(Cell)))[(c.i)];
  c_l = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+-1]) ) + sizeof(Cell)))[(c.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(c.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+1]) ) + sizeof(Cell)))[(c.i)];



  mx0 = 0.5*(c_l-c_r);
  my0 = 0.5*(c_b-c_t);


  if (fabs(mx0) <= fabs(my0)) {
    my0 = my0 > 0. ? 1. : -1.;
    ix = 1;
  }
  else {
    mx0 = mx0 > 0. ? 1. : -1.;
    ix = 0;
  }


  mm1 = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+-1]) ) + sizeof(Cell)))[(c.i)] + 2.0*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(c.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+1]) ) + sizeof(Cell)))[(c.i)];
  mm2 = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+-1]) ) + sizeof(Cell)))[(c.i)] + 2.0*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(c.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+1]) ) + sizeof(Cell)))[(c.i)];
  mx1 = mm1 - mm2 + 1.e-30;
  mm1 = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+-1]) ) + sizeof(Cell)))[(c.i)] + 2.0*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(c.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+-1]) ) + sizeof(Cell)))[(c.i)];
  mm2 = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+1]) ) + sizeof(Cell)))[(c.i)] + 2.0*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(c.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+1]) ) + sizeof(Cell)))[(c.i)];
  my1 = mm1 - mm2 + 1.e-30;


  if (ix) {
    mm1 = fabs(my1);
    mm1 = fabs(mx1)/mm1;
    if (mm1 > fabs(mx0)) {
      mx0 = mx1;
      my0 = my1;
    }
  }
  else {
    mm1 = fabs(mx1);
    mm1 = fabs(my1)/mm1;
    if (mm1 > fabs(my0)) {
      mx0 = mx1;
      my0 = my1;
    }
  }



  mm1 = fabs(mx0) + fabs(my0);
  coord n = {mx0/mm1, my0/mm1};

  return n;
}
# 13 "/root/mnt/basilisk/src/fractions.h"
# 1 "myc2d.h"
# 1 "/root/mnt/basilisk/src/myc2d.h"





static void _stencil_mycs (Point point, scalar c)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;





stencil_val (point, c, -1, 1, 0, "/root/mnt/basilisk/src/myc2d.h", 13, 
# 13 "/root/mnt/basilisk/src/myc2d.h" 3 4
0
# 13 "/root/mnt/basilisk/src/myc2d.h"
); stencil_val (point, c, 0, 1, 0, "/root/mnt/basilisk/src/myc2d.h", 13, 
# 13 "/root/mnt/basilisk/src/myc2d.h" 3 4
                       0
# 13 "/root/mnt/basilisk/src/myc2d.h"
                       ); stencil_val (point, c, 1, 1, 0, "/root/mnt/basilisk/src/myc2d.h", 13, 
# 13 "/root/mnt/basilisk/src/myc2d.h" 3 4
                                              0
# 13 "/root/mnt/basilisk/src/myc2d.h"
                                              );
# 14 "/root/mnt/basilisk/src/myc2d.h"
stencil_val (point, c, -1, -1, 0, "/root/mnt/basilisk/src/myc2d.h", 14, 
# 14 "/root/mnt/basilisk/src/myc2d.h" 3 4
0
# 14 "/root/mnt/basilisk/src/myc2d.h"
); stencil_val (point, c, 0, -1, 0, "/root/mnt/basilisk/src/myc2d.h", 14, 
# 14 "/root/mnt/basilisk/src/myc2d.h" 3 4
                        0
# 14 "/root/mnt/basilisk/src/myc2d.h"
                        ); stencil_val (point, c, 1, -1, 0, "/root/mnt/basilisk/src/myc2d.h", 14, 
# 14 "/root/mnt/basilisk/src/myc2d.h" 3 4
                                                0
# 14 "/root/mnt/basilisk/src/myc2d.h"
                                                );
     stencil_val (point, c, 1, -1, 0, "/root/mnt/basilisk/src/myc2d.h", 15, 
# 15 "/root/mnt/basilisk/src/myc2d.h" 3 4
    0
# 15 "/root/mnt/basilisk/src/myc2d.h"
    ); stencil_val (point, c, 1, 0, 0, "/root/mnt/basilisk/src/myc2d.h", 15, 
# 15 "/root/mnt/basilisk/src/myc2d.h" 3 4
                            0
# 15 "/root/mnt/basilisk/src/myc2d.h"
                            ); stencil_val (point, c, 1, 1, 0, "/root/mnt/basilisk/src/myc2d.h", 15, 
# 15 "/root/mnt/basilisk/src/myc2d.h" 3 4
                                                   0
# 15 "/root/mnt/basilisk/src/myc2d.h"
                                                   );
     stencil_val (point, c, -1, -1, 0, "/root/mnt/basilisk/src/myc2d.h", 16, 
# 16 "/root/mnt/basilisk/src/myc2d.h" 3 4
    0
# 16 "/root/mnt/basilisk/src/myc2d.h"
    ); stencil_val (point, c, -1, 0, 0, "/root/mnt/basilisk/src/myc2d.h", 16, 
# 16 "/root/mnt/basilisk/src/myc2d.h" 3 4
                             0
# 16 "/root/mnt/basilisk/src/myc2d.h"
                             ); stencil_val (point, c, -1, 1, 0, "/root/mnt/basilisk/src/myc2d.h", 16, 
# 16 "/root/mnt/basilisk/src/myc2d.h" 3 4
                                                     0
# 16 "/root/mnt/basilisk/src/myc2d.h"
                                                     );
# 34 "/root/mnt/basilisk/src/myc2d.h"
stencil_val (point, c, -1, -1, 0, "/root/mnt/basilisk/src/myc2d.h", 34, 
# 34 "/root/mnt/basilisk/src/myc2d.h" 3 4
0
# 34 "/root/mnt/basilisk/src/myc2d.h"
);stencil_val (point, c, -1, 0, 0, "/root/mnt/basilisk/src/myc2d.h", 34, 
# 34 "/root/mnt/basilisk/src/myc2d.h" 3 4
                       0
# 34 "/root/mnt/basilisk/src/myc2d.h"
                       ); stencil_val (point, c, -1, 1, 0, "/root/mnt/basilisk/src/myc2d.h", 34, 
# 34 "/root/mnt/basilisk/src/myc2d.h" 3 4
                                               0
# 34 "/root/mnt/basilisk/src/myc2d.h"
                                               );
# 35 "/root/mnt/basilisk/src/myc2d.h"
stencil_val (point, c, 1, -1, 0, "/root/mnt/basilisk/src/myc2d.h", 35, 
# 35 "/root/mnt/basilisk/src/myc2d.h" 3 4
0
# 35 "/root/mnt/basilisk/src/myc2d.h"
);stencil_val (point, c, 1, 0, 0, "/root/mnt/basilisk/src/myc2d.h", 35, 
# 35 "/root/mnt/basilisk/src/myc2d.h" 3 4
                      0
# 35 "/root/mnt/basilisk/src/myc2d.h"
                      ); stencil_val (point, c, 1, 1, 0, "/root/mnt/basilisk/src/myc2d.h", 35, 
# 35 "/root/mnt/basilisk/src/myc2d.h" 3 4
                                             0
# 35 "/root/mnt/basilisk/src/myc2d.h"
                                             );

        stencil_val (point, c, -1, -1, 0, "/root/mnt/basilisk/src/myc2d.h", 37, 
# 37 "/root/mnt/basilisk/src/myc2d.h" 3 4
       0
# 37 "/root/mnt/basilisk/src/myc2d.h"
       );stencil_val (point, c, 0, -1, 0, "/root/mnt/basilisk/src/myc2d.h", 37, 
# 37 "/root/mnt/basilisk/src/myc2d.h" 3 4
                               0
# 37 "/root/mnt/basilisk/src/myc2d.h"
                               ); stencil_val (point, c, 1, -1, 0, "/root/mnt/basilisk/src/myc2d.h", 37, 
# 37 "/root/mnt/basilisk/src/myc2d.h" 3 4
                                                       0
# 37 "/root/mnt/basilisk/src/myc2d.h"
                                                       );
       stencil_val (point, c, -1, 1, 0, "/root/mnt/basilisk/src/myc2d.h", 38, 
# 38 "/root/mnt/basilisk/src/myc2d.h" 3 4
      0
# 38 "/root/mnt/basilisk/src/myc2d.h"
      );stencil_val (point, c, 0, 1, 0, "/root/mnt/basilisk/src/myc2d.h", 38, 
# 38 "/root/mnt/basilisk/src/myc2d.h" 3 4
                             0
# 38 "/root/mnt/basilisk/src/myc2d.h"
                             ); stencil_val (point, c, 1, 1, 0, "/root/mnt/basilisk/src/myc2d.h", 38, 
# 38 "/root/mnt/basilisk/src/myc2d.h" 3 4
                                                    0
# 38 "/root/mnt/basilisk/src/myc2d.h"
                                                    );
# 64 "/root/mnt/basilisk/src/myc2d.h"
return ;
}
# 20 "/root/mnt/basilisk/src/fractions.h"
# 41 "/root/mnt/basilisk/src/fractions.h"
void fraction_refine (Point point, scalar c)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;





  double cc = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(c.i)];
  if (cc <= 0. || cc >= 1.)
    {{ int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(c.i)] = cc;} } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}}
  else {




    coord n = mycs (point, c);
    double alpha = line_alpha (cc, n);






    {{ int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
      static const coord a = {0.,0.,0.}, b = {.5,.5,.5};
      coord nc;

 nc.x = child.x*n.x;
# 69 "/root/mnt/basilisk/src/fractions.h"
nc.y = child.y*n.y;
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(c.i)] = rectangle_fraction (nc, alpha, a, b);
    }} } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}}
  }
}
# 85 "/root/mnt/basilisk/src/fractions.h"
static void alpha_refine (Point point, scalar alpha)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  vector n = _attribute[alpha.i].n;
  double alphac = 2.*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.i)];
  coord m;

    m.x = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(n.x.i)];
# 91 "/root/mnt/basilisk/src/fractions.h"
m.y = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(n.y.i)];
  {{ int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.i)] = alphac;

      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.i)] -= child.x*m.x/2.;
# 95 "/root/mnt/basilisk/src/fractions.h"
((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.i)] -= child.y*m.y/2.;
  }} } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}}
}
# 121 "/root/mnt/basilisk/src/fractions.h"
struct Fractions {
  scalar Phi;
  scalar c;
  vector s;
  double val;
};


void fractions (struct Fractions a)
{;
  scalar Phi = a.Phi;
  scalar c = a.c;
  vector s=(a.s).x.i?(a.s):new_face_vector("s");
  double val = a.val;
# 145 "/root/mnt/basilisk/src/fractions.h"
  vector p;
  p.x = s.y; p.y = s.x;
# 155 "/root/mnt/basilisk/src/fractions.h"
  { static ForeachData _loop = { "/root/mnt/basilisk/src/fractions.h", 155, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 155 "/root/mnt/basilisk/src/fractions.h" 3 4
 0
# 155 "/root/mnt/basilisk/src/fractions.h"
 ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point);{{ _loop.face |= (1 << 1);{ {





stencil_val (point, Phi, 0, 0, 0, "/root/mnt/basilisk/src/fractions.h", 161, 
# 161 "/root/mnt/basilisk/src/fractions.h" 3 4
0
# 161 "/root/mnt/basilisk/src/fractions.h"
);stencil_val (point, Phi, 1, 0, 0, "/root/mnt/basilisk/src/fractions.h", 161, 
# 161 "/root/mnt/basilisk/src/fractions.h" 3 4
                       0
# 161 "/root/mnt/basilisk/src/fractions.h"
                       );{ {






      stencil_val_a (point, p.x, 0, 0, 0, 
# 168 "/root/mnt/basilisk/src/fractions.h" 3 4
     0
# 168 "/root/mnt/basilisk/src/fractions.h"
     , "/root/mnt/basilisk/src/fractions.h", 168);stencil_val (point, Phi, 0, 0, 0, "/root/mnt/basilisk/src/fractions.h", 168, 
# 168 "/root/mnt/basilisk/src/fractions.h" 3 4
                               0
# 168 "/root/mnt/basilisk/src/fractions.h"
                               );stencil_val (point, Phi, 0, 0, 0, "/root/mnt/basilisk/src/fractions.h", 168, 
# 168 "/root/mnt/basilisk/src/fractions.h" 3 4
                                                       0
# 168 "/root/mnt/basilisk/src/fractions.h"
                                                       ); stencil_val (point, Phi, 1, 0, 0, "/root/mnt/basilisk/src/fractions.h", 168, 
# 168 "/root/mnt/basilisk/src/fractions.h" 3 4
                                                                                0
# 168 "/root/mnt/basilisk/src/fractions.h"
                                                                                );
stencil_val (point, Phi, 0, 0, 0, "/root/mnt/basilisk/src/fractions.h", 169, 
# 169 "/root/mnt/basilisk/src/fractions.h" 3 4
0
# 169 "/root/mnt/basilisk/src/fractions.h"
);
 {stencil_val_a (point, p.x, 0, 0, 0, 
# 170 "/root/mnt/basilisk/src/fractions.h" 3 4
 0
# 170 "/root/mnt/basilisk/src/fractions.h"
 , "/root/mnt/basilisk/src/fractions.h", 170); stencil_val (point, p.x, 0, 0, 0, "/root/mnt/basilisk/src/fractions.h", 170, 
# 170 "/root/mnt/basilisk/src/fractions.h" 3 4
                            0
# 170 "/root/mnt/basilisk/src/fractions.h"
                            ); }
# 171 "/root/mnt/basilisk/src/fractions.h"
}
# 181 "/root/mnt/basilisk/src/fractions.h"
{stencil_val_a (point, p.x, 0, 0, 0, 
# 181 "/root/mnt/basilisk/src/fractions.h" 3 4
0
# 181 "/root/mnt/basilisk/src/fractions.h"
, "/root/mnt/basilisk/src/fractions.h", 181);stencil_val (point, Phi, 0, 0, 0, "/root/mnt/basilisk/src/fractions.h", 181, 
# 181 "/root/mnt/basilisk/src/fractions.h" 3 4
                          0
# 181 "/root/mnt/basilisk/src/fractions.h"
                          ); stencil_val (point, Phi, 1, 0, 0, "/root/mnt/basilisk/src/fractions.h", 181, 
# 181 "/root/mnt/basilisk/src/fractions.h" 3 4
                                                   0
# 181 "/root/mnt/basilisk/src/fractions.h"
                                                   ); }}
# 180 "/root/mnt/basilisk/src/fractions.h"


}}}
# 155 "/root/mnt/basilisk/src/fractions.h"
{ _loop.face |= (1 << 0);{ {





stencil_val (point, Phi, 0, 0, 0, "/root/mnt/basilisk/src/fractions.h", 161, 
# 161 "/root/mnt/basilisk/src/fractions.h" 3 4
0
# 161 "/root/mnt/basilisk/src/fractions.h"
);stencil_val (point, Phi, 0, 1, 0, "/root/mnt/basilisk/src/fractions.h", 161, 
# 161 "/root/mnt/basilisk/src/fractions.h" 3 4
                       0
# 161 "/root/mnt/basilisk/src/fractions.h"
                       );{ {






      stencil_val_a (point, p.y, 0, 0, 0, 
# 168 "/root/mnt/basilisk/src/fractions.h" 3 4
     0
# 168 "/root/mnt/basilisk/src/fractions.h"
     , "/root/mnt/basilisk/src/fractions.h", 168);stencil_val (point, Phi, 0, 0, 0, "/root/mnt/basilisk/src/fractions.h", 168, 
# 168 "/root/mnt/basilisk/src/fractions.h" 3 4
                               0
# 168 "/root/mnt/basilisk/src/fractions.h"
                               );stencil_val (point, Phi, 0, 0, 0, "/root/mnt/basilisk/src/fractions.h", 168, 
# 168 "/root/mnt/basilisk/src/fractions.h" 3 4
                                                       0
# 168 "/root/mnt/basilisk/src/fractions.h"
                                                       ); stencil_val (point, Phi, 0, 1, 0, "/root/mnt/basilisk/src/fractions.h", 168, 
# 168 "/root/mnt/basilisk/src/fractions.h" 3 4
                                                                                0
# 168 "/root/mnt/basilisk/src/fractions.h"
                                                                                );
stencil_val (point, Phi, 0, 0, 0, "/root/mnt/basilisk/src/fractions.h", 169, 
# 169 "/root/mnt/basilisk/src/fractions.h" 3 4
0
# 169 "/root/mnt/basilisk/src/fractions.h"
);
 {stencil_val_a (point, p.y, 0, 0, 0, 
# 170 "/root/mnt/basilisk/src/fractions.h" 3 4
 0
# 170 "/root/mnt/basilisk/src/fractions.h"
 , "/root/mnt/basilisk/src/fractions.h", 170); stencil_val (point, p.y, 0, 0, 0, "/root/mnt/basilisk/src/fractions.h", 170, 
# 170 "/root/mnt/basilisk/src/fractions.h" 3 4
                            0
# 170 "/root/mnt/basilisk/src/fractions.h"
                            ); }
# 171 "/root/mnt/basilisk/src/fractions.h"
}
# 181 "/root/mnt/basilisk/src/fractions.h"
{stencil_val_a (point, p.y, 0, 0, 0, 
# 181 "/root/mnt/basilisk/src/fractions.h" 3 4
0
# 181 "/root/mnt/basilisk/src/fractions.h"
, "/root/mnt/basilisk/src/fractions.h", 181);stencil_val (point, Phi, 0, 0, 0, "/root/mnt/basilisk/src/fractions.h", 181, 
# 181 "/root/mnt/basilisk/src/fractions.h" 3 4
                          0
# 181 "/root/mnt/basilisk/src/fractions.h"
                          ); stencil_val (point, Phi, 0, 1, 0, "/root/mnt/basilisk/src/fractions.h", 181, 
# 181 "/root/mnt/basilisk/src/fractions.h" 3 4
                                                   0
# 181 "/root/mnt/basilisk/src/fractions.h"
                                                   ); }}
# 180 "/root/mnt/basilisk/src/fractions.h"


}}}}end_stencil (&_loop); _loop.first = 0;};
# 155 "/root/mnt/basilisk/src/fractions.h"
  {{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{ {





    if ((((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(Phi.i)] - val)*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(Phi.i)] - val) < 0.) {






      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(p.x.i)] = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(Phi.i)] - val)/(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(Phi.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(Phi.i)]);
      if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(Phi.i)] < val)
 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(p.x.i)] = 1. - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(p.x.i)];
    }
# 180 "/root/mnt/basilisk/src/fractions.h"
    else
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(p.x.i)] = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(Phi.i)] > val || ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(Phi.i)] > val);
  }}}}
# 155 "/root/mnt/basilisk/src/fractions.h"
{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{ {





    if ((((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(Phi.i)] - val)*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(Phi.i)] - val) < 0.) {






      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(p.y.i)] = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(Phi.i)] - val)/(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(Phi.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(Phi.i)]);
      if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(Phi.i)] < val)
 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(p.y.i)] = 1. - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(p.y.i)];
    }
# 180 "/root/mnt/basilisk/src/fractions.h"
    else
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(p.y.i)] = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(Phi.i)] > val || ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(Phi.i)] > val);
  }}}}}} } };}
# 205 "/root/mnt/basilisk/src/fractions.h"
  scalar s_z = c;
  { static ForeachData _loop = { "/root/mnt/basilisk/src/fractions.h", 206, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 206 "/root/mnt/basilisk/src/fractions.h" 3 4
 0
# 206 "/root/mnt/basilisk/src/fractions.h"
 ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point);

  {
# 240 "/root/mnt/basilisk/src/fractions.h"


     {
stencil_val (point, p.y, 0, 0, 0, "/root/mnt/basilisk/src/fractions.h", 243, 
# 243 "/root/mnt/basilisk/src/fractions.h" 3 4
0
# 243 "/root/mnt/basilisk/src/fractions.h"
); stencil_val (point, p.y, 1, 0, 0, "/root/mnt/basilisk/src/fractions.h", 243, 
# 243 "/root/mnt/basilisk/src/fractions.h" 3 4
                        0
# 243 "/root/mnt/basilisk/src/fractions.h"
                        );
# 245 "/root/mnt/basilisk/src/fractions.h"
}
# 242 "/root/mnt/basilisk/src/fractions.h"
{
stencil_val (point, p.x, 0, 0, 0, "/root/mnt/basilisk/src/fractions.h", 243, 
# 243 "/root/mnt/basilisk/src/fractions.h" 3 4
0
# 243 "/root/mnt/basilisk/src/fractions.h"
); stencil_val (point, p.x, 0, 1, 0, "/root/mnt/basilisk/src/fractions.h", 243, 
# 243 "/root/mnt/basilisk/src/fractions.h" 3 4
                        0
# 243 "/root/mnt/basilisk/src/fractions.h"
                        );
# 245 "/root/mnt/basilisk/src/fractions.h"
}





{
      {stencil_val_a (point, s_z, 0, 0, 0, 
# 252 "/root/mnt/basilisk/src/fractions.h" 3 4
      0
# 252 "/root/mnt/basilisk/src/fractions.h"
      , "/root/mnt/basilisk/src/fractions.h", 252); stencil_val (point, p.x, 0, 0, 0, "/root/mnt/basilisk/src/fractions.h", 252, 
# 252 "/root/mnt/basilisk/src/fractions.h" 3 4
                                 0
# 252 "/root/mnt/basilisk/src/fractions.h"
                                 ); }
{
# 268 "/root/mnt/basilisk/src/fractions.h"
      for (int i = 0; i <= 1; i++)
 {
   {stencil_val (point, p.x, 0, i, 0, "/root/mnt/basilisk/src/fractions.h", 270, 
# 270 "/root/mnt/basilisk/src/fractions.h" 3 4
   0
# 270 "/root/mnt/basilisk/src/fractions.h"
   ); stencil_val (point, p.x, 0, i, 0, "/root/mnt/basilisk/src/fractions.h", 270, 
# 270 "/root/mnt/basilisk/src/fractions.h" 3 4
                            0
# 270 "/root/mnt/basilisk/src/fractions.h"
                            ); {
     stencil_val (point, p.x, 0, i, 0, "/root/mnt/basilisk/src/fractions.h", 271, 
# 271 "/root/mnt/basilisk/src/fractions.h" 3 4
    0
# 271 "/root/mnt/basilisk/src/fractions.h"
    );stencil_val (point, Phi, 0, i, 0, "/root/mnt/basilisk/src/fractions.h", 271, 
# 271 "/root/mnt/basilisk/src/fractions.h" 3 4
                            0
# 271 "/root/mnt/basilisk/src/fractions.h"
                            );


   } }
# 270 "/root/mnt/basilisk/src/fractions.h"
{stencil_val (point, p.y, i, 0, 0, "/root/mnt/basilisk/src/fractions.h", 270, 
# 270 "/root/mnt/basilisk/src/fractions.h" 3 4
0
# 270 "/root/mnt/basilisk/src/fractions.h"
); stencil_val (point, p.y, i, 0, 0, "/root/mnt/basilisk/src/fractions.h", 270, 
# 270 "/root/mnt/basilisk/src/fractions.h" 3 4
                         0
# 270 "/root/mnt/basilisk/src/fractions.h"
                         ); {
     stencil_val (point, p.y, i, 0, 0, "/root/mnt/basilisk/src/fractions.h", 271, 
# 271 "/root/mnt/basilisk/src/fractions.h" 3 4
    0
# 271 "/root/mnt/basilisk/src/fractions.h"
    );stencil_val (point, Phi, i, 0, 0, "/root/mnt/basilisk/src/fractions.h", 271, 
# 271 "/root/mnt/basilisk/src/fractions.h" 3 4
                            0
# 271 "/root/mnt/basilisk/src/fractions.h"
                            );


   } }}
# 283 "/root/mnt/basilisk/src/fractions.h"
{
 {stencil_val_a (point, s_z, 0, 0, 0, 
# 284 "/root/mnt/basilisk/src/fractions.h" 3 4
 0
# 284 "/root/mnt/basilisk/src/fractions.h"
 , "/root/mnt/basilisk/src/fractions.h", 284);stencil_val (point, p.x, 0, 0, 0, "/root/mnt/basilisk/src/fractions.h", 284, 
# 284 "/root/mnt/basilisk/src/fractions.h" 3 4
                           0
# 284 "/root/mnt/basilisk/src/fractions.h"
                           ); stencil_val (point, p.y, 0, 0, 0, "/root/mnt/basilisk/src/fractions.h", 284, 
# 284 "/root/mnt/basilisk/src/fractions.h" 3 4
                                                    0
# 284 "/root/mnt/basilisk/src/fractions.h"
                                                    ); }
{
 {stencil_val_a (point, s_z, 0, 0, 0, 
# 286 "/root/mnt/basilisk/src/fractions.h" 3 4
 0
# 286 "/root/mnt/basilisk/src/fractions.h"
 , "/root/mnt/basilisk/src/fractions.h", 286); }
{



 stencil_val_a (point, s_z, 0, 0, 0, 
# 291 "/root/mnt/basilisk/src/fractions.h" 3 4
0
# 291 "/root/mnt/basilisk/src/fractions.h"
, "/root/mnt/basilisk/src/fractions.h", 291);

      }}}
# 283 "/root/mnt/basilisk/src/fractions.h"
# 294 "/root/mnt/basilisk/src/fractions.h"
}}
# 295 "/root/mnt/basilisk/src/fractions.h"
}end_stencil (&_loop); _loop.first = 0;};
  {
# 206 "/root/mnt/basilisk/src/fractions.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;

  {
# 240 "/root/mnt/basilisk/src/fractions.h"
    coord n;
    double nn = 0.;
     {
      n.x = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(p.y.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(p.y.i)];
      nn += fabs(n.x);
    }
# 242 "/root/mnt/basilisk/src/fractions.h"
{
      n.y = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(p.x.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(p.x.i)];
      nn += fabs(n.y);
    }





    if (nn == 0.)
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s_z.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(p.x.i)];
    else {






 n.x /= nn;
# 260 "/root/mnt/basilisk/src/fractions.h"
n.y /= nn;






      double alpha = 0., ni = 0.;
      for (int i = 0; i <= 1; i++)
 {
   if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(p.x.i)] > 0. && ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(p.x.i)] < 1.) {
     double a = ((((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(Phi.i)] - val) > 0 ? 1 : -1)*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(p.x.i)] - 0.5);
     alpha += n.x*a + n.y*(i - 0.5);
     ni++;
   }
# 270 "/root/mnt/basilisk/src/fractions.h"
if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(p.y.i)] > 0. && ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(p.y.i)] < 1.) {
     double a = ((((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(Phi.i)] - val) > 0 ? 1 : -1)*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(p.y.i)] - 0.5);
     alpha += n.y*a + n.x*(i - 0.5);
     ni++;
   }}
# 283 "/root/mnt/basilisk/src/fractions.h"
      if (ni == 0)
 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s_z.i)] = ((((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(p.x.i)]) > (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(p.y.i)]) ? (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(p.x.i)]) : (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(p.y.i)]));
      else if (ni != 4)
 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s_z.i)] = line_area (n.x, n.y, alpha/ni);
      else {



 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s_z.i)] = 0.;

      }
    }
  }} } };}if(!(a.s).x.i)delete((scalar*)((vector[]){s,{{-1},{-1}}}));
# 347 "/root/mnt/basilisk/src/fractions.h"
;}
# 391 "/root/mnt/basilisk/src/fractions.h"
coord youngs_normal (Point point, scalar c)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  coord n;
  double nn = 0.;
  if (!(2 == 2)) qassert ("/root/mnt/basilisk/src/fractions.h", 395, "dimension == 2");
   {
    n.x = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+1]) ) + sizeof(Cell)))[(c.i)] + 2.*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(c.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+-1]) ) + sizeof(Cell)))[(c.i)] -
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+ +1][point.j+1]) ) + sizeof(Cell)))[(c.i)] - 2.*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+ +1][point.j+0]) ) + sizeof(Cell)))[(c.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+ +1][point.j+-1]) ) + sizeof(Cell)))[(c.i)]);
    nn += fabs(n.x);
  }
# 396 "/root/mnt/basilisk/src/fractions.h"
{
    n.y = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+-1]) ) + sizeof(Cell)))[(c.i)] + 2.*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(c.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+-1]) ) + sizeof(Cell)))[(c.i)] -
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+ +1]) ) + sizeof(Cell)))[(c.i)] - 2.*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+ +1]) ) + sizeof(Cell)))[(c.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+ +1]) ) + sizeof(Cell)))[(c.i)]);
    nn += fabs(n.y);
  }

  if (nn > 0.)
    {
      n.x /= nn;
# 404 "/root/mnt/basilisk/src/fractions.h"
n.y /= nn;}
  else
    n.x = 1.;
  return n;
}





coord facet_normal (Point point, scalar c, vector s)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  if (s.x.i >= 0) {
    coord n;
    double nn = 0.;
     {
      n.x = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.x.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(s.x.i)];
      nn += fabs(n.x);
    }
# 419 "/root/mnt/basilisk/src/fractions.h"
{
      n.y = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.y.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(s.y.i)];
      nn += fabs(n.y);
    }
    if (nn > 0.)
      {
 n.x /= nn;
# 425 "/root/mnt/basilisk/src/fractions.h"
n.y /= nn;}
    else
      {
 n.x = 1./2;
# 428 "/root/mnt/basilisk/src/fractions.h"
n.y = 1./2;}
    return n;
  }
  return mycs (point, c);
}
# 414 "/root/mnt/basilisk/src/fractions.h"
static void _stencil_facet_normal (Point point, scalar c, vector s)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  if (s.x.i >= 0) {


     {
stencil_val (point, s.x, 0, 0, 0, "/root/mnt/basilisk/src/fractions.h", 420, 
# 420 "/root/mnt/basilisk/src/fractions.h" 3 4
0
# 420 "/root/mnt/basilisk/src/fractions.h"
); stencil_val (point, s.x, 1, 0, 0, "/root/mnt/basilisk/src/fractions.h", 420, 
# 420 "/root/mnt/basilisk/src/fractions.h" 3 4
                        0
# 420 "/root/mnt/basilisk/src/fractions.h"
                        );
# 422 "/root/mnt/basilisk/src/fractions.h"
}
# 419 "/root/mnt/basilisk/src/fractions.h"
{
stencil_val (point, s.y, 0, 0, 0, "/root/mnt/basilisk/src/fractions.h", 420, 
# 420 "/root/mnt/basilisk/src/fractions.h" 3 4
0
# 420 "/root/mnt/basilisk/src/fractions.h"
); stencil_val (point, s.y, 0, 1, 0, "/root/mnt/basilisk/src/fractions.h", 420, 
# 420 "/root/mnt/basilisk/src/fractions.h" 3 4
                        0
# 420 "/root/mnt/basilisk/src/fractions.h"
                        );
# 422 "/root/mnt/basilisk/src/fractions.h"
}






    return ;
  }
_stencil_mycs (point, c);
# 431 "/root/mnt/basilisk/src/fractions.h"
return;
}
# 441 "/root/mnt/basilisk/src/fractions.h"

void reconstruction (const scalar c, vector n, scalar alpha)
{;
  { static ForeachData _loop = { "/root/mnt/basilisk/src/fractions.h", 444, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 444 "/root/mnt/basilisk/src/fractions.h" 3 4
 0
# 444 "/root/mnt/basilisk/src/fractions.h"
 ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point); {





stencil_val (point, c, 0, 0, 0, "/root/mnt/basilisk/src/fractions.h", 450, 
# 450 "/root/mnt/basilisk/src/fractions.h" 3 4
0
# 450 "/root/mnt/basilisk/src/fractions.h"
); stencil_val (point, c, 0, 0, 0, "/root/mnt/basilisk/src/fractions.h", 450, 
# 450 "/root/mnt/basilisk/src/fractions.h" 3 4
                      0
# 450 "/root/mnt/basilisk/src/fractions.h"
                      );{ {
      stencil_val_a (point, alpha, 0, 0, 0, 
# 451 "/root/mnt/basilisk/src/fractions.h" 3 4
     0
# 451 "/root/mnt/basilisk/src/fractions.h"
     , "/root/mnt/basilisk/src/fractions.h", 451);

 {stencil_val_a (point, n.x, 0, 0, 0, 
# 453 "/root/mnt/basilisk/src/fractions.h" 3 4
 0
# 453 "/root/mnt/basilisk/src/fractions.h"
 , "/root/mnt/basilisk/src/fractions.h", 453); }
# 453 "/root/mnt/basilisk/src/fractions.h"
{stencil_val_a (point, n.y, 0, 0, 0, 
# 453 "/root/mnt/basilisk/src/fractions.h" 3 4
0
# 453 "/root/mnt/basilisk/src/fractions.h"
, "/root/mnt/basilisk/src/fractions.h", 453); }
    }
{






       _stencil_mycs (point, c);

 {stencil_val_a (point, n.x, 0, 0, 0, 
# 464 "/root/mnt/basilisk/src/fractions.h" 3 4
 0
# 464 "/root/mnt/basilisk/src/fractions.h"
 , "/root/mnt/basilisk/src/fractions.h", 464); }
# 464 "/root/mnt/basilisk/src/fractions.h"
{stencil_val_a (point, n.y, 0, 0, 0, 
# 464 "/root/mnt/basilisk/src/fractions.h" 3 4
0
# 464 "/root/mnt/basilisk/src/fractions.h"
, "/root/mnt/basilisk/src/fractions.h", 464); }
      stencil_val_a (point, alpha, 0, 0, 0, 
# 465 "/root/mnt/basilisk/src/fractions.h" 3 4
     0
# 465 "/root/mnt/basilisk/src/fractions.h"
     , "/root/mnt/basilisk/src/fractions.h", 465);stencil_val (point, c, 0, 0, 0, "/root/mnt/basilisk/src/fractions.h", 465, 
# 465 "/root/mnt/basilisk/src/fractions.h" 3 4
                                 0
# 465 "/root/mnt/basilisk/src/fractions.h"
                                 );
    }}
# 467 "/root/mnt/basilisk/src/fractions.h"
}end_stencil (&_loop); _loop.first = 0;};
  {
# 444 "/root/mnt/basilisk/src/fractions.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {





    if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(c.i)] <= 0. || ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(c.i)] >= 1.) {
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.i)] = 0.;

 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(n.x.i)] = 0.;
# 453 "/root/mnt/basilisk/src/fractions.h"
((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(n.y.i)] = 0.;
    }
    else {






      coord m = mycs (point, c);

 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(n.x.i)] = m.x;
# 464 "/root/mnt/basilisk/src/fractions.h"
((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(n.y.i)] = m.y;
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.i)] = line_alpha (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(c.i)], m);
    }
  }} } };}
# 476 "/root/mnt/basilisk/src/fractions.h"

    _attribute[n.x.i].refine = _attribute[n.x.i].prolongation = refine_injection;
# 477 "/root/mnt/basilisk/src/fractions.h"
_attribute[n.y.i].refine = _attribute[n.y.i].prolongation = refine_injection;




  _attribute[alpha.i].n = n;
  _attribute[alpha.i].refine = _attribute[alpha.i].prolongation = alpha_refine;

;}
# 505 "/root/mnt/basilisk/src/fractions.h"
struct OutputFacets {
  scalar c;
  FILE * fp;
  vector s;
};


void output_facets (struct OutputFacets p)
{;
  scalar c = p.c;
  vector s = p.s;
  if (!p.fp) p.fp = 
# 516 "/root/mnt/basilisk/src/fractions.h" 3
                   stdout
# 516 "/root/mnt/basilisk/src/fractions.h"
                       ;
  if (!s.x.i) s.x.i = -1;

  { static ForeachData _loop = { "/root/mnt/basilisk/src/fractions.h", 519, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 519 "/root/mnt/basilisk/src/fractions.h" 3 4
 0
# 519 "/root/mnt/basilisk/src/fractions.h"
 ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point);
    {stencil_val (point, c, 0, 0, 0, "/root/mnt/basilisk/src/fractions.h", 520, 
# 520 "/root/mnt/basilisk/src/fractions.h" 3 4
    0
# 520 "/root/mnt/basilisk/src/fractions.h"
    ); stencil_val (point, c, 0, 0, 0, "/root/mnt/basilisk/src/fractions.h", 520, 
# 520 "/root/mnt/basilisk/src/fractions.h" 3 4
                           0
# 520 "/root/mnt/basilisk/src/fractions.h"
                           ); {
       _stencil_facet_normal (point, c, s);
      stencil_val (point, c, 0, 0, 0, "/root/mnt/basilisk/src/fractions.h", 522, 
# 522 "/root/mnt/basilisk/src/fractions.h" 3 4
     0
# 522 "/root/mnt/basilisk/src/fractions.h"
     );
# 538 "/root/mnt/basilisk/src/fractions.h"
    } }end_stencil (&_loop); _loop.first = 0;};

  {
# 519 "/root/mnt/basilisk/src/fractions.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(c.i)] > 1e-6 && ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(c.i)] < 1. - 1e-6) {
      coord n = facet_normal (point, c, s);
      double alpha = line_alpha (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(c.i)], n);

      coord segment[2];
      if (facets (n, alpha, segment) == 2)
 fprintf (p.fp, "%g %g\n%g %g\n\n",
   x + segment[0].x*Delta, y + segment[0].y*Delta,
   x + segment[1].x*Delta, y + segment[1].y*Delta);
# 538 "/root/mnt/basilisk/src/fractions.h"
    }} } };}

  fflush (p.fp);
;}
# 550 "/root/mnt/basilisk/src/fractions.h"
double interface_area (scalar c)
{;
  double area = 0.;
  { static ForeachData _loop = { "/root/mnt/basilisk/src/fractions.h", 553, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 553 "/root/mnt/basilisk/src/fractions.h" 3 4
 0
# 553 "/root/mnt/basilisk/src/fractions.h"
 ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point);
    {stencil_val (point, c, 0, 0, 0, "/root/mnt/basilisk/src/fractions.h", 554, 
# 554 "/root/mnt/basilisk/src/fractions.h" 3 4
    0
# 554 "/root/mnt/basilisk/src/fractions.h"
    ); stencil_val (point, c, 0, 0, 0, "/root/mnt/basilisk/src/fractions.h", 554, 
# 554 "/root/mnt/basilisk/src/fractions.h" 3 4
                           0
# 554 "/root/mnt/basilisk/src/fractions.h"
                           ); {
       _stencil_mycs (point, c);
      stencil_val (point, c, 0, 0, 0, "/root/mnt/basilisk/src/fractions.h", 556, 
# 556 "/root/mnt/basilisk/src/fractions.h" 3 4
     0
# 556 "/root/mnt/basilisk/src/fractions.h"
     );

    } }end_stencil (&_loop); _loop.first = 0;};



{
# 553 "/root/mnt/basilisk/src/fractions.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(c.i)] > 1e-6 && ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(c.i)] < 1. - 1e-6) {
      coord n = mycs (point, c), p;
      double alpha = line_alpha (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(c.i)], n);
      area += pow(Delta, 2 - 1)*line_length_center(n,alpha,&p);
    }} } };;


}
# 559 "/root/mnt/basilisk/src/fractions.h"
{;return area;}
;}
# 36 "/root/mnt/basilisk/src/vof.h"
# 44 "/root/mnt/basilisk/src/vof.h"
extern scalar * interfaces;
extern vector uf;
extern double dt;
# 55 "/root/mnt/basilisk/src/vof.h"
static double vof_concentration_gradient_x (Point point, scalar c, scalar t)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  static const double cmin = 0.5;
  double cl = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(c.i)], cc = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(c.i)], cr = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(c.i)];
  if (_attribute[t.i].inverse)
    cl = 1. - cl, cc = 1. - cc, cr = 1. - cr;
  if (cc >= cmin && _attribute[t.i].gradient != zero) {
    if (cr >= cmin) {
      if (cl >= cmin) {
 if (_attribute[t.i].gradient)
   return _attribute[t.i].gradient (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(t.i)]/cl, ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(t.i)]/cc, ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(t.i)]/cr)/Delta;
 else
   return (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(t.i)]/cr - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(t.i)]/cl)/(2.*Delta);
      }
      else
 return (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(t.i)]/cr - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(t.i)]/cc)/Delta;
    }
    else if (cl >= cmin)
      return (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(t.i)]/cc - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(t.i)]/cl)/Delta;
  }
  return 0.;
}
# 55 "/root/mnt/basilisk/src/vof.h"
static double vof_concentration_gradient_y (Point point, scalar c, scalar t)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  static const double cmin = 0.5;
  double cl = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(c.i)], cc = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(c.i)], cr = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(c.i)];
  if (_attribute[t.i].inverse)
    cl = 1. - cl, cc = 1. - cc, cr = 1. - cr;
  if (cc >= cmin && _attribute[t.i].gradient != zero) {
    if (cr >= cmin) {
      if (cl >= cmin) {
 if (_attribute[t.i].gradient)
   return _attribute[t.i].gradient (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(t.i)]/cl, ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(t.i)]/cc, ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(t.i)]/cr)/Delta;
 else
   return (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(t.i)]/cr - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(t.i)]/cl)/(2.*Delta);
      }
      else
 return (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(t.i)]/cr - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(t.i)]/cc)/Delta;
    }
    else if (cl >= cmin)
      return (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(t.i)]/cc - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(t.i)]/cl)/Delta;
  }
  return 0.;
}
# 55 "/root/mnt/basilisk/src/vof.h"
static void _stencil_vof_concentration_gradient_x (Point point, scalar c, scalar t)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;

   stencil_val (point, c, 1, 0, 0, "/root/mnt/basilisk/src/vof.h", 58, 
# 58 "/root/mnt/basilisk/src/vof.h" 3 4
  0
# 58 "/root/mnt/basilisk/src/vof.h"
  ); stencil_val (point, c, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 58, 
# 58 "/root/mnt/basilisk/src/vof.h" 3 4
                         0
# 58 "/root/mnt/basilisk/src/vof.h"
                         ); stencil_val (point, c, -1, 0, 0, "/root/mnt/basilisk/src/vof.h", 58, 
# 58 "/root/mnt/basilisk/src/vof.h" 3 4
                                                0
# 58 "/root/mnt/basilisk/src/vof.h"
                                                );


{
{ {
{ {
 if (_attribute[t.i].gradient)
   {stencil_val (point, t, -1, 0, 0, "/root/mnt/basilisk/src/vof.h", 65, 
# 65 "/root/mnt/basilisk/src/vof.h" 3 4
   0
# 65 "/root/mnt/basilisk/src/vof.h"
   ); stencil_val (point, t, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 65, 
# 65 "/root/mnt/basilisk/src/vof.h" 3 4
                           0
# 65 "/root/mnt/basilisk/src/vof.h"
                           ); stencil_val (point, t, 1, 0, 0, "/root/mnt/basilisk/src/vof.h", 65, 
# 65 "/root/mnt/basilisk/src/vof.h" 3 4
                                                  0
# 65 "/root/mnt/basilisk/src/vof.h"
                                                  ); }
 else
   {stencil_val (point, t, 1, 0, 0, "/root/mnt/basilisk/src/vof.h", 67, 
# 67 "/root/mnt/basilisk/src/vof.h" 3 4
   0
# 67 "/root/mnt/basilisk/src/vof.h"
   ); stencil_val (point, t, -1, 0, 0, "/root/mnt/basilisk/src/vof.h", 67, 
# 67 "/root/mnt/basilisk/src/vof.h" 3 4
                          0
# 67 "/root/mnt/basilisk/src/vof.h"
                          ); }
      }

{stencil_val (point, t, 1, 0, 0, "/root/mnt/basilisk/src/vof.h", 70, 
# 70 "/root/mnt/basilisk/src/vof.h" 3 4
0
# 70 "/root/mnt/basilisk/src/vof.h"
); stencil_val (point, t, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 70, 
# 70 "/root/mnt/basilisk/src/vof.h" 3 4
                       0
# 70 "/root/mnt/basilisk/src/vof.h"
                       ); }}
# 71 "/root/mnt/basilisk/src/vof.h"
}

{stencil_val (point, t, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 73, 
# 73 "/root/mnt/basilisk/src/vof.h" 3 4
0
# 73 "/root/mnt/basilisk/src/vof.h"
); stencil_val (point, t, -1, 0, 0, "/root/mnt/basilisk/src/vof.h", 73, 
# 73 "/root/mnt/basilisk/src/vof.h" 3 4
                       0
# 73 "/root/mnt/basilisk/src/vof.h"
                       ); }}
# 74 "/root/mnt/basilisk/src/vof.h"
}
# 75 "/root/mnt/basilisk/src/vof.h"
return ;
}
# 55 "/root/mnt/basilisk/src/vof.h"
static void _stencil_vof_concentration_gradient_y (Point point, scalar c, scalar t)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;

   stencil_val (point, c, 0, 1, 0, "/root/mnt/basilisk/src/vof.h", 58, 
# 58 "/root/mnt/basilisk/src/vof.h" 3 4
  0
# 58 "/root/mnt/basilisk/src/vof.h"
  ); stencil_val (point, c, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 58, 
# 58 "/root/mnt/basilisk/src/vof.h" 3 4
                         0
# 58 "/root/mnt/basilisk/src/vof.h"
                         ); stencil_val (point, c, 0, -1, 0, "/root/mnt/basilisk/src/vof.h", 58, 
# 58 "/root/mnt/basilisk/src/vof.h" 3 4
                                                0
# 58 "/root/mnt/basilisk/src/vof.h"
                                                );


{
{ {
{ {
 if (_attribute[t.i].gradient)
   {stencil_val (point, t, 0, -1, 0, "/root/mnt/basilisk/src/vof.h", 65, 
# 65 "/root/mnt/basilisk/src/vof.h" 3 4
   0
# 65 "/root/mnt/basilisk/src/vof.h"
   ); stencil_val (point, t, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 65, 
# 65 "/root/mnt/basilisk/src/vof.h" 3 4
                           0
# 65 "/root/mnt/basilisk/src/vof.h"
                           ); stencil_val (point, t, 0, 1, 0, "/root/mnt/basilisk/src/vof.h", 65, 
# 65 "/root/mnt/basilisk/src/vof.h" 3 4
                                                  0
# 65 "/root/mnt/basilisk/src/vof.h"
                                                  ); }
 else
   {stencil_val (point, t, 0, 1, 0, "/root/mnt/basilisk/src/vof.h", 67, 
# 67 "/root/mnt/basilisk/src/vof.h" 3 4
   0
# 67 "/root/mnt/basilisk/src/vof.h"
   ); stencil_val (point, t, 0, -1, 0, "/root/mnt/basilisk/src/vof.h", 67, 
# 67 "/root/mnt/basilisk/src/vof.h" 3 4
                          0
# 67 "/root/mnt/basilisk/src/vof.h"
                          ); }
      }

{stencil_val (point, t, 0, 1, 0, "/root/mnt/basilisk/src/vof.h", 70, 
# 70 "/root/mnt/basilisk/src/vof.h" 3 4
0
# 70 "/root/mnt/basilisk/src/vof.h"
); stencil_val (point, t, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 70, 
# 70 "/root/mnt/basilisk/src/vof.h" 3 4
                       0
# 70 "/root/mnt/basilisk/src/vof.h"
                       ); }}
# 71 "/root/mnt/basilisk/src/vof.h"
}

{stencil_val (point, t, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 73, 
# 73 "/root/mnt/basilisk/src/vof.h" 3 4
0
# 73 "/root/mnt/basilisk/src/vof.h"
); stencil_val (point, t, 0, -1, 0, "/root/mnt/basilisk/src/vof.h", 73, 
# 73 "/root/mnt/basilisk/src/vof.h" 3 4
                       0
# 73 "/root/mnt/basilisk/src/vof.h"
                       ); }}
# 74 "/root/mnt/basilisk/src/vof.h"
}
# 75 "/root/mnt/basilisk/src/vof.h"
return ;
}






static void vof_concentration_refine (Point point, scalar s)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 84 "/root/mnt/basilisk/src/vof.h"
if(!((cm).i >= 65536)){{
  scalar f = _attribute[s.i].c;
  if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(cm.i)] == 0. || (!_attribute[s.i].inverse && ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)] <= 0.) || (_attribute[s.i].inverse && ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)] >= 1.))
    {{ int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] = 0.;} } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}}
  else {
    coord g;

      g.x = Delta*vof_concentration_gradient_x (point, f, s);
# 92 "/root/mnt/basilisk/src/vof.h"
g.y = Delta*vof_concentration_gradient_y (point, f, s);
    double sc = _attribute[s.i].inverse ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)]/(1. - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)]) : ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)]/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)], cmc = 4.*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(cm.i)];
    {{ int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] = sc;

 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] += child.x*g.x*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-child.x][point.j+0]) ) + sizeof(Cell)))[(cm.i)]/cmc;
# 97 "/root/mnt/basilisk/src/vof.h"
((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] += child.y*g.y*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-child.y]) ) + sizeof(Cell)))[(cm.i)]/cmc;
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] *= _attribute[s.i].inverse ? 1. - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)] : ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)];
    }} } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}}
  }
}}else {double _const_cm=_constant[cm.i-65536];(void)(_const_cm);
# 84 "/root/mnt/basilisk/src/vof.h"
{
  scalar f = _attribute[s.i].c;
  if (_const_cm == 0. || (!_attribute[s.i].inverse && ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)] <= 0.) || (_attribute[s.i].inverse && ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)] >= 1.))
    {{ int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] = 0.;} } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}}
  else {
    coord g;

      g.x = Delta*vof_concentration_gradient_x (point, f, s);
# 92 "/root/mnt/basilisk/src/vof.h"
g.y = Delta*vof_concentration_gradient_y (point, f, s);
    double sc = _attribute[s.i].inverse ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)]/(1. - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)]) : ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)]/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)], cmc = 4.*_const_cm;
    {{ int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] = sc;

 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] += child.x*g.x*_const_cm/cmc;
# 97 "/root/mnt/basilisk/src/vof.h"
((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] += child.y*g.y*_const_cm/cmc;
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.i)] *= _attribute[s.i].inverse ? 1. - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)] : ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)];
    }} } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}}
  }
}}
# 101 "/root/mnt/basilisk/src/vof.h"
}





static int defaults_1_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i = 0);*ip=i;*tp=t;return ret;} static int defaults_1(const int i,const double t,Event *_ev){;
{
  {scalar*_i=(scalar*)( interfaces);if(_i)for(scalar c=*_i;(&c)->i>=0;c=*++_i){ {
    _attribute[c.i].refine = _attribute[c.i].prolongation = fraction_refine;
    _attribute[c.i].dirty = 
# 111 "/root/mnt/basilisk/src/vof.h" 3 4
                           1
# 111 "/root/mnt/basilisk/src/vof.h"
                               ;
    scalar * tracers = _attribute[c.i].tracers;
    {scalar*_i=(scalar*)( tracers);if(_i)for(scalar t=*_i;(&t)->i>=0;t=*++_i){ {
      _attribute[t.i].restriction = restriction_volume_average;
      _attribute[t.i].refine = _attribute[t.i].prolongation = vof_concentration_refine;
      _attribute[t.i].dirty = 
# 116 "/root/mnt/basilisk/src/vof.h" 3 4
                             1
# 116 "/root/mnt/basilisk/src/vof.h"
                                 ;
      _attribute[t.i].c = c;
    }}}
  }}}
}{;return 0;};}






static int defaults_2_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i = 0);*ip=i;*tp=t;return ret;} static int defaults_2(const int i,const double t,Event *_ev){;
{
  {scalar*_i=(scalar*)( interfaces);if(_i)for(scalar c=*_i;(&c)->i>=0;c=*++_i){ {
    scalar * tracers = _attribute[c.i].tracers;
    {scalar*_i=(scalar*)( tracers);if(_i)for(scalar t=*_i;(&t)->i>=0;t=*++_i){
      _attribute[t.i].depends = list_add (_attribute[t.i].depends, c);}}
  }}}
}{;return 0;};}





static int stability_0_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;} static int stability_0(const int i,const double t,Event *_ev){; {
  if (CFL > 0.5)
    CFL = 0.5;
}{;return 0;};}
# 157 "/root/mnt/basilisk/src/vof.h"

static void sweep_x (scalar c, scalar cc, scalar * tcl)
{
  vector n=new_vector("n");
  scalar alpha=new_scalar("alpha"), flux=new_scalar("flux");
  double cfl = 0.;
# 171 "/root/mnt/basilisk/src/vof.h"
  scalar * tracers = _attribute[c.i].tracers, * gfl = 
# 171 "/root/mnt/basilisk/src/vof.h" 3 4
                                                     ((void *)0)
# 171 "/root/mnt/basilisk/src/vof.h"
                                                         , * tfluxl = 
# 171 "/root/mnt/basilisk/src/vof.h" 3 4
                                                                      ((void *)0)
# 171 "/root/mnt/basilisk/src/vof.h"
                                                                          ;
  if (tracers) {
    {scalar*_i=(scalar*)( tracers);if(_i)for(scalar t=*_i;(&t)->i>=0;t=*++_i){ {
      scalar gf = new_scalar("gf"), flux = new_scalar("flux");
      gfl = list_append (gfl, gf);
      tfluxl = list_append (tfluxl, flux);
    }}}




    { static ForeachData _loop = { "/root/mnt/basilisk/src/vof.h", 182, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 182 "/root/mnt/basilisk/src/vof.h" 3 4
   0
# 182 "/root/mnt/basilisk/src/vof.h"
   ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point); {
      scalar t, gf;
      {scalar*_i0=gfl;scalar*_i1= tracers;if(_i0)for(gf=*_i0,t=*_i1;_i0->i>= 0;gf=*++_i0,t=*++_i1){
 {stencil_val_a (point, gf, 0, 0, 0, 
# 185 "/root/mnt/basilisk/src/vof.h" 3 4
 0
# 185 "/root/mnt/basilisk/src/vof.h"
 , "/root/mnt/basilisk/src/vof.h", 185); _stencil_vof_concentration_gradient_x (point, c, t); }}}
    }end_stencil (&_loop); _loop.first = 0;};




    {
# 182 "/root/mnt/basilisk/src/vof.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
      scalar t, gf;
      {scalar*_i0=gfl;scalar*_i1= tracers;if(_i0)for(gf=*_i0,t=*_i1;_i0->i>= 0;gf=*++_i0,t=*++_i1){
 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(gf.i)] = vof_concentration_gradient_x (point, c, t);}}
    }} } };}
  }






  reconstruction (c, n, alpha);
  { static ForeachData _loop = { "/root/mnt/basilisk/src/vof.h", 195, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 195 "/root/mnt/basilisk/src/vof.h" 3 4
 0
# 195 "/root/mnt/basilisk/src/vof.h"
 ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point);{ _loop.face |= (1 << 0);{ {






    stencil_val (point, fm.x, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 202, 
# 202 "/root/mnt/basilisk/src/vof.h" 3 4
   0
# 202 "/root/mnt/basilisk/src/vof.h"
   ); stencil_val (point, uf.x, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 202, 
# 202 "/root/mnt/basilisk/src/vof.h" 3 4
                             0
# 202 "/root/mnt/basilisk/src/vof.h"
                             );
# 211 "/root/mnt/basilisk/src/vof.h"
stencil_val (point, fm.x, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 211, 
# 211 "/root/mnt/basilisk/src/vof.h" 3 4
0
# 211 "/root/mnt/basilisk/src/vof.h"
);stencil_val (point, cm, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 211, 
# 211 "/root/mnt/basilisk/src/vof.h" 3 4
                        0
# 211 "/root/mnt/basilisk/src/vof.h"
                        );
      {stencil_val (point, fm.x, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 212, 
# 212 "/root/mnt/basilisk/src/vof.h" 3 4
      0
# 212 "/root/mnt/basilisk/src/vof.h"
      );stencil_val (point, cm, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 212, 
# 212 "/root/mnt/basilisk/src/vof.h" 3 4
                               0
# 212 "/root/mnt/basilisk/src/vof.h"
                               ); }
# 225 "/root/mnt/basilisk/src/vof.h"

stencil_val (point, alpha, -2, 0, 0, "/root/mnt/basilisk/src/vof.h", 226, 
# 226 "/root/mnt/basilisk/src/vof.h" 3 4
0
# 226 "/root/mnt/basilisk/src/vof.h"
);(_stencil_nop = 1);stencil_val (point, n.y, -2, 0, 0, "/root/mnt/basilisk/src/vof.h", 226, 
# 226 "/root/mnt/basilisk/src/vof.h" 3 4
                                                                0
# 226 "/root/mnt/basilisk/src/vof.h"
                                                                );stencil_val (point, n.x, -2, 0, 0, "/root/mnt/basilisk/src/vof.h", 226, 
# 226 "/root/mnt/basilisk/src/vof.h" 3 4
                                                                                                 0
# 226 "/root/mnt/basilisk/src/vof.h"
                                                                                                 );
# 225 "/root/mnt/basilisk/src/vof.h"
stencil_val (point, c, -2, 0, 0, "/root/mnt/basilisk/src/vof.h", 225, 
# 225 "/root/mnt/basilisk/src/vof.h" 3 4
0
# 225 "/root/mnt/basilisk/src/vof.h"
);stencil_val (point, c, -2, 0, 0, "/root/mnt/basilisk/src/vof.h", 225, 
# 225 "/root/mnt/basilisk/src/vof.h" 3 4
                              0
# 225 "/root/mnt/basilisk/src/vof.h"
                              );stencil_val (point, c, -2, 0, 0, "/root/mnt/basilisk/src/vof.h", 225, 
# 225 "/root/mnt/basilisk/src/vof.h" 3 4
                                                             0
# 225 "/root/mnt/basilisk/src/vof.h"
                                                             );
# 234 "/root/mnt/basilisk/src/vof.h"
stencil_val_a (point, flux, 0, 0, 0, 
# 234 "/root/mnt/basilisk/src/vof.h" 3 4
0
# 234 "/root/mnt/basilisk/src/vof.h"
, "/root/mnt/basilisk/src/vof.h", 234);stencil_val (point, uf.x, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 234, 
# 234 "/root/mnt/basilisk/src/vof.h" 3 4
                          0
# 234 "/root/mnt/basilisk/src/vof.h"
                          );






    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {
      stencil_val (point, c, -2, 0, 0, "/root/mnt/basilisk/src/vof.h", 243, 
# 243 "/root/mnt/basilisk/src/vof.h" 3 4
     0
# 243 "/root/mnt/basilisk/src/vof.h"
     );


{ {
 stencil_val (point, gf, -2, 0, 0, "/root/mnt/basilisk/src/vof.h", 247, 
# 247 "/root/mnt/basilisk/src/vof.h" 3 4
0
# 247 "/root/mnt/basilisk/src/vof.h"
);stencil_val (point, t, -2, 0, 0, "/root/mnt/basilisk/src/vof.h", 247, 
# 247 "/root/mnt/basilisk/src/vof.h" 3 4
                               0
# 247 "/root/mnt/basilisk/src/vof.h"
                               );
 stencil_val_a (point, tflux, 0, 0, 0, 
# 248 "/root/mnt/basilisk/src/vof.h" 3 4
0
# 248 "/root/mnt/basilisk/src/vof.h"
, "/root/mnt/basilisk/src/vof.h", 248);stencil_val (point, uf.x, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 248, 
# 248 "/root/mnt/basilisk/src/vof.h" 3 4
                            0
# 248 "/root/mnt/basilisk/src/vof.h"
                            );
      }

{stencil_val_a (point, tflux, 0, 0, 0, 
# 251 "/root/mnt/basilisk/src/vof.h" 3 4
0
# 251 "/root/mnt/basilisk/src/vof.h"
, "/root/mnt/basilisk/src/vof.h", 251); }}
# 252 "/root/mnt/basilisk/src/vof.h"
}}}
  }}}end_stencil (&_loop); _loop.first = 0;};
# 195 "/root/mnt/basilisk/src/vof.h"
if(!((fm.x).i >= 65536) && !((cm).i >= 65536)){


{
# 195 "/root/mnt/basilisk/src/vof.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{ {






    double un = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.x.i)]*dt/(Delta*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)] + 0.), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;







    if (un*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)]*s/(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(cm.i)] + 0.) > cfl)
      cfl = un*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)]*s/(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(cm.i)] + 0.);
# 225 "/root/mnt/basilisk/src/vof.h"
    double cf = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(c.i)] <= 0. || ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(c.i)] >= 1.) ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(c.i)] :
      rectangle_fraction ((coord){-s*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(n.x.i)], ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(n.y.i)], _val_higher_dimension}, ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(alpha.i)],
     (coord){-0.5, -0.5, -0.5},
     (coord){s*un - 0.5, 0.5, 0.5});





    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(flux.i)] = cf*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.x.i)];






    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {
      double cf1 = cf, ci = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(c.i)];
      if (_attribute[t.i].inverse)
 cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
 double ff = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(t.i)]/ci + s*((1.) < (1. - s*un) ? (1.) : (1. - s*un))*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(gf.i)]*Delta/2.;
 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(tflux.i)] = ff*cf1*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.x.i)];
      }
      else
 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(tflux.i)] = 0.;
    }}}
  }}}}} } };;


}
# 253 "/root/mnt/basilisk/src/vof.h"
}else if(((fm.x).i >= 65536) && !((cm).i >= 65536)){struct{double x,y;}_const_fm={_constant[fm.x.i-65536],_constant[fm.y.i-65536]};(void)(_const_fm);



{
# 195 "/root/mnt/basilisk/src/vof.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{ {






    double un = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.x.i)]*dt/(Delta*_const_fm.x + 0.), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;







    if (un*_const_fm.x*s/(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(cm.i)] + 0.) > cfl)
      cfl = un*_const_fm.x*s/(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(cm.i)] + 0.);
# 225 "/root/mnt/basilisk/src/vof.h"
    double cf = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(c.i)] <= 0. || ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(c.i)] >= 1.) ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(c.i)] :
      rectangle_fraction ((coord){-s*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(n.x.i)], ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(n.y.i)], _val_higher_dimension}, ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(alpha.i)],
     (coord){-0.5, -0.5, -0.5},
     (coord){s*un - 0.5, 0.5, 0.5});





    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(flux.i)] = cf*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.x.i)];






    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {
      double cf1 = cf, ci = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(c.i)];
      if (_attribute[t.i].inverse)
 cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
 double ff = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(t.i)]/ci + s*((1.) < (1. - s*un) ? (1.) : (1. - s*un))*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(gf.i)]*Delta/2.;
 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(tflux.i)] = ff*cf1*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.x.i)];
      }
      else
 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(tflux.i)] = 0.;
    }}}
  }}}}} } };;


}
# 253 "/root/mnt/basilisk/src/vof.h"
}else if(!((fm.x).i >= 65536) && ((cm).i >= 65536)){double _const_cm=_constant[cm.i-65536];(void)(_const_cm);



{
# 195 "/root/mnt/basilisk/src/vof.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{ {






    double un = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.x.i)]*dt/(Delta*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)] + 0.), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;







    if (un*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)]*s/(_const_cm + 0.) > cfl)
      cfl = un*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)]*s/(_const_cm + 0.);
# 225 "/root/mnt/basilisk/src/vof.h"
    double cf = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(c.i)] <= 0. || ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(c.i)] >= 1.) ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(c.i)] :
      rectangle_fraction ((coord){-s*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(n.x.i)], ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(n.y.i)], _val_higher_dimension}, ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(alpha.i)],
     (coord){-0.5, -0.5, -0.5},
     (coord){s*un - 0.5, 0.5, 0.5});





    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(flux.i)] = cf*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.x.i)];






    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {
      double cf1 = cf, ci = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(c.i)];
      if (_attribute[t.i].inverse)
 cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
 double ff = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(t.i)]/ci + s*((1.) < (1. - s*un) ? (1.) : (1. - s*un))*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(gf.i)]*Delta/2.;
 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(tflux.i)] = ff*cf1*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.x.i)];
      }
      else
 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(tflux.i)] = 0.;
    }}}
  }}}}} } };;


}
# 253 "/root/mnt/basilisk/src/vof.h"
}else {struct{double x,y;}_const_fm={_constant[fm.x.i-65536],_constant[fm.y.i-65536]};(void)(_const_fm);double _const_cm=_constant[cm.i-65536];(void)(_const_cm);



{
# 195 "/root/mnt/basilisk/src/vof.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{ {






    double un = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.x.i)]*dt/(Delta*_const_fm.x + 0.), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;







    if (un*_const_fm.x*s/(_const_cm + 0.) > cfl)
      cfl = un*_const_fm.x*s/(_const_cm + 0.);
# 225 "/root/mnt/basilisk/src/vof.h"
    double cf = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(c.i)] <= 0. || ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(c.i)] >= 1.) ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(c.i)] :
      rectangle_fraction ((coord){-s*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(n.x.i)], ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(n.y.i)], _val_higher_dimension}, ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(alpha.i)],
     (coord){-0.5, -0.5, -0.5},
     (coord){s*un - 0.5, 0.5, 0.5});





    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(flux.i)] = cf*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.x.i)];






    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {
      double cf1 = cf, ci = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(c.i)];
      if (_attribute[t.i].inverse)
 cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
 double ff = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(t.i)]/ci + s*((1.) < (1. - s*un) ? (1.) : (1. - s*un))*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(gf.i)]*Delta/2.;
 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(tflux.i)] = ff*cf1*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.x.i)];
      }
      else
 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(tflux.i)] = 0.;
    }}}
  }}}}} } };;


}
# 253 "/root/mnt/basilisk/src/vof.h"
}
  delete (gfl); free(gfl);




  if (cfl > 0.5 + 1e-6)
    fprintf (
# 260 "/root/mnt/basilisk/src/vof.h" 3
            stderr
# 260 "/root/mnt/basilisk/src/vof.h"
                ,
      "WARNING: CFL must be <= 0.5 for VOF (cfl - 0.5 = %g)\n",
      cfl - 0.5), fflush (
# 262 "/root/mnt/basilisk/src/vof.h" 3
                         stderr
# 262 "/root/mnt/basilisk/src/vof.h"
                             );
# 282 "/root/mnt/basilisk/src/vof.h"
  { static ForeachData _loop = { "/root/mnt/basilisk/src/vof.h", 282, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 282 "/root/mnt/basilisk/src/vof.h" 3 4
 0
# 282 "/root/mnt/basilisk/src/vof.h"
 ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point); {
    stencil_val_a (point, c, 0, 0, 0, 
# 283 "/root/mnt/basilisk/src/vof.h" 3 4
   1
# 283 "/root/mnt/basilisk/src/vof.h"
   , "/root/mnt/basilisk/src/vof.h", 283);stencil_val (point, flux, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 283, 
# 283 "/root/mnt/basilisk/src/vof.h" 3 4
                           0
# 283 "/root/mnt/basilisk/src/vof.h"
                           ); stencil_val (point, flux, 1, 0, 0, "/root/mnt/basilisk/src/vof.h", 283, 
# 283 "/root/mnt/basilisk/src/vof.h" 3 4
                                                     0
# 283 "/root/mnt/basilisk/src/vof.h"
                                                     ); stencil_val (point, cc, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 283, 
# 283 "/root/mnt/basilisk/src/vof.h" 3 4
                                                                               0
# 283 "/root/mnt/basilisk/src/vof.h"
                                                                               );stencil_val (point, uf.x, 1, 0, 0, "/root/mnt/basilisk/src/vof.h", 283, 
# 283 "/root/mnt/basilisk/src/vof.h" 3 4
                                                                                                      0
# 283 "/root/mnt/basilisk/src/vof.h"
                                                                                                      ); stencil_val (point, uf.x, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 283, 
# 283 "/root/mnt/basilisk/src/vof.h" 3 4
                                                                                                                                0
# 283 "/root/mnt/basilisk/src/vof.h"
                                                                                                                                );stencil_val (point, cm, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 283, 
# 283 "/root/mnt/basilisk/src/vof.h" 3 4
                                                                                                                                                         0
# 283 "/root/mnt/basilisk/src/vof.h"
                                                                                                                                                         );
    scalar t, tc, tflux;
    {scalar*_i0= tfluxl;scalar*_i1= tcl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,tc=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,tc=*++_i1,t=*++_i2){
      {stencil_val_a (point, t, 0, 0, 0, 
# 286 "/root/mnt/basilisk/src/vof.h" 3 4
      1
# 286 "/root/mnt/basilisk/src/vof.h"
      , "/root/mnt/basilisk/src/vof.h", 286);stencil_val (point, tflux, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 286, 
# 286 "/root/mnt/basilisk/src/vof.h" 3 4
                              0
# 286 "/root/mnt/basilisk/src/vof.h"
                              ); stencil_val (point, tflux, 1, 0, 0, "/root/mnt/basilisk/src/vof.h", 286, 
# 286 "/root/mnt/basilisk/src/vof.h" 3 4
                                                         0
# 286 "/root/mnt/basilisk/src/vof.h"
                                                         ); stencil_val (point, tc, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 286, 
# 286 "/root/mnt/basilisk/src/vof.h" 3 4
                                                                                    0
# 286 "/root/mnt/basilisk/src/vof.h"
                                                                                    );stencil_val (point, uf.x, 1, 0, 0, "/root/mnt/basilisk/src/vof.h", 286, 
# 286 "/root/mnt/basilisk/src/vof.h" 3 4
                                                                                                           0
# 286 "/root/mnt/basilisk/src/vof.h"
                                                                                                           ); stencil_val (point, uf.x, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 286, 
# 286 "/root/mnt/basilisk/src/vof.h" 3 4
                                                                                                                                     0
# 286 "/root/mnt/basilisk/src/vof.h"
                                                                                                                                     );stencil_val (point, cm, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 286, 
# 286 "/root/mnt/basilisk/src/vof.h" 3 4
                                                                                                                                                              0
# 286 "/root/mnt/basilisk/src/vof.h"
                                                                                                                                                              ); }}}
  }end_stencil (&_loop); _loop.first = 0;};
# 282 "/root/mnt/basilisk/src/vof.h"
  if(!((cm).i >= 65536)){{{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(c.i)] += dt*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(flux.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(flux.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(cc.i)]*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(uf.x.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.x.i)]))/(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(cm.i)]*Delta);
    scalar t, tc, tflux;
    {scalar*_i0= tfluxl;scalar*_i1= tcl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,tc=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,tc=*++_i1,t=*++_i2){
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(t.i)] += dt*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(tflux.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(tflux.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(tc.i)]*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(uf.x.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.x.i)]))/(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(cm.i)]*Delta);}}
  }} } };}}else {double _const_cm=_constant[cm.i-65536];(void)(_const_cm);
# 282 "/root/mnt/basilisk/src/vof.h"
  {{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(c.i)] += dt*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(flux.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(flux.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(cc.i)]*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(uf.x.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.x.i)]))/(_const_cm*Delta);
    scalar t, tc, tflux;
    {scalar*_i0= tfluxl;scalar*_i1= tcl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,tc=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,tc=*++_i1,t=*++_i2){
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(t.i)] += dt*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(tflux.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(tflux.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(tc.i)]*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(uf.x.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.x.i)]))/(_const_cm*Delta);}}
  }} } };}}
# 305 "/root/mnt/basilisk/src/vof.h"
  delete (tfluxl); free(tfluxl);delete((scalar*)((scalar[]){flux,alpha,n.x,n.y,{-1}}));
}
# 158 "/root/mnt/basilisk/src/vof.h"
static void sweep_y (scalar c, scalar cc, scalar * tcl)
{
  vector n=new_vector("n");
  scalar alpha=new_scalar("alpha"), flux=new_scalar("flux");
  double cfl = 0.;
# 171 "/root/mnt/basilisk/src/vof.h"
  scalar * tracers = _attribute[c.i].tracers, * gfl = 
# 171 "/root/mnt/basilisk/src/vof.h" 3 4
                                                     ((void *)0)
# 171 "/root/mnt/basilisk/src/vof.h"
                                                         , * tfluxl = 
# 171 "/root/mnt/basilisk/src/vof.h" 3 4
                                                                      ((void *)0)
# 171 "/root/mnt/basilisk/src/vof.h"
                                                                          ;
  if (tracers) {
    {scalar*_i=(scalar*)( tracers);if(_i)for(scalar t=*_i;(&t)->i>=0;t=*++_i){ {
      scalar gf = new_scalar("gf"), flux = new_scalar("flux");
      gfl = list_append (gfl, gf);
      tfluxl = list_append (tfluxl, flux);
    }}}




    { static ForeachData _loop = { "/root/mnt/basilisk/src/vof.h", 182, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 182 "/root/mnt/basilisk/src/vof.h" 3 4
   0
# 182 "/root/mnt/basilisk/src/vof.h"
   ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point); {
      scalar t, gf;
      {scalar*_i0=gfl;scalar*_i1= tracers;if(_i0)for(gf=*_i0,t=*_i1;_i0->i>= 0;gf=*++_i0,t=*++_i1){
 {stencil_val_a (point, gf, 0, 0, 0, 
# 185 "/root/mnt/basilisk/src/vof.h" 3 4
 0
# 185 "/root/mnt/basilisk/src/vof.h"
 , "/root/mnt/basilisk/src/vof.h", 185); _stencil_vof_concentration_gradient_y (point, c, t); }}}
    }end_stencil (&_loop); _loop.first = 0;};




    {
# 182 "/root/mnt/basilisk/src/vof.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
      scalar t, gf;
      {scalar*_i0=gfl;scalar*_i1= tracers;if(_i0)for(gf=*_i0,t=*_i1;_i0->i>= 0;gf=*++_i0,t=*++_i1){
 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(gf.i)] = vof_concentration_gradient_y (point, c, t);}}
    }} } };}
  }






  reconstruction (c, n, alpha);
  { static ForeachData _loop = { "/root/mnt/basilisk/src/vof.h", 195, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 195 "/root/mnt/basilisk/src/vof.h" 3 4
 0
# 195 "/root/mnt/basilisk/src/vof.h"
 ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point);{ _loop.face |= (1 << 1);{ {






    stencil_val (point, fm.y, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 202, 
# 202 "/root/mnt/basilisk/src/vof.h" 3 4
   0
# 202 "/root/mnt/basilisk/src/vof.h"
   ); stencil_val (point, uf.y, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 202, 
# 202 "/root/mnt/basilisk/src/vof.h" 3 4
                             0
# 202 "/root/mnt/basilisk/src/vof.h"
                             );
# 211 "/root/mnt/basilisk/src/vof.h"
stencil_val (point, fm.y, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 211, 
# 211 "/root/mnt/basilisk/src/vof.h" 3 4
0
# 211 "/root/mnt/basilisk/src/vof.h"
);stencil_val (point, cm, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 211, 
# 211 "/root/mnt/basilisk/src/vof.h" 3 4
                        0
# 211 "/root/mnt/basilisk/src/vof.h"
                        );
      {stencil_val (point, fm.y, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 212, 
# 212 "/root/mnt/basilisk/src/vof.h" 3 4
      0
# 212 "/root/mnt/basilisk/src/vof.h"
      );stencil_val (point, cm, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 212, 
# 212 "/root/mnt/basilisk/src/vof.h" 3 4
                               0
# 212 "/root/mnt/basilisk/src/vof.h"
                               ); }
# 225 "/root/mnt/basilisk/src/vof.h"

stencil_val (point, alpha, 0, -2, 0, "/root/mnt/basilisk/src/vof.h", 226, 
# 226 "/root/mnt/basilisk/src/vof.h" 3 4
0
# 226 "/root/mnt/basilisk/src/vof.h"
);(_stencil_nop = 1);stencil_val (point, n.x, 0, -2, 0, "/root/mnt/basilisk/src/vof.h", 226, 
# 226 "/root/mnt/basilisk/src/vof.h" 3 4
                                                                0
# 226 "/root/mnt/basilisk/src/vof.h"
                                                                );stencil_val (point, n.y, 0, -2, 0, "/root/mnt/basilisk/src/vof.h", 226, 
# 226 "/root/mnt/basilisk/src/vof.h" 3 4
                                                                                                 0
# 226 "/root/mnt/basilisk/src/vof.h"
                                                                                                 );
# 225 "/root/mnt/basilisk/src/vof.h"
stencil_val (point, c, 0, -2, 0, "/root/mnt/basilisk/src/vof.h", 225, 
# 225 "/root/mnt/basilisk/src/vof.h" 3 4
0
# 225 "/root/mnt/basilisk/src/vof.h"
);stencil_val (point, c, 0, -2, 0, "/root/mnt/basilisk/src/vof.h", 225, 
# 225 "/root/mnt/basilisk/src/vof.h" 3 4
                              0
# 225 "/root/mnt/basilisk/src/vof.h"
                              );stencil_val (point, c, 0, -2, 0, "/root/mnt/basilisk/src/vof.h", 225, 
# 225 "/root/mnt/basilisk/src/vof.h" 3 4
                                                             0
# 225 "/root/mnt/basilisk/src/vof.h"
                                                             );
# 234 "/root/mnt/basilisk/src/vof.h"
stencil_val_a (point, flux, 0, 0, 0, 
# 234 "/root/mnt/basilisk/src/vof.h" 3 4
0
# 234 "/root/mnt/basilisk/src/vof.h"
, "/root/mnt/basilisk/src/vof.h", 234);stencil_val (point, uf.y, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 234, 
# 234 "/root/mnt/basilisk/src/vof.h" 3 4
                          0
# 234 "/root/mnt/basilisk/src/vof.h"
                          );






    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {
      stencil_val (point, c, 0, -2, 0, "/root/mnt/basilisk/src/vof.h", 243, 
# 243 "/root/mnt/basilisk/src/vof.h" 3 4
     0
# 243 "/root/mnt/basilisk/src/vof.h"
     );


{ {
 stencil_val (point, gf, 0, -2, 0, "/root/mnt/basilisk/src/vof.h", 247, 
# 247 "/root/mnt/basilisk/src/vof.h" 3 4
0
# 247 "/root/mnt/basilisk/src/vof.h"
);stencil_val (point, t, 0, -2, 0, "/root/mnt/basilisk/src/vof.h", 247, 
# 247 "/root/mnt/basilisk/src/vof.h" 3 4
                               0
# 247 "/root/mnt/basilisk/src/vof.h"
                               );
 stencil_val_a (point, tflux, 0, 0, 0, 
# 248 "/root/mnt/basilisk/src/vof.h" 3 4
0
# 248 "/root/mnt/basilisk/src/vof.h"
, "/root/mnt/basilisk/src/vof.h", 248);stencil_val (point, uf.y, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 248, 
# 248 "/root/mnt/basilisk/src/vof.h" 3 4
                            0
# 248 "/root/mnt/basilisk/src/vof.h"
                            );
      }

{stencil_val_a (point, tflux, 0, 0, 0, 
# 251 "/root/mnt/basilisk/src/vof.h" 3 4
0
# 251 "/root/mnt/basilisk/src/vof.h"
, "/root/mnt/basilisk/src/vof.h", 251); }}
# 252 "/root/mnt/basilisk/src/vof.h"
}}}
  }}}end_stencil (&_loop); _loop.first = 0;};
# 195 "/root/mnt/basilisk/src/vof.h"
if(!((fm.y).i >= 65536) && !((cm).i >= 65536)){


{
# 195 "/root/mnt/basilisk/src/vof.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{ {






    double un = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.y.i)]*dt/(Delta*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)] + 0.), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;







    if (un*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)]*s/(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(cm.i)] + 0.) > cfl)
      cfl = un*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)]*s/(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(cm.i)] + 0.);
# 225 "/root/mnt/basilisk/src/vof.h"
    double cf = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(c.i)] <= 0. || ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(c.i)] >= 1.) ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(c.i)] :
      rectangle_fraction ((coord){-s*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(n.y.i)], ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(n.x.i)], _val_higher_dimension}, ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(alpha.i)],
     (coord){-0.5, -0.5, -0.5},
     (coord){s*un - 0.5, 0.5, 0.5});





    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(flux.i)] = cf*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.y.i)];






    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {
      double cf1 = cf, ci = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(c.i)];
      if (_attribute[t.i].inverse)
 cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
 double ff = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(t.i)]/ci + s*((1.) < (1. - s*un) ? (1.) : (1. - s*un))*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(gf.i)]*Delta/2.;
 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(tflux.i)] = ff*cf1*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.y.i)];
      }
      else
 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(tflux.i)] = 0.;
    }}}
  }}}}} } };;


}
# 253 "/root/mnt/basilisk/src/vof.h"
}else if(((fm.y).i >= 65536) && !((cm).i >= 65536)){struct{double x,y;}_const_fm={_constant[fm.y.i-65536],_constant[fm.x.i-65536]};(void)(_const_fm);



{
# 195 "/root/mnt/basilisk/src/vof.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{ {






    double un = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.y.i)]*dt/(Delta*_const_fm.y + 0.), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;







    if (un*_const_fm.y*s/(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(cm.i)] + 0.) > cfl)
      cfl = un*_const_fm.y*s/(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(cm.i)] + 0.);
# 225 "/root/mnt/basilisk/src/vof.h"
    double cf = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(c.i)] <= 0. || ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(c.i)] >= 1.) ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(c.i)] :
      rectangle_fraction ((coord){-s*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(n.y.i)], ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(n.x.i)], _val_higher_dimension}, ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(alpha.i)],
     (coord){-0.5, -0.5, -0.5},
     (coord){s*un - 0.5, 0.5, 0.5});





    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(flux.i)] = cf*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.y.i)];






    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {
      double cf1 = cf, ci = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(c.i)];
      if (_attribute[t.i].inverse)
 cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
 double ff = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(t.i)]/ci + s*((1.) < (1. - s*un) ? (1.) : (1. - s*un))*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(gf.i)]*Delta/2.;
 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(tflux.i)] = ff*cf1*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.y.i)];
      }
      else
 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(tflux.i)] = 0.;
    }}}
  }}}}} } };;


}
# 253 "/root/mnt/basilisk/src/vof.h"
}else if(!((fm.y).i >= 65536) && ((cm).i >= 65536)){double _const_cm=_constant[cm.i-65536];(void)(_const_cm);



{
# 195 "/root/mnt/basilisk/src/vof.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{ {






    double un = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.y.i)]*dt/(Delta*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)] + 0.), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;







    if (un*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)]*s/(_const_cm + 0.) > cfl)
      cfl = un*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)]*s/(_const_cm + 0.);
# 225 "/root/mnt/basilisk/src/vof.h"
    double cf = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(c.i)] <= 0. || ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(c.i)] >= 1.) ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(c.i)] :
      rectangle_fraction ((coord){-s*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(n.y.i)], ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(n.x.i)], _val_higher_dimension}, ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(alpha.i)],
     (coord){-0.5, -0.5, -0.5},
     (coord){s*un - 0.5, 0.5, 0.5});





    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(flux.i)] = cf*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.y.i)];






    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {
      double cf1 = cf, ci = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(c.i)];
      if (_attribute[t.i].inverse)
 cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
 double ff = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(t.i)]/ci + s*((1.) < (1. - s*un) ? (1.) : (1. - s*un))*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(gf.i)]*Delta/2.;
 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(tflux.i)] = ff*cf1*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.y.i)];
      }
      else
 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(tflux.i)] = 0.;
    }}}
  }}}}} } };;


}
# 253 "/root/mnt/basilisk/src/vof.h"
}else {struct{double x,y;}_const_fm={_constant[fm.y.i-65536],_constant[fm.x.i-65536]};(void)(_const_fm);double _const_cm=_constant[cm.i-65536];(void)(_const_cm);



{
# 195 "/root/mnt/basilisk/src/vof.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{ {






    double un = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.y.i)]*dt/(Delta*_const_fm.y + 0.), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;







    if (un*_const_fm.y*s/(_const_cm + 0.) > cfl)
      cfl = un*_const_fm.y*s/(_const_cm + 0.);
# 225 "/root/mnt/basilisk/src/vof.h"
    double cf = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(c.i)] <= 0. || ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(c.i)] >= 1.) ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(c.i)] :
      rectangle_fraction ((coord){-s*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(n.y.i)], ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(n.x.i)], _val_higher_dimension}, ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(alpha.i)],
     (coord){-0.5, -0.5, -0.5},
     (coord){s*un - 0.5, 0.5, 0.5});





    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(flux.i)] = cf*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.y.i)];






    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {
      double cf1 = cf, ci = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(c.i)];
      if (_attribute[t.i].inverse)
 cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
 double ff = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(t.i)]/ci + s*((1.) < (1. - s*un) ? (1.) : (1. - s*un))*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(gf.i)]*Delta/2.;
 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(tflux.i)] = ff*cf1*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.y.i)];
      }
      else
 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(tflux.i)] = 0.;
    }}}
  }}}}} } };;


}
# 253 "/root/mnt/basilisk/src/vof.h"
}
  delete (gfl); free(gfl);




  if (cfl > 0.5 + 1e-6)
    fprintf (
# 260 "/root/mnt/basilisk/src/vof.h" 3
            stderr
# 260 "/root/mnt/basilisk/src/vof.h"
                ,
      "WARNING: CFL must be <= 0.5 for VOF (cfl - 0.5 = %g)\n",
      cfl - 0.5), fflush (
# 262 "/root/mnt/basilisk/src/vof.h" 3
                         stderr
# 262 "/root/mnt/basilisk/src/vof.h"
                             );
# 282 "/root/mnt/basilisk/src/vof.h"
  { static ForeachData _loop = { "/root/mnt/basilisk/src/vof.h", 282, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 282 "/root/mnt/basilisk/src/vof.h" 3 4
 0
# 282 "/root/mnt/basilisk/src/vof.h"
 ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point); {
    stencil_val_a (point, c, 0, 0, 0, 
# 283 "/root/mnt/basilisk/src/vof.h" 3 4
   1
# 283 "/root/mnt/basilisk/src/vof.h"
   , "/root/mnt/basilisk/src/vof.h", 283);stencil_val (point, flux, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 283, 
# 283 "/root/mnt/basilisk/src/vof.h" 3 4
                           0
# 283 "/root/mnt/basilisk/src/vof.h"
                           ); stencil_val (point, flux, 0, 1, 0, "/root/mnt/basilisk/src/vof.h", 283, 
# 283 "/root/mnt/basilisk/src/vof.h" 3 4
                                                     0
# 283 "/root/mnt/basilisk/src/vof.h"
                                                     ); stencil_val (point, cc, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 283, 
# 283 "/root/mnt/basilisk/src/vof.h" 3 4
                                                                               0
# 283 "/root/mnt/basilisk/src/vof.h"
                                                                               );stencil_val (point, uf.y, 0, 1, 0, "/root/mnt/basilisk/src/vof.h", 283, 
# 283 "/root/mnt/basilisk/src/vof.h" 3 4
                                                                                                      0
# 283 "/root/mnt/basilisk/src/vof.h"
                                                                                                      ); stencil_val (point, uf.y, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 283, 
# 283 "/root/mnt/basilisk/src/vof.h" 3 4
                                                                                                                                0
# 283 "/root/mnt/basilisk/src/vof.h"
                                                                                                                                );stencil_val (point, cm, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 283, 
# 283 "/root/mnt/basilisk/src/vof.h" 3 4
                                                                                                                                                         0
# 283 "/root/mnt/basilisk/src/vof.h"
                                                                                                                                                         );
    scalar t, tc, tflux;
    {scalar*_i0= tfluxl;scalar*_i1= tcl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,tc=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,tc=*++_i1,t=*++_i2){
      {stencil_val_a (point, t, 0, 0, 0, 
# 286 "/root/mnt/basilisk/src/vof.h" 3 4
      1
# 286 "/root/mnt/basilisk/src/vof.h"
      , "/root/mnt/basilisk/src/vof.h", 286);stencil_val (point, tflux, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 286, 
# 286 "/root/mnt/basilisk/src/vof.h" 3 4
                              0
# 286 "/root/mnt/basilisk/src/vof.h"
                              ); stencil_val (point, tflux, 0, 1, 0, "/root/mnt/basilisk/src/vof.h", 286, 
# 286 "/root/mnt/basilisk/src/vof.h" 3 4
                                                         0
# 286 "/root/mnt/basilisk/src/vof.h"
                                                         ); stencil_val (point, tc, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 286, 
# 286 "/root/mnt/basilisk/src/vof.h" 3 4
                                                                                    0
# 286 "/root/mnt/basilisk/src/vof.h"
                                                                                    );stencil_val (point, uf.y, 0, 1, 0, "/root/mnt/basilisk/src/vof.h", 286, 
# 286 "/root/mnt/basilisk/src/vof.h" 3 4
                                                                                                           0
# 286 "/root/mnt/basilisk/src/vof.h"
                                                                                                           ); stencil_val (point, uf.y, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 286, 
# 286 "/root/mnt/basilisk/src/vof.h" 3 4
                                                                                                                                     0
# 286 "/root/mnt/basilisk/src/vof.h"
                                                                                                                                     );stencil_val (point, cm, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 286, 
# 286 "/root/mnt/basilisk/src/vof.h" 3 4
                                                                                                                                                              0
# 286 "/root/mnt/basilisk/src/vof.h"
                                                                                                                                                              ); }}}
  }end_stencil (&_loop); _loop.first = 0;};
# 282 "/root/mnt/basilisk/src/vof.h"
  if(!((cm).i >= 65536)){{{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(c.i)] += dt*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(flux.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(flux.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(cc.i)]*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(uf.y.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.y.i)]))/(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(cm.i)]*Delta);
    scalar t, tc, tflux;
    {scalar*_i0= tfluxl;scalar*_i1= tcl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,tc=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,tc=*++_i1,t=*++_i2){
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(t.i)] += dt*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(tflux.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(tflux.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(tc.i)]*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(uf.y.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.y.i)]))/(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(cm.i)]*Delta);}}
  }} } };}}else {double _const_cm=_constant[cm.i-65536];(void)(_const_cm);
# 282 "/root/mnt/basilisk/src/vof.h"
  {{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(c.i)] += dt*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(flux.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(flux.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(cc.i)]*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(uf.y.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.y.i)]))/(_const_cm*Delta);
    scalar t, tc, tflux;
    {scalar*_i0= tfluxl;scalar*_i1= tcl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,tc=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,tc=*++_i1,t=*++_i2){
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(t.i)] += dt*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(tflux.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(tflux.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(tc.i)]*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(uf.y.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(uf.y.i)]))/(_const_cm*Delta);}}
  }} } };}}
# 305 "/root/mnt/basilisk/src/vof.h"
  delete (tfluxl); free(tfluxl);delete((scalar*)((scalar[]){flux,alpha,n.x,n.y,{-1}}));
}






void vof_advection (scalar * interfaces, int i)
{
  {scalar*_i=(scalar*)( interfaces);if(_i)for(scalar c=*_i;(&c)->i>=0;c=*++_i){ {
# 325 "/root/mnt/basilisk/src/vof.h"
    scalar cc=new_scalar("cc"), * tcl = 
# 325 "/root/mnt/basilisk/src/vof.h" 3 4
                                        ((void *)0)
# 325 "/root/mnt/basilisk/src/vof.h"
                                            , * tracers = _attribute[c.i].tracers;
    {scalar*_i=(scalar*)( tracers);if(_i)for(scalar t=*_i;(&t)->i>=0;t=*++_i){ {
      scalar tc = new_scalar("tc");
      tcl = list_append (tcl, tc);

      if (_attribute[t.i].refine != vof_concentration_refine) {
 _attribute[t.i].refine = _attribute[t.i].prolongation = vof_concentration_refine;
 _attribute[t.i].restriction = restriction_volume_average;
 _attribute[t.i].dirty = 
# 333 "/root/mnt/basilisk/src/vof.h" 3 4
                        1
# 333 "/root/mnt/basilisk/src/vof.h"
                            ;
 _attribute[t.i].c = c;
      }

    }}}
    { static ForeachData _loop = { "/root/mnt/basilisk/src/vof.h", 338, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 338 "/root/mnt/basilisk/src/vof.h" 3 4
   0
# 338 "/root/mnt/basilisk/src/vof.h"
   ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point); {
      stencil_val_a (point, cc, 0, 0, 0, 
# 339 "/root/mnt/basilisk/src/vof.h" 3 4
     0
# 339 "/root/mnt/basilisk/src/vof.h"
     , "/root/mnt/basilisk/src/vof.h", 339);stencil_val (point, c, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 339, 
# 339 "/root/mnt/basilisk/src/vof.h" 3 4
                              0
# 339 "/root/mnt/basilisk/src/vof.h"
                              );
      scalar t, tc;
      {scalar*_i0= tcl;scalar*_i1= tracers;if(_i0)for(tc=*_i0,t=*_i1;_i0->i>= 0;tc=*++_i0,t=*++_i1){ {
 if (_attribute[t.i].inverse)
   {stencil_val_a (point, tc, 0, 0, 0, 
# 343 "/root/mnt/basilisk/src/vof.h" 3 4
   0
# 343 "/root/mnt/basilisk/src/vof.h"
   , "/root/mnt/basilisk/src/vof.h", 343); stencil_val (point, c, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 343, 
# 343 "/root/mnt/basilisk/src/vof.h" 3 4
                             0
# 343 "/root/mnt/basilisk/src/vof.h"
                             ); stencil_val (point, t, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 343, 
# 343 "/root/mnt/basilisk/src/vof.h" 3 4
                                                    0
# 343 "/root/mnt/basilisk/src/vof.h"
                                                    ); stencil_val (point, c, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 343, 
# 343 "/root/mnt/basilisk/src/vof.h" 3 4
                                                                           0
# 343 "/root/mnt/basilisk/src/vof.h"
                                                                           ); }
 else
   {stencil_val_a (point, tc, 0, 0, 0, 
# 345 "/root/mnt/basilisk/src/vof.h" 3 4
   0
# 345 "/root/mnt/basilisk/src/vof.h"
   , "/root/mnt/basilisk/src/vof.h", 345); stencil_val (point, c, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 345, 
# 345 "/root/mnt/basilisk/src/vof.h" 3 4
                             0
# 345 "/root/mnt/basilisk/src/vof.h"
                             ); stencil_val (point, t, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 345, 
# 345 "/root/mnt/basilisk/src/vof.h" 3 4
                                                    0
# 345 "/root/mnt/basilisk/src/vof.h"
                                                    );stencil_val (point, c, 0, 0, 0, "/root/mnt/basilisk/src/vof.h", 345, 
# 345 "/root/mnt/basilisk/src/vof.h" 3 4
                                                                          0
# 345 "/root/mnt/basilisk/src/vof.h"
                                                                          ); }
      }}}
    }end_stencil (&_loop); _loop.first = 0;};
    {
# 338 "/root/mnt/basilisk/src/vof.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(cc.i)] = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(c.i)] > 0.5);
      scalar t, tc;
      {scalar*_i0= tcl;scalar*_i1= tracers;if(_i0)for(tc=*_i0,t=*_i1;_i0->i>= 0;tc=*++_i0,t=*++_i1){ {
 if (_attribute[t.i].inverse)
   ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(tc.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(c.i)] < 0.5 ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(t.i)]/(1. - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(c.i)]) : 0.;
 else
   ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(tc.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(c.i)] > 0.5 ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(t.i)]/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(c.i)] : 0.;
      }}}
    }} } };}






    void (* sweep[2]) (scalar, scalar, scalar *);
    int d = 0;

      sweep[d++] = sweep_x;
# 357 "/root/mnt/basilisk/src/vof.h"
sweep[d++] = sweep_y;
    for (d = 0; d < 2; d++)
      sweep[(i + d) % 2] (c, cc, tcl);
    delete (tcl), free(tcl);delete((scalar*)((scalar[]){cc,{-1}}));
  }}}
}

static int vof_0_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;} static int vof_0(const int i,const double t,Event *_ev){;
  vof_advection (interfaces, i);{;return 0;};}
# 14 "/root/mnt/basilisk/src/two-phase.h"

scalar f={8}, * interfaces = ((scalar[]){{8},{-1}});
double rho1 = 1., mu1 = 0., rho2 = 1., mu2 = 0.;





vector alphav={{9},{10}};
scalar rhov={11};

static int defaults_3_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i = 0);*ip=i;*tp=t;return ret;} static int defaults_3(const int i,const double t,Event *_ev){; {
  alpha = alphav;
  rho = rhov;





  if (mu1 || mu2)
    mu = new_face_vector("mu");




  display ((struct _display){"draw_vof (c = 'f');"});
}{;return 0;};}
# 64 "/root/mnt/basilisk/src/two-phase.h"
static int tracer_advection_0_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;} static int tracer_advection_0(const int i,const double t,Event *_ev){;
{
# 90 "/root/mnt/basilisk/src/two-phase.h"
  _attribute[f.i].prolongation = refine_bilinear;
  _attribute[f.i].dirty = 
# 91 "/root/mnt/basilisk/src/two-phase.h" 3 4
                         1
# 91 "/root/mnt/basilisk/src/two-phase.h"
                             ;

}{;return 0;};}

static int properties_0_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;} static int properties_0(const int i,const double t,Event *_ev){;
{
  { static ForeachData _loop = { "/root/mnt/basilisk/src/two-phase.h", 97, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 97 "/root/mnt/basilisk/src/two-phase.h" 3 4
 0
# 97 "/root/mnt/basilisk/src/two-phase.h"
 ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point);{{ _loop.face |= (1 << 0);{ {
     stencil_val (point, f, -1, 0, 0, "/root/mnt/basilisk/src/two-phase.h", 98, 
# 98 "/root/mnt/basilisk/src/two-phase.h" 3 4
    0
# 98 "/root/mnt/basilisk/src/two-phase.h"
    );stencil_val (point, f, 0, 0, 0, "/root/mnt/basilisk/src/two-phase.h", 98, 
# 98 "/root/mnt/basilisk/src/two-phase.h" 3 4
                           0
# 98 "/root/mnt/basilisk/src/two-phase.h"
                           );
    stencil_val_a (point, alphav.x, 0, 0, 0, 
# 99 "/root/mnt/basilisk/src/two-phase.h" 3 4
   0
# 99 "/root/mnt/basilisk/src/two-phase.h"
   , "/root/mnt/basilisk/src/two-phase.h", 99); stencil_val (point, fm.x, 0, 0, 0, "/root/mnt/basilisk/src/two-phase.h", 99, 
# 99 "/root/mnt/basilisk/src/two-phase.h" 3 4
                                   0
# 99 "/root/mnt/basilisk/src/two-phase.h"
                                   );
    if (mu1 || mu2) {
      vector muv = mu;
      stencil_val_a (point, muv.x, 0, 0, 0, 
# 102 "/root/mnt/basilisk/src/two-phase.h" 3 4
     0
# 102 "/root/mnt/basilisk/src/two-phase.h"
     , "/root/mnt/basilisk/src/two-phase.h", 102); stencil_val (point, fm.x, 0, 0, 0, "/root/mnt/basilisk/src/two-phase.h", 102, 
# 102 "/root/mnt/basilisk/src/two-phase.h" 3 4
                                  0
# 102 "/root/mnt/basilisk/src/two-phase.h"
                                  );
    }
  }}}
# 97 "/root/mnt/basilisk/src/two-phase.h"
{ _loop.face |= (1 << 1);{ {
     stencil_val (point, f, 0, -1, 0, "/root/mnt/basilisk/src/two-phase.h", 98, 
# 98 "/root/mnt/basilisk/src/two-phase.h" 3 4
    0
# 98 "/root/mnt/basilisk/src/two-phase.h"
    );stencil_val (point, f, 0, 0, 0, "/root/mnt/basilisk/src/two-phase.h", 98, 
# 98 "/root/mnt/basilisk/src/two-phase.h" 3 4
                           0
# 98 "/root/mnt/basilisk/src/two-phase.h"
                           );
    stencil_val_a (point, alphav.y, 0, 0, 0, 
# 99 "/root/mnt/basilisk/src/two-phase.h" 3 4
   0
# 99 "/root/mnt/basilisk/src/two-phase.h"
   , "/root/mnt/basilisk/src/two-phase.h", 99); stencil_val (point, fm.y, 0, 0, 0, "/root/mnt/basilisk/src/two-phase.h", 99, 
# 99 "/root/mnt/basilisk/src/two-phase.h" 3 4
                                   0
# 99 "/root/mnt/basilisk/src/two-phase.h"
                                   );
    if (mu1 || mu2) {
      vector muv = mu;
      stencil_val_a (point, muv.y, 0, 0, 0, 
# 102 "/root/mnt/basilisk/src/two-phase.h" 3 4
     0
# 102 "/root/mnt/basilisk/src/two-phase.h"
     , "/root/mnt/basilisk/src/two-phase.h", 102); stencil_val (point, fm.y, 0, 0, 0, "/root/mnt/basilisk/src/two-phase.h", 102, 
# 102 "/root/mnt/basilisk/src/two-phase.h" 3 4
                                  0
# 102 "/root/mnt/basilisk/src/two-phase.h"
                                  );
    }
  }}}}end_stencil (&_loop); _loop.first = 0;};
# 97 "/root/mnt/basilisk/src/two-phase.h"
if(!((fm.x).i >= 65536)){{{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{ {
    double ff = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(f.i)])/2.;
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alphav.x.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)]/(((ff) < (0.) ? (0.) : (ff) > (1.) ? (1.) : (ff))*(rho1 - rho2) + rho2);
    if (mu1 || mu2) {
      vector muv = mu;
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(muv.x.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)]*(((ff) < (0.) ? (0.) : (ff) > (1.) ? (1.) : (ff))*(mu1 - mu2) + mu2);
    }
  }}}}
# 97 "/root/mnt/basilisk/src/two-phase.h"
{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{ {
    double ff = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(f.i)])/2.;
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alphav.y.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)]/(((ff) < (0.) ? (0.) : (ff) > (1.) ? (1.) : (ff))*(rho1 - rho2) + rho2);
    if (mu1 || mu2) {
      vector muv = mu;
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(muv.y.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)]*(((ff) < (0.) ? (0.) : (ff) > (1.) ? (1.) : (ff))*(mu1 - mu2) + mu2);
    }
  }}}}}} } };}}else {struct{double x,y;}_const_fm={_constant[fm.x.i-65536],_constant[fm.y.i-65536]};(void)(_const_fm);
  {
# 97 "/root/mnt/basilisk/src/two-phase.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{ {
    double ff = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(f.i)])/2.;
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alphav.x.i)] = _const_fm.x/(((ff) < (0.) ? (0.) : (ff) > (1.) ? (1.) : (ff))*(rho1 - rho2) + rho2);
    if (mu1 || mu2) {
      vector muv = mu;
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(muv.x.i)] = _const_fm.x*(((ff) < (0.) ? (0.) : (ff) > (1.) ? (1.) : (ff))*(mu1 - mu2) + mu2);
    }
  }}}}
# 97 "/root/mnt/basilisk/src/two-phase.h"
{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{ {
    double ff = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(f.i)])/2.;
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alphav.y.i)] = _const_fm.y/(((ff) < (0.) ? (0.) : (ff) > (1.) ? (1.) : (ff))*(rho1 - rho2) + rho2);
    if (mu1 || mu2) {
      vector muv = mu;
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(muv.y.i)] = _const_fm.y*(((ff) < (0.) ? (0.) : (ff) > (1.) ? (1.) : (ff))*(mu1 - mu2) + mu2);
    }
  }}}}}} } };}}

  { static ForeachData _loop = { "/root/mnt/basilisk/src/two-phase.h", 106, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 106 "/root/mnt/basilisk/src/two-phase.h" 3 4
 0
# 106 "/root/mnt/basilisk/src/two-phase.h"
 ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point);
    {stencil_val_a (point, rhov, 0, 0, 0, 
# 107 "/root/mnt/basilisk/src/two-phase.h" 3 4
    0
# 107 "/root/mnt/basilisk/src/two-phase.h"
    , "/root/mnt/basilisk/src/two-phase.h", 107); stencil_val (point, cm, 0, 0, 0, "/root/mnt/basilisk/src/two-phase.h", 107, 
# 107 "/root/mnt/basilisk/src/two-phase.h" 3 4
                                0
# 107 "/root/mnt/basilisk/src/two-phase.h"
                                );stencil_val (point, f, 0, 0, 0, "/root/mnt/basilisk/src/two-phase.h", 107, 
# 107 "/root/mnt/basilisk/src/two-phase.h" 3 4
                                                       0
# 107 "/root/mnt/basilisk/src/two-phase.h"
                                                       ); }end_stencil (&_loop); _loop.first = 0;};
# 106 "/root/mnt/basilisk/src/two-phase.h"
if(!((cm).i >= 65536)){{{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(rhov.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(cm.i)]*(((((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)]) < (0.) ? (0.) : (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)]) > (1.) ? (1.) : (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)]))*(rho1 - rho2) + rho2);} } };}}else {double _const_cm=_constant[cm.i-65536];(void)(_const_cm);

  {
# 106 "/root/mnt/basilisk/src/two-phase.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(rhov.i)] = _const_cm*(((((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)]) < (0.) ? (0.) : (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)]) > (1.) ? (1.) : (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)]))*(rho1 - rho2) + rho2);} } };}}


  _attribute[f.i].prolongation = fraction_refine;
  _attribute[f.i].dirty = 
# 111 "/root/mnt/basilisk/src/two-phase.h" 3 4
                         1
# 111 "/root/mnt/basilisk/src/two-phase.h"
                             ;

}{;return 0;};}
# 20 "rising.c"
# 1 "tension.h"
# 1 "/root/mnt/basilisk/src/tension.h"
# 15 "/root/mnt/basilisk/src/tension.h"
# 1 "iforce.h"
# 1 "/root/mnt/basilisk/src/iforce.h"
# 20 "/root/mnt/basilisk/src/iforce.h"
# 28 "/root/mnt/basilisk/src/iforce.h"
static int defaults_4_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i = 0);*ip=i;*tp=t;return ret;}

      static int defaults_4(const int i,const double t,Event *_ev){; {
  if (((a.x).i >= 65536)) {
    a = new_face_vector("a");
    { static ForeachData _loop = { "/root/mnt/basilisk/src/iforce.h", 33, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 33 "/root/mnt/basilisk/src/iforce.h" 3 4
   0
# 33 "/root/mnt/basilisk/src/iforce.h"
   ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point);{{ _loop.face |= (1 << 0);{
      {stencil_val_a (point, a.x, 0, 0, 0, 
# 34 "/root/mnt/basilisk/src/iforce.h" 3 4
      0
# 34 "/root/mnt/basilisk/src/iforce.h"
      , "/root/mnt/basilisk/src/iforce.h", 34); }}}
# 33 "/root/mnt/basilisk/src/iforce.h"
{ _loop.face |= (1 << 1);{
      {stencil_val_a (point, a.y, 0, 0, 0, 
# 34 "/root/mnt/basilisk/src/iforce.h" 3 4
      0
# 34 "/root/mnt/basilisk/src/iforce.h"
      , "/root/mnt/basilisk/src/iforce.h", 34); }}}}end_stencil (&_loop); _loop.first = 0;};
# 33 "/root/mnt/basilisk/src/iforce.h"
if(!((a.x).i >= 65536)){{{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(a.x.i)] = 0.;}}}
# 33 "/root/mnt/basilisk/src/iforce.h"
{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(a.y.i)] = 0.;}}}}} } };}}else {struct{double x,y;}_const_a={_constant[a.x.i-65536],_constant[a.y.i-65536]};(void)(_const_a);
    {
# 33 "/root/mnt/basilisk/src/iforce.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{
      _const_a.x = 0.;}}}
# 33 "/root/mnt/basilisk/src/iforce.h"
{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{
      _const_a.y = 0.;}}}}} } };}}
  }
}{;return 0;};}






static int acceleration_0_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;} static int acceleration_0(const int i,const double t,Event *_ev){;
{





  scalar * list = 
# 50 "/root/mnt/basilisk/src/iforce.h" 3 4
                 ((void *)0)
# 50 "/root/mnt/basilisk/src/iforce.h"
                     ;
  {scalar*_i=(scalar*)( interfaces);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
    if (_attribute[f.i].phi.i) {
      list = list_add (list, f);






      { static ForeachData _loop = { "/root/mnt/basilisk/src/iforce.h", 60, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 60 "/root/mnt/basilisk/src/iforce.h" 3 4
     0
# 60 "/root/mnt/basilisk/src/iforce.h"
     ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point);
 {stencil_val_a (point, f, 0, 0, 0, 
# 61 "/root/mnt/basilisk/src/iforce.h" 3 4
 0
# 61 "/root/mnt/basilisk/src/iforce.h"
 , "/root/mnt/basilisk/src/iforce.h", 61);stencil_val (point, f, 0, 0, 0, "/root/mnt/basilisk/src/iforce.h", 61, 
# 61 "/root/mnt/basilisk/src/iforce.h" 3 4
                         0
# 61 "/root/mnt/basilisk/src/iforce.h"
                         ); }end_stencil (&_loop); _loop.first = 0;};






      {
# 60 "/root/mnt/basilisk/src/iforce.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)] = ((((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)]) < (0.) ? (0.) : (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)]) > (1.) ? (1.) : (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)]));} } };}
    }}}
# 72 "/root/mnt/basilisk/src/iforce.h"
  {scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){ {
    _attribute[f.i].prolongation = _attribute[p.i].prolongation;
    _attribute[f.i].dirty = 
# 74 "/root/mnt/basilisk/src/iforce.h" 3 4
                           1
# 74 "/root/mnt/basilisk/src/iforce.h"
                               ;
  }}}
# 86 "/root/mnt/basilisk/src/iforce.h"
  vector ia = a;
  { static ForeachData _loop = { "/root/mnt/basilisk/src/iforce.h", 87, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 87 "/root/mnt/basilisk/src/iforce.h" 3 4
 0
# 87 "/root/mnt/basilisk/src/iforce.h"
 ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point);{{ _loop.face |= (1 << 0);{
    {scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      {stencil_val (point, f, 0, 0, 0, "/root/mnt/basilisk/src/iforce.h", 89, 
# 89 "/root/mnt/basilisk/src/iforce.h" 3 4
      0
# 89 "/root/mnt/basilisk/src/iforce.h"
      ); stencil_val (point, f, -1, 0, 0, "/root/mnt/basilisk/src/iforce.h", 89, 
# 89 "/root/mnt/basilisk/src/iforce.h" 3 4
                             0
# 89 "/root/mnt/basilisk/src/iforce.h"
                             ); stencil_val (point, fm.x, 0, 0, 0, "/root/mnt/basilisk/src/iforce.h", 89, 
# 89 "/root/mnt/basilisk/src/iforce.h" 3 4
                                                     0
# 89 "/root/mnt/basilisk/src/iforce.h"
                                                     ); {
# 99 "/root/mnt/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;




stencil_val (point, phi, -1, 0, 0, "/root/mnt/basilisk/src/iforce.h", 104, 
# 104 "/root/mnt/basilisk/src/iforce.h" 3 4
0
# 104 "/root/mnt/basilisk/src/iforce.h"
);
# 104 "/root/mnt/basilisk/src/iforce.h"
stencil_val (point, phi, -1, 0, 0, "/root/mnt/basilisk/src/iforce.h", 104, 
# 104 "/root/mnt/basilisk/src/iforce.h" 3 4
0
# 104 "/root/mnt/basilisk/src/iforce.h"
);
# 103 "/root/mnt/basilisk/src/iforce.h"
stencil_val (point, phi, 0, 0, 0, "/root/mnt/basilisk/src/iforce.h", 103, 
# 103 "/root/mnt/basilisk/src/iforce.h" 3 4
0
# 103 "/root/mnt/basilisk/src/iforce.h"
);
# 103 "/root/mnt/basilisk/src/iforce.h"
stencil_val (point, phi, 0, 0, 0, "/root/mnt/basilisk/src/iforce.h", 103, 
# 103 "/root/mnt/basilisk/src/iforce.h" 3 4
0
# 103 "/root/mnt/basilisk/src/iforce.h"
);
# 102 "/root/mnt/basilisk/src/iforce.h"
stencil_val (point, phi, -1, 0, 0, "/root/mnt/basilisk/src/iforce.h", 102, 
# 102 "/root/mnt/basilisk/src/iforce.h" 3 4
0
# 102 "/root/mnt/basilisk/src/iforce.h"
);stencil_val (point, phi, 0, 0, 0, "/root/mnt/basilisk/src/iforce.h", 102, 
# 102 "/root/mnt/basilisk/src/iforce.h" 3 4
                        0
# 102 "/root/mnt/basilisk/src/iforce.h"
                        );
# 101 "/root/mnt/basilisk/src/iforce.h"
stencil_val (point, phi, -1, 0, 0, "/root/mnt/basilisk/src/iforce.h", 101, 
# 101 "/root/mnt/basilisk/src/iforce.h" 3 4
0
# 101 "/root/mnt/basilisk/src/iforce.h"
);stencil_val (point, phi, 0, 0, 0, "/root/mnt/basilisk/src/iforce.h", 101, 
# 101 "/root/mnt/basilisk/src/iforce.h" 3 4
                        0
# 101 "/root/mnt/basilisk/src/iforce.h"
                        );





stencil_val_a (point, ia.x, 0, 0, 0, 
# 107 "/root/mnt/basilisk/src/iforce.h" 3 4
1
# 107 "/root/mnt/basilisk/src/iforce.h"
, "/root/mnt/basilisk/src/iforce.h", 107); stencil_val (point, alpha.x, 0, 0, 0, "/root/mnt/basilisk/src/iforce.h", 107, 
# 107 "/root/mnt/basilisk/src/iforce.h" 3 4
                           0
# 107 "/root/mnt/basilisk/src/iforce.h"
                           );stencil_val (point, fm.x, 0, 0, 0, "/root/mnt/basilisk/src/iforce.h", 107, 
# 107 "/root/mnt/basilisk/src/iforce.h" 3 4
                                                       0
# 107 "/root/mnt/basilisk/src/iforce.h"
                                                       );stencil_val (point, f, 0, 0, 0, "/root/mnt/basilisk/src/iforce.h", 107, 
# 107 "/root/mnt/basilisk/src/iforce.h" 3 4
                                                                                0
# 107 "/root/mnt/basilisk/src/iforce.h"
                                                                                ); stencil_val (point, f, -1, 0, 0, "/root/mnt/basilisk/src/iforce.h", 107, 
# 107 "/root/mnt/basilisk/src/iforce.h" 3 4
                                                                                                       0
# 107 "/root/mnt/basilisk/src/iforce.h"
                                                                                                       );
      } }}}}}
# 87 "/root/mnt/basilisk/src/iforce.h"
{ _loop.face |= (1 << 1);{
    {scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      {stencil_val (point, f, 0, 0, 0, "/root/mnt/basilisk/src/iforce.h", 89, 
# 89 "/root/mnt/basilisk/src/iforce.h" 3 4
      0
# 89 "/root/mnt/basilisk/src/iforce.h"
      ); stencil_val (point, f, 0, -1, 0, "/root/mnt/basilisk/src/iforce.h", 89, 
# 89 "/root/mnt/basilisk/src/iforce.h" 3 4
                             0
# 89 "/root/mnt/basilisk/src/iforce.h"
                             ); stencil_val (point, fm.y, 0, 0, 0, "/root/mnt/basilisk/src/iforce.h", 89, 
# 89 "/root/mnt/basilisk/src/iforce.h" 3 4
                                                     0
# 89 "/root/mnt/basilisk/src/iforce.h"
                                                     ); {
# 99 "/root/mnt/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;




stencil_val (point, phi, 0, -1, 0, "/root/mnt/basilisk/src/iforce.h", 104, 
# 104 "/root/mnt/basilisk/src/iforce.h" 3 4
0
# 104 "/root/mnt/basilisk/src/iforce.h"
);
# 104 "/root/mnt/basilisk/src/iforce.h"
stencil_val (point, phi, 0, -1, 0, "/root/mnt/basilisk/src/iforce.h", 104, 
# 104 "/root/mnt/basilisk/src/iforce.h" 3 4
0
# 104 "/root/mnt/basilisk/src/iforce.h"
);
# 103 "/root/mnt/basilisk/src/iforce.h"
stencil_val (point, phi, 0, 0, 0, "/root/mnt/basilisk/src/iforce.h", 103, 
# 103 "/root/mnt/basilisk/src/iforce.h" 3 4
0
# 103 "/root/mnt/basilisk/src/iforce.h"
);
# 103 "/root/mnt/basilisk/src/iforce.h"
stencil_val (point, phi, 0, 0, 0, "/root/mnt/basilisk/src/iforce.h", 103, 
# 103 "/root/mnt/basilisk/src/iforce.h" 3 4
0
# 103 "/root/mnt/basilisk/src/iforce.h"
);
# 102 "/root/mnt/basilisk/src/iforce.h"
stencil_val (point, phi, 0, -1, 0, "/root/mnt/basilisk/src/iforce.h", 102, 
# 102 "/root/mnt/basilisk/src/iforce.h" 3 4
0
# 102 "/root/mnt/basilisk/src/iforce.h"
);stencil_val (point, phi, 0, 0, 0, "/root/mnt/basilisk/src/iforce.h", 102, 
# 102 "/root/mnt/basilisk/src/iforce.h" 3 4
                        0
# 102 "/root/mnt/basilisk/src/iforce.h"
                        );
# 101 "/root/mnt/basilisk/src/iforce.h"
stencil_val (point, phi, 0, -1, 0, "/root/mnt/basilisk/src/iforce.h", 101, 
# 101 "/root/mnt/basilisk/src/iforce.h" 3 4
0
# 101 "/root/mnt/basilisk/src/iforce.h"
);stencil_val (point, phi, 0, 0, 0, "/root/mnt/basilisk/src/iforce.h", 101, 
# 101 "/root/mnt/basilisk/src/iforce.h" 3 4
                        0
# 101 "/root/mnt/basilisk/src/iforce.h"
                        );





stencil_val_a (point, ia.y, 0, 0, 0, 
# 107 "/root/mnt/basilisk/src/iforce.h" 3 4
1
# 107 "/root/mnt/basilisk/src/iforce.h"
, "/root/mnt/basilisk/src/iforce.h", 107); stencil_val (point, alpha.y, 0, 0, 0, "/root/mnt/basilisk/src/iforce.h", 107, 
# 107 "/root/mnt/basilisk/src/iforce.h" 3 4
                           0
# 107 "/root/mnt/basilisk/src/iforce.h"
                           );stencil_val (point, fm.y, 0, 0, 0, "/root/mnt/basilisk/src/iforce.h", 107, 
# 107 "/root/mnt/basilisk/src/iforce.h" 3 4
                                                       0
# 107 "/root/mnt/basilisk/src/iforce.h"
                                                       );stencil_val (point, f, 0, 0, 0, "/root/mnt/basilisk/src/iforce.h", 107, 
# 107 "/root/mnt/basilisk/src/iforce.h" 3 4
                                                                                0
# 107 "/root/mnt/basilisk/src/iforce.h"
                                                                                ); stencil_val (point, f, 0, -1, 0, "/root/mnt/basilisk/src/iforce.h", 107, 
# 107 "/root/mnt/basilisk/src/iforce.h" 3 4
                                                                                                       0
# 107 "/root/mnt/basilisk/src/iforce.h"
                                                                                                       );
      } }}}}}}end_stencil (&_loop); _loop.first = 0;};
# 87 "/root/mnt/basilisk/src/iforce.h"
if(!((fm.x).i >= 65536) && !((alpha.x).i >= 65536)){{{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{
    {scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)] != ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(f.i)] && ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)] > 0.) {
# 99 "/root/mnt/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;
 double phif =
   (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(phi.i)] < ((double)1e30) && ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(phi.i)] < ((double)1e30)) ?
   (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(phi.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(phi.i)])/2. :
   ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(phi.i)] < ((double)1e30) ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(phi.i)] :
   ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(phi.i)] < ((double)1e30) ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(phi.i)] :
   0.;

 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(ia.x.i)] += ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.x.i)]/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)]*phif*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(f.i)])/Delta;
      }}}}}}
# 87 "/root/mnt/basilisk/src/iforce.h"
{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{
    {scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)] != ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(f.i)] && ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)] > 0.) {
# 99 "/root/mnt/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;
 double phif =
   (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(phi.i)] < ((double)1e30) && ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(phi.i)] < ((double)1e30)) ?
   (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(phi.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(phi.i)])/2. :
   ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(phi.i)] < ((double)1e30) ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(phi.i)] :
   ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(phi.i)] < ((double)1e30) ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(phi.i)] :
   0.;

 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(ia.y.i)] += ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.y.i)]/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)]*phif*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(f.i)])/Delta;
      }}}}}}}} } };}}else if(((fm.x).i >= 65536) && !((alpha.x).i >= 65536)){struct{double x,y;}_const_fm={_constant[fm.x.i-65536],_constant[fm.y.i-65536]};(void)(_const_fm);
  {
# 87 "/root/mnt/basilisk/src/iforce.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{
    {scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)] != ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(f.i)] && _const_fm.x > 0.) {
# 99 "/root/mnt/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;
 double phif =
   (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(phi.i)] < ((double)1e30) && ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(phi.i)] < ((double)1e30)) ?
   (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(phi.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(phi.i)])/2. :
   ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(phi.i)] < ((double)1e30) ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(phi.i)] :
   ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(phi.i)] < ((double)1e30) ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(phi.i)] :
   0.;

 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(ia.x.i)] += ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.x.i)]/_const_fm.x*phif*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(f.i)])/Delta;
      }}}}}}
# 87 "/root/mnt/basilisk/src/iforce.h"
{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{
    {scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)] != ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(f.i)] && _const_fm.y > 0.) {
# 99 "/root/mnt/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;
 double phif =
   (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(phi.i)] < ((double)1e30) && ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(phi.i)] < ((double)1e30)) ?
   (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(phi.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(phi.i)])/2. :
   ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(phi.i)] < ((double)1e30) ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(phi.i)] :
   ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(phi.i)] < ((double)1e30) ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(phi.i)] :
   0.;

 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(ia.y.i)] += ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.y.i)]/_const_fm.y*phif*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(f.i)])/Delta;
      }}}}}}}} } };}}else if(!((fm.x).i >= 65536) && ((alpha.x).i >= 65536)){struct{double x,y;}_const_alpha={_constant[alpha.x.i-65536],_constant[alpha.y.i-65536]};(void)(_const_alpha);
  {
# 87 "/root/mnt/basilisk/src/iforce.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{
    {scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)] != ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(f.i)] && ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)] > 0.) {
# 99 "/root/mnt/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;
 double phif =
   (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(phi.i)] < ((double)1e30) && ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(phi.i)] < ((double)1e30)) ?
   (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(phi.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(phi.i)])/2. :
   ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(phi.i)] < ((double)1e30) ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(phi.i)] :
   ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(phi.i)] < ((double)1e30) ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(phi.i)] :
   0.;

 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(ia.x.i)] += _const_alpha.x/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)]*phif*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(f.i)])/Delta;
      }}}}}}
# 87 "/root/mnt/basilisk/src/iforce.h"
{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{
    {scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)] != ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(f.i)] && ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)] > 0.) {
# 99 "/root/mnt/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;
 double phif =
   (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(phi.i)] < ((double)1e30) && ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(phi.i)] < ((double)1e30)) ?
   (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(phi.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(phi.i)])/2. :
   ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(phi.i)] < ((double)1e30) ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(phi.i)] :
   ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(phi.i)] < ((double)1e30) ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(phi.i)] :
   0.;

 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(ia.y.i)] += _const_alpha.y/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)]*phif*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(f.i)])/Delta;
      }}}}}}}} } };}}else {struct{double x,y;}_const_fm={_constant[fm.x.i-65536],_constant[fm.y.i-65536]};(void)(_const_fm);struct{double x,y;}_const_alpha={_constant[alpha.x.i-65536],_constant[alpha.y.i-65536]};(void)(_const_alpha);
  {
# 87 "/root/mnt/basilisk/src/iforce.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{
    {scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)] != ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(f.i)] && _const_fm.x > 0.) {
# 99 "/root/mnt/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;
 double phif =
   (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(phi.i)] < ((double)1e30) && ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(phi.i)] < ((double)1e30)) ?
   (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(phi.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(phi.i)])/2. :
   ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(phi.i)] < ((double)1e30) ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(phi.i)] :
   ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(phi.i)] < ((double)1e30) ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(phi.i)] :
   0.;

 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(ia.x.i)] += _const_alpha.x/_const_fm.x*phif*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(f.i)])/Delta;
      }}}}}}
# 87 "/root/mnt/basilisk/src/iforce.h"
{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{
    {scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)] != ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(f.i)] && _const_fm.y > 0.) {
# 99 "/root/mnt/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;
 double phif =
   (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(phi.i)] < ((double)1e30) && ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(phi.i)] < ((double)1e30)) ?
   (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(phi.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(phi.i)])/2. :
   ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(phi.i)] < ((double)1e30) ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(phi.i)] :
   ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(phi.i)] < ((double)1e30) ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(phi.i)] :
   0.;

 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(ia.y.i)] += _const_alpha.y/_const_fm.y*phif*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(f.i)])/Delta;
      }}}}}}}} } };}}






  {scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){ {
    _attribute[f.i].prolongation = fraction_refine;
    _attribute[f.i].dirty = 
# 117 "/root/mnt/basilisk/src/iforce.h" 3 4
                           1
# 117 "/root/mnt/basilisk/src/iforce.h"
                               ;
  }}}






  {scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){ {
    scalar phi = _attribute[f.i].phi;
    delete (((scalar[]){phi,{-1}}));
    _attribute[f.i].phi.i = 0;
  }}}
  free(list);
}{;return 0;};}
# 16 "/root/mnt/basilisk/src/tension.h"
# 1 "curvature.h"
# 1 "/root/mnt/basilisk/src/curvature.h"
# 12 "/root/mnt/basilisk/src/curvature.h"
static void curvature_restriction (Point point, scalar kappa)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  double k = 0., s = 0.;
  {{ int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(kappa.i)] != ((double)1e30))
      k += ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(kappa.i)], s++;} } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}}
  ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(kappa.i)] = s ? k/s : ((double)1e30);
}







static void curvature_prolongation (Point point, scalar kappa)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  {{ int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
    double sk = 0., s = 0.;
    for (int i = 0; i <= 1; i++)

      for (int j = 0; j <= 1; j++)




   if (((double *) ((((((Tree *)grid)->L[point.level-1]->m)->b[(point.i+2)/2+child.x*i][(point.j+2)/2+child.y*j]) ) + sizeof(Cell)))[(kappa.i)] != ((double)1e30))
     sk += ((double *) ((((((Tree *)grid)->L[point.level-1]->m)->b[(point.i+2)/2+child.x*i][(point.j+2)/2+child.y*j]) ) + sizeof(Cell)))[(kappa.i)], s++;
    ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(kappa.i)] = s ? sk/s : ((double)1e30);
  }} } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}}
}
# 66 "/root/mnt/basilisk/src/curvature.h"
# 1 "heights.h"
# 1 "/root/mnt/basilisk/src/heights.h"
# 29 "/root/mnt/basilisk/src/heights.h"
static inline double height (double H) {
  return H > 20./2. ? H - 20. : H < -20./2. ? H + 20. : H;
}

static inline int orientation (double H) {
  return fabs(H) > 20./2.;
}
# 49 "/root/mnt/basilisk/src/heights.h"
static void half_column (Point point, scalar c, vector h, vector cs, int j)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;






  const int complete = -1;

   {







    double S = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(c.i)], H = S, ci, a;







    typedef struct { int s; double h; } HState;
    HState state = {0, 0};
    if (j == 1) {




      if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.x.i)] == 300.)
 state.s = complete, state.h = ((double)1e30);




      else {
 int s = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.x.i)] + 20./2.)/100.;
 state.h = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.x.i)] - 100.*s;
 state.s = s - 1;
      }





      if (state.s != complete)
 S = state.s, H = state.h;
    }
# 109 "/root/mnt/basilisk/src/heights.h"
    for (int i = 1; i <= 4; i++) {
      ci = i <= 2 ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i*j][point.j+0]) ) + sizeof(Cell)))[(c.i)] : ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+(i - 2)*j][point.j+0]) ) + sizeof(Cell)))[(cs.x.i)];
      H += ci;




      if (S > 0. && S < 1.) {
 S = ci;
 if (ci <= 0. || ci >= 1.) {







   H -= i*ci;
   break;
 }
      }
# 138 "/root/mnt/basilisk/src/heights.h"
      else if (S >= 1. && ci <= 0.) {
 H = (H - 0.5)*j + (j == -1)*20.;
 S = complete;
 break;
      }
      else if (S <= 0. && ci >= 1.) {
 H = (i + 0.5 - H)*j + (j == 1)*20.;
 S = complete;
 break;
      }
# 156 "/root/mnt/basilisk/src/heights.h"
      else if (S == ci && modf(H, &a))
 break;
    }





    if (j == -1) {







      if (S != complete && ((((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(c.i)] <= 0. || ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(c.i)] >= 1.) ||
       (S > 0. && S < 1.)))
 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.x.i)] = 300.;
      else if (S == complete)
 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.x.i)] = H;
      else





 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.x.i)] = H + 100.*(1. + (S >= 1.));
    }
    else {
# 195 "/root/mnt/basilisk/src/heights.h"
      if (state.s != complete ||
   (S == complete && fabs(height(H)) < fabs(height(state.h))))
 state.s = S, state.h = H;





      if (state.s != complete)
 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.x.i)] = ((double)1e30);
      else
 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.x.i)] = (state.h > 1e10 ? ((double)1e30) : state.h);
    }
  }
# 59 "/root/mnt/basilisk/src/heights.h"
{







    double S = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(c.i)], H = S, ci, a;







    typedef struct { int s; double h; } HState;
    HState state = {0, 0};
    if (j == 1) {




      if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.y.i)] == 300.)
 state.s = complete, state.h = ((double)1e30);




      else {
 int s = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.y.i)] + 20./2.)/100.;
 state.h = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.y.i)] - 100.*s;
 state.s = s - 1;
      }





      if (state.s != complete)
 S = state.s, H = state.h;
    }
# 109 "/root/mnt/basilisk/src/heights.h"
    for (int i = 1; i <= 4; i++) {
      ci = i <= 2 ? ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i*j]) ) + sizeof(Cell)))[(c.i)] : ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+(i - 2)*j]) ) + sizeof(Cell)))[(cs.y.i)];
      H += ci;




      if (S > 0. && S < 1.) {
 S = ci;
 if (ci <= 0. || ci >= 1.) {







   H -= i*ci;
   break;
 }
      }
# 138 "/root/mnt/basilisk/src/heights.h"
      else if (S >= 1. && ci <= 0.) {
 H = (H - 0.5)*j + (j == -1)*20.;
 S = complete;
 break;
      }
      else if (S <= 0. && ci >= 1.) {
 H = (i + 0.5 - H)*j + (j == 1)*20.;
 S = complete;
 break;
      }
# 156 "/root/mnt/basilisk/src/heights.h"
      else if (S == ci && modf(H, &a))
 break;
    }





    if (j == -1) {







      if (S != complete && ((((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(c.i)] <= 0. || ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(c.i)] >= 1.) ||
       (S > 0. && S < 1.)))
 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.y.i)] = 300.;
      else if (S == complete)
 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.y.i)] = H;
      else





 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.y.i)] = H + 100.*(1. + (S >= 1.));
    }
    else {
# 195 "/root/mnt/basilisk/src/heights.h"
      if (state.s != complete ||
   (S == complete && fabs(height(H)) < fabs(height(state.h))))
 state.s = S, state.h = H;





      if (state.s != complete)
 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.y.i)] = ((double)1e30);
      else
 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.y.i)] = (state.h > 1e10 ? ((double)1e30) : state.h);
    }
  }
}
# 222 "/root/mnt/basilisk/src/heights.h"
static void column_propagation (vector h)
{
  { static ForeachData _loop = { "/root/mnt/basilisk/src/heights.h", 224, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 224 "/root/mnt/basilisk/src/heights.h" 3 4
 0
# 224 "/root/mnt/basilisk/src/heights.h"
 ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point);
    for (int i = -2; i <= 2; i++)
      {
 {stencil_val (point, h.x, i, 0, 0, "/root/mnt/basilisk/src/heights.h", 227, 
# 227 "/root/mnt/basilisk/src/heights.h" 3 4
 0
# 227 "/root/mnt/basilisk/src/heights.h"
 );
stencil_val (point, h.x, i, 0, 0, "/root/mnt/basilisk/src/heights.h", 228, 
# 228 "/root/mnt/basilisk/src/heights.h" 3 4
0
# 228 "/root/mnt/basilisk/src/heights.h"
);stencil_val (point, h.x, 0, 0, 0, "/root/mnt/basilisk/src/heights.h", 228, 
# 228 "/root/mnt/basilisk/src/heights.h" 3 4
                       0
# 228 "/root/mnt/basilisk/src/heights.h"
                       );
   {stencil_val_a (point, h.x, 0, 0, 0, 
# 229 "/root/mnt/basilisk/src/heights.h" 3 4
   0
# 229 "/root/mnt/basilisk/src/heights.h"
   , "/root/mnt/basilisk/src/heights.h", 229); stencil_val (point, h.x, i, 0, 0, "/root/mnt/basilisk/src/heights.h", 229, 
# 229 "/root/mnt/basilisk/src/heights.h" 3 4
                              0
# 229 "/root/mnt/basilisk/src/heights.h"
                              ); }
# 229 "/root/mnt/basilisk/src/heights.h"
}
# 227 "/root/mnt/basilisk/src/heights.h"
{stencil_val (point, h.y, 0, i, 0, "/root/mnt/basilisk/src/heights.h", 227, 
# 227 "/root/mnt/basilisk/src/heights.h" 3 4
0
# 227 "/root/mnt/basilisk/src/heights.h"
);
stencil_val (point, h.y, 0, i, 0, "/root/mnt/basilisk/src/heights.h", 228, 
# 228 "/root/mnt/basilisk/src/heights.h" 3 4
0
# 228 "/root/mnt/basilisk/src/heights.h"
);stencil_val (point, h.y, 0, 0, 0, "/root/mnt/basilisk/src/heights.h", 228, 
# 228 "/root/mnt/basilisk/src/heights.h" 3 4
                       0
# 228 "/root/mnt/basilisk/src/heights.h"
                       );
   {stencil_val_a (point, h.y, 0, 0, 0, 
# 229 "/root/mnt/basilisk/src/heights.h" 3 4
   0
# 229 "/root/mnt/basilisk/src/heights.h"
   , "/root/mnt/basilisk/src/heights.h", 229); stencil_val (point, h.y, 0, i, 0, "/root/mnt/basilisk/src/heights.h", 229, 
# 229 "/root/mnt/basilisk/src/heights.h" 3 4
                              0
# 229 "/root/mnt/basilisk/src/heights.h"
                              ); }
# 229 "/root/mnt/basilisk/src/heights.h"
}}end_stencil (&_loop); _loop.first = 0;};





{
# 224 "/root/mnt/basilisk/src/heights.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    for (int i = -2; i <= 2; i++)
      {
 if (fabs(height(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(h.x.i)])) <= 3.5 &&
     fabs(height(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(h.x.i)]) + i) < fabs(height(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.x.i)])))
   ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.x.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(h.x.i)] + i;
# 227 "/root/mnt/basilisk/src/heights.h"
if (fabs(height(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(h.y.i)])) <= 3.5 &&
     fabs(height(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(h.y.i)]) + i) < fabs(height(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.y.i)])))
   ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.y.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(h.y.i)] + i;}} } };}
# 230 "/root/mnt/basilisk/src/heights.h"
}
# 289 "/root/mnt/basilisk/src/heights.h"

static void refine_h_x (Point point, scalar h)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;




  
# 296 "/root/mnt/basilisk/src/heights.h" 3 4
 _Bool 
# 296 "/root/mnt/basilisk/src/heights.h"
      complete = 
# 296 "/root/mnt/basilisk/src/heights.h" 3 4
                 1
# 296 "/root/mnt/basilisk/src/heights.h"
                     ;
  {{ int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
    for (int i = -2; i <= 2; i++)
      if ((((point.i+i) >= (((Tree *)grid)->L[point.level]->m)->r1.start && (point.i+i) < (((Tree *)grid)->L[point.level]->m->r1.end) && (((Tree *)grid)->L[point.level]->m)->b[point.i+i] && (point.j+0) >= (((Tree *)grid)->L[point.level]->m)->r2[point.i+i].start && (point.j+0) < (((Tree *)grid)->L[point.level]->m)->r2[point.i+i].end && (((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) &&
   !(!(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ))))).flags & leaf) && !(*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) )))).neighbors && (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) )))).pid >= 0) && !((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) )))).pid < 0) &&
   fabs(height(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(h.i)])) <= 3.5 &&
   fabs(height(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(h.i)]) + i) < fabs(height(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.i)])))
 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(h.i)] + i;
    if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.i)] == ((double)1e30))
      complete = 
# 305 "/root/mnt/basilisk/src/heights.h" 3 4
                0
# 305 "/root/mnt/basilisk/src/heights.h"
                     ;
  }} } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}}
  if (complete)
    return;
# 317 "/root/mnt/basilisk/src/heights.h"
  int ori = orientation(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.i)]);

  for (int i = -1; i <= 1; i++)
    if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(h.i)] == ((double)1e30) || orientation(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(h.i)]) != ori)
      return;

  double h0 = (30.*height(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.i)]) + height(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(h.i)]) + height(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(h.i)]))/16.
    + 20.*ori;
  double dh = (height(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(h.i)]) - height(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(h.i)]))/4.;
  {{ int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.i)] == ((double)1e30))
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.i)] = h0 + dh*child.y - child.x/2.;} } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}}
# 352 "/root/mnt/basilisk/src/heights.h"
}
# 290 "/root/mnt/basilisk/src/heights.h"
static void refine_h_y (Point point, scalar h)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;




  
# 296 "/root/mnt/basilisk/src/heights.h" 3 4
 _Bool 
# 296 "/root/mnt/basilisk/src/heights.h"
      complete = 
# 296 "/root/mnt/basilisk/src/heights.h" 3 4
                 1
# 296 "/root/mnt/basilisk/src/heights.h"
                     ;
  {{ int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
    for (int i = -2; i <= 2; i++)
      if ((((point.i+0) >= (((Tree *)grid)->L[point.level]->m)->r1.start && (point.i+0) < (((Tree *)grid)->L[point.level]->m->r1.end) && (((Tree *)grid)->L[point.level]->m)->b[point.i+0] && (point.j+i) >= (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].start && (point.j+i) < (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].end && (((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) &&
   !(!(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ))))).flags & leaf) && !(*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) )))).neighbors && (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) )))).pid >= 0) && !((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) )))).pid < 0) &&
   fabs(height(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(h.i)])) <= 3.5 &&
   fabs(height(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(h.i)]) + i) < fabs(height(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.i)])))
 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(h.i)] + i;
    if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.i)] == ((double)1e30))
      complete = 
# 305 "/root/mnt/basilisk/src/heights.h" 3 4
                0
# 305 "/root/mnt/basilisk/src/heights.h"
                     ;
  }} } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}}
  if (complete)
    return;
# 317 "/root/mnt/basilisk/src/heights.h"
  int ori = orientation(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.i)]);

  for (int i = -1; i <= 1; i++)
    if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(h.i)] == ((double)1e30) || orientation(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(h.i)]) != ori)
      return;

  double h0 = (30.*height(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.i)]) + height(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(h.i)]) + height(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(h.i)]))/16.
    + 20.*ori;
  double dh = (height(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(h.i)]) - height(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(h.i)]))/4.;
  {{ int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.i)] == ((double)1e30))
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.i)] = h0 + dh*child.x - child.y/2.;} } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}}
# 352 "/root/mnt/basilisk/src/heights.h"
}







void heights (scalar c, vector h)
{;
  vector s=new_vector("s");

    for (int i = 0; i < nboundary; i++)
      _attribute[s.x.i].boundary[i] = _attribute[c.i].boundary[i];
# 364 "/root/mnt/basilisk/src/heights.h"
for (int i = 0; i < nboundary; i++)
      _attribute[s.y.i].boundary[i] = _attribute[c.i].boundary[i];





  restriction (((scalar[]){c,{-1}}));
  for (int j = -1; j <= 1; j += 2) {





    {{ if (0 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[0]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.level = 0; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
      {
        ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.x.i)] = ((double)1e30);
# 380 "/root/mnt/basilisk/src/heights.h"
((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.y.i)] = ((double)1e30);}} } }; }};}

    for (int l = 1; l <= (grid->depth); l++) {




      {{ if (l <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[l]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.level = l; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
 {
   ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.x.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+2*j][point.j+0]) ) + sizeof(Cell)))[(c.i)];
# 389 "/root/mnt/basilisk/src/heights.h"
((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.y.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+2*j]) ) + sizeof(Cell)))[(c.i)];}} } }; }};}
# 399 "/root/mnt/basilisk/src/heights.h"
      {{ if (l - 1 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[l - 1]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.level = l - 1; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
 { {
   ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.x.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+j][point.j+0]) ) + sizeof(Cell)))[(c.i)];
   ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+j][point.j+0]) ) + sizeof(Cell)))[(s.x.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+2*j][point.j+0]) ) + sizeof(Cell)))[(c.i)];
        }
# 400 "/root/mnt/basilisk/src/heights.h"
{
   ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(s.y.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+j]) ) + sizeof(Cell)))[(c.i)];
   ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+j]) ) + sizeof(Cell)))[(s.y.i)] = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+2*j]) ) + sizeof(Cell)))[(c.i)];
        }}} } }; }};}






      {{ if (l - 1 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _cache = ((Tree *)grid)->prolongation[l - 1]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.level = l - 1; int _k; for (_k = 0; _k < _cache.n; _k++) { point.i = _cache.p[_k].i; point.j = _cache.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
 {
   _attribute[c.i].prolongation (point, s.x);
# 412 "/root/mnt/basilisk/src/heights.h"
_attribute[c.i].prolongation (point, s.y);}} } }; }};}
      { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->level) _b->level (_b, (scalar *)((vector[]){s,{{-1},{-1}}}), l); };





      {{ if (l <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[l]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.level = l; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
        half_column (point, c, h, s, j);} } }; }};}
    }
  }






   {
    _attribute[h.x.i].prolongation = no_data;
    _attribute[h.x.i].restriction = no_restriction;
    _attribute[h.x.i].dirty = 
# 432 "/root/mnt/basilisk/src/heights.h" 3 4
                             1
# 432 "/root/mnt/basilisk/src/heights.h"
                                 ;
  }
# 429 "/root/mnt/basilisk/src/heights.h"
{
    _attribute[h.y.i].prolongation = no_data;
    _attribute[h.y.i].restriction = no_restriction;
    _attribute[h.y.i].dirty = 
# 432 "/root/mnt/basilisk/src/heights.h" 3 4
                             1
# 432 "/root/mnt/basilisk/src/heights.h"
                                 ;
  }




  column_propagation (h);







    _attribute[h.x.i].prolongation = refine_h_x;
# 446 "/root/mnt/basilisk/src/heights.h"
_attribute[h.y.i].prolongation = refine_h_y;delete((scalar*)((vector[]){s,{{-1},{-1}}}));
;}
# 67 "/root/mnt/basilisk/src/curvature.h"



static double kappa_y (Point point, vector h)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  int ori = orientation(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.y.i)]);
  for (int i = -1; i <= 1; i++)
    if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(h.y.i)] == ((double)1e30) || orientation(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(h.y.i)]) != ori)
      return ((double)1e30);
  double hx = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(h.y.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(h.y.i)])/2.;
  double hxx = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(h.y.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(h.y.i)] - 2.*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.y.i)])/Delta;
  return hxx/pow(1. + ((hx)*(hx)), 3/2.);
}
# 70 "/root/mnt/basilisk/src/curvature.h"
static double kappa_x (Point point, vector h)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  int ori = orientation(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.x.i)]);
  for (int i = -1; i <= 1; i++)
    if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(h.x.i)] == ((double)1e30) || orientation(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(h.x.i)]) != ori)
      return ((double)1e30);
  double hx = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(h.x.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(h.x.i)])/2.;
  double hxx = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(h.x.i)] + ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(h.x.i)] - 2.*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.x.i)])/Delta;
  return hxx/pow(1. + ((hx)*(hx)), 3/2.);
}


static coord normal_y (Point point, vector h)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  coord n = {((double)1e30), ((double)1e30), ((double)1e30)};
  if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.y.i)] == ((double)1e30))
    return n;
  int ori = orientation(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.y.i)]);
  if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(h.y.i)] != ((double)1e30) && orientation(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(h.y.i)]) == ori) {
    if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(h.y.i)] != ((double)1e30) && orientation(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(h.y.i)]) == ori)
      n.x = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(h.y.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(h.y.i)])/2.;
    else
      n.x = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(h.y.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.y.i)];
  }
  else if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(h.y.i)] != ((double)1e30) && orientation(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(h.y.i)]) == ori)
    n.x = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.y.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(h.y.i)];
  else
    return n;
  double nn = (ori ? -1. : 1.)*sqrt(1. + ((n.x)*(n.x)));
  n.x /= nn;
  n.y = 1./nn;
  return n;
}
# 82 "/root/mnt/basilisk/src/curvature.h"
static coord normal_x (Point point, vector h)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  coord n = {((double)1e30), ((double)1e30), ((double)1e30)};
  if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.x.i)] == ((double)1e30))
    return n;
  int ori = orientation(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.x.i)]);
  if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(h.x.i)] != ((double)1e30) && orientation(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(h.x.i)]) == ori) {
    if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(h.x.i)] != ((double)1e30) && orientation(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(h.x.i)]) == ori)
      n.y = (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(h.x.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(h.x.i)])/2.;
    else
      n.y = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(h.x.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.x.i)];
  }
  else if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(h.x.i)] != ((double)1e30) && orientation(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(h.x.i)]) == ori)
    n.y = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.x.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(h.x.i)];
  else
    return n;
  double nn = (ori ? -1. : 1.)*sqrt(1. + ((n.y)*(n.y)));
  n.y /= nn;
  n.x = 1./nn;
  return n;
}
# 179 "/root/mnt/basilisk/src/curvature.h"
static double height_curvature (Point point, scalar c, vector h)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;






  typedef struct {
    double n;
    double (* kappa) (Point, vector);
  } NormKappa;
  struct { NormKappa x, y, z; } n;

    n.x.n = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(c.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(c.i)], n.x.kappa = kappa_x;
# 193 "/root/mnt/basilisk/src/curvature.h"
n.y.n = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(c.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(c.i)], n.y.kappa = kappa_y;
  double (* kappaf) (Point, vector) = 
# 194 "/root/mnt/basilisk/src/curvature.h" 3 4
                                     ((void *)0)
# 194 "/root/mnt/basilisk/src/curvature.h"
                                         ; (void)(kappaf);




  if (fabs(n.x.n) < fabs(n.y.n))
    do { NormKappa __tmp = n.x; n.x = n.y; n.y = __tmp; } while(0);
# 211 "/root/mnt/basilisk/src/curvature.h"
  double kappa = ((double)1e30);

    if (kappa == ((double)1e30)) {
      kappa = n.x.kappa (point, h);
      if (kappa != ((double)1e30)) {
 kappaf = n.x.kappa;
 if (n.x.n < 0.)
   kappa = - kappa;
      }
    }
# 213 "/root/mnt/basilisk/src/curvature.h"
if (kappa == ((double)1e30)) {
      kappa = n.y.kappa (point, h);
      if (kappa != ((double)1e30)) {
 kappaf = n.y.kappa;
 if (n.y.n < 0.)
   kappa = - kappa;
      }
    }

  if (kappa != ((double)1e30)) {




    if (fabs(kappa) > 1./Delta)
      kappa = ((kappa) > 0 ? 1 : -1)/Delta;
# 247 "/root/mnt/basilisk/src/curvature.h"
  }

  return kappa;
}
# 179 "/root/mnt/basilisk/src/curvature.h"
static void _stencil_height_curvature (Point point, scalar c, vector h)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 193 "/root/mnt/basilisk/src/curvature.h"
    { stencil_val (point, c, 1, 0, 0, "/root/mnt/basilisk/src/curvature.h", 193, 
# 193 "/root/mnt/basilisk/src/curvature.h" 3 4
     0
# 193 "/root/mnt/basilisk/src/curvature.h"
     ); stencil_val (point, c, -1, 0, 0, "/root/mnt/basilisk/src/curvature.h", 193, 
# 193 "/root/mnt/basilisk/src/curvature.h" 3 4
                            0
# 193 "/root/mnt/basilisk/src/curvature.h"
                            ); }
# 193 "/root/mnt/basilisk/src/curvature.h"
{ stencil_val (point, c, 0, 1, 0, "/root/mnt/basilisk/src/curvature.h", 193, 
# 193 "/root/mnt/basilisk/src/curvature.h" 3 4
 0
# 193 "/root/mnt/basilisk/src/curvature.h"
 ); stencil_val (point, c, 0, -1, 0, "/root/mnt/basilisk/src/curvature.h", 193, 
# 193 "/root/mnt/basilisk/src/curvature.h" 3 4
                        0
# 193 "/root/mnt/basilisk/src/curvature.h"
                        ); }
# 211 "/root/mnt/basilisk/src/curvature.h"
# 247 "/root/mnt/basilisk/src/curvature.h"


  return ;
}






coord height_normal (Point point, scalar c, vector h)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;






  typedef struct {
    double n;
    coord (* normal) (Point, vector);
  } NormNormal;
  struct { NormNormal x, y, z; } n;

    n.x.n = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(c.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(c.i)], n.x.normal = normal_x;
# 271 "/root/mnt/basilisk/src/curvature.h"
n.y.n = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(c.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(c.i)], n.y.normal = normal_y;




  if (fabs(n.x.n) < fabs(n.y.n))
    do { NormNormal __tmp = n.x; n.x = n.y; n.y = __tmp; } while(0);
# 288 "/root/mnt/basilisk/src/curvature.h"
  coord normal = {((double)1e30), ((double)1e30), ((double)1e30)};

    if (normal.x == ((double)1e30))
      normal = n.x.normal (point, h);
# 290 "/root/mnt/basilisk/src/curvature.h"
if (normal.y == ((double)1e30))
      normal = n.y.normal (point, h);

  return normal;
}
# 330 "/root/mnt/basilisk/src/curvature.h"
# 1 "parabola.h"
# 1 "/root/mnt/basilisk/src/parabola.h"
# 1 "utils.h"
# 2 "/root/mnt/basilisk/src/parabola.h"






typedef struct {
  coord o;

  coord m;
  double ** M, rhs[3], a[3];
# 21 "/root/mnt/basilisk/src/parabola.h"
} ParabolaFit;

static void parabola_fit_init (ParabolaFit * p, coord o, coord m)
{

    p->o.x = o.x;
# 26 "/root/mnt/basilisk/src/parabola.h"
p->o.y = o.y;


    p->m.x = m.x;
# 29 "/root/mnt/basilisk/src/parabola.h"
p->m.y = m.y;
  normalize (&p->m);
  int n = 3;
# 65 "/root/mnt/basilisk/src/parabola.h"
  p->M = (double **) matrix_new (n, n, sizeof(double));
  for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++)
      p->M[i][j] = 0.;
    p->rhs[i] = 0.;
  }
}

static void parabola_fit_add (ParabolaFit * p, coord m, double w)
{

  double x1 = m.x - p->o.x, y1 = m.y - p->o.y;
  double x = p->m.y*x1 - p->m.x*y1;
  double y = p->m.x*x1 + p->m.y*y1;
  double x2 = w*x*x, x3 = x2*x, x4 = x3*x;
  p->M[0][0] += x4;
  p->M[1][0] += x3; p->M[1][1] += x2;
  p->M[2][1] += w*x; p->M[2][2] += w;
  p->rhs[0] += x2*y; p->rhs[1] += w*x*y; p->rhs[2] += w*y;
# 111 "/root/mnt/basilisk/src/parabola.h"
}

static double parabola_fit_solve (ParabolaFit * p)
{

  p->M[0][1] = p->M[1][0];
  p->M[0][2] = p->M[2][0] = p->M[1][1];
  p->M[1][2] = p->M[2][1];
  double pivmin = matrix_inverse (p->M, 3, 1e-10);
  if (pivmin) {
    p->a[0] = p->M[0][0]*p->rhs[0] + p->M[0][1]*p->rhs[1] + p->M[0][2]*p->rhs[2];
    p->a[1] = p->M[1][0]*p->rhs[0] + p->M[1][1]*p->rhs[1] + p->M[1][2]*p->rhs[2];
  }
  else
    p->a[0] = p->a[1] = 0.;
# 158 "/root/mnt/basilisk/src/parabola.h"
  matrix_free (p->M);
  return pivmin;
}

static double parabola_fit_curvature (ParabolaFit * p,
          double kappamax, double * kmax)
{
  double kappa;

  double dnm = 1. + ((p->a[1])*(p->a[1]));
  kappa = - 2.*p->a[0]/pow(dnm, 3/2.);
  if (kmax)
    *kmax = fabs (kappa);
# 190 "/root/mnt/basilisk/src/parabola.h"
  if (fabs (kappa) > kappamax) {
    if (kmax)
      *kmax = kappamax;
    return kappa > 0. ? kappamax : - kappamax;
  }
  return kappa;
}
# 331 "/root/mnt/basilisk/src/curvature.h"






static int independents (coord * p, int n)
{
  if (n < 2)
    return n;
  int ni = 1;
  for (int j = 1; j < n; j++) {
    
# 343 "/root/mnt/basilisk/src/curvature.h" 3 4
   _Bool 
# 343 "/root/mnt/basilisk/src/curvature.h"
        depends = 
# 343 "/root/mnt/basilisk/src/curvature.h" 3 4
                  0
# 343 "/root/mnt/basilisk/src/curvature.h"
                       ;
    for (int i = 0; i < j && !depends; i++) {
      double d2 = 0.;

 d2 += ((p[i].x - p[j].x)*(p[i].x - p[j].x));
# 347 "/root/mnt/basilisk/src/curvature.h"
d2 += ((p[i].y - p[j].y)*(p[i].y - p[j].y));
      depends = (d2 < ((0.5)*(0.5)));
    }
    ni += !depends;
  }
  return ni;
}






static double height_curvature_fit (Point point, scalar c, vector h)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;





  coord ip[2 == 2 ? 6 : 27];
  int n = 0;




   {





    int n1 = 0, n2 = 0;

    for (int i = -1; i <= 1; i++)
      if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(h.y.i)] != ((double)1e30)) {
 if (orientation(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(h.y.i)])) n1++; else n2++;
      }







    int ori = (n1 > n2);







    for (int i = -1; i <= 1; i++)
      if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(h.y.i)] != ((double)1e30) && orientation(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(h.y.i)]) == ori)
 ip[n].x = i, ip[n++].y = height(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(h.y.i)]);






  }
# 373 "/root/mnt/basilisk/src/curvature.h"
{





    int n1 = 0, n2 = 0;

    for (int i = -1; i <= 1; i++)
      if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(h.x.i)] != ((double)1e30)) {
 if (orientation(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(h.x.i)])) n1++; else n2++;
      }







    int ori = (n1 > n2);







    for (int i = -1; i <= 1; i++)
      if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(h.x.i)] != ((double)1e30) && orientation(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(h.x.i)]) == ori)
 ip[n].y = i, ip[n++].x = height(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(h.x.i)]);






  }





  if (independents (ip, n) < (2 == 2 ? 3 : 9))
    return ((double)1e30);





  coord m = mycs (point, c), fc;
  double alpha = line_alpha (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(c.i)], m);
  double area = line_length_center(m,alpha,&fc);
  ParabolaFit fit;
  parabola_fit_init (&fit, fc, m);

  (void)(area);
  parabola_fit_add (&fit, fc, .1);
# 438 "/root/mnt/basilisk/src/curvature.h"
  for (int i = 0; i < n; i++)
    parabola_fit_add (&fit, ip[i], 1.);
  parabola_fit_solve (&fit);
  double kappa = parabola_fit_curvature (&fit, 2., 
# 441 "/root/mnt/basilisk/src/curvature.h" 3 4
                                                  ((void *)0)
# 441 "/root/mnt/basilisk/src/curvature.h"
                                                      )/Delta;



  return kappa;
}
# 360 "/root/mnt/basilisk/src/curvature.h"
static void _stencil_height_curvature_fit (Point point, scalar c, vector h)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 373 "/root/mnt/basilisk/src/curvature.h"
   {







    for (int i = -1; i <= 1; i++)
      {stencil_val (point, h.y, i, 0, 0, "/root/mnt/basilisk/src/curvature.h", 382, 
# 382 "/root/mnt/basilisk/src/curvature.h" 3 4
      0
# 382 "/root/mnt/basilisk/src/curvature.h"
      ); {
stencil_val (point, h.y, i, 0, 0, "/root/mnt/basilisk/src/curvature.h", 383, 
# 383 "/root/mnt/basilisk/src/curvature.h" 3 4
0
# 383 "/root/mnt/basilisk/src/curvature.h"
);
# 384 "/root/mnt/basilisk/src/curvature.h"
} }
# 400 "/root/mnt/basilisk/src/curvature.h"
    for (int i = -1; i <= 1; i++)
      {stencil_val (point, h.y, i, 0, 0, "/root/mnt/basilisk/src/curvature.h", 401, 
# 401 "/root/mnt/basilisk/src/curvature.h" 3 4
      0
# 401 "/root/mnt/basilisk/src/curvature.h"
      );stencil_val (point, h.y, i, 0, 0, "/root/mnt/basilisk/src/curvature.h", 401, 
# 401 "/root/mnt/basilisk/src/curvature.h" 3 4
                              0
# 401 "/root/mnt/basilisk/src/curvature.h"
                              );
 {stencil_val (point, h.y, i, 0, 0, "/root/mnt/basilisk/src/curvature.h", 402, 
# 402 "/root/mnt/basilisk/src/curvature.h" 3 4
 0
# 402 "/root/mnt/basilisk/src/curvature.h"
 ); } }






  }
# 373 "/root/mnt/basilisk/src/curvature.h"
{







    for (int i = -1; i <= 1; i++)
      {stencil_val (point, h.x, 0, i, 0, "/root/mnt/basilisk/src/curvature.h", 382, 
# 382 "/root/mnt/basilisk/src/curvature.h" 3 4
      0
# 382 "/root/mnt/basilisk/src/curvature.h"
      ); {
stencil_val (point, h.x, 0, i, 0, "/root/mnt/basilisk/src/curvature.h", 383, 
# 383 "/root/mnt/basilisk/src/curvature.h" 3 4
0
# 383 "/root/mnt/basilisk/src/curvature.h"
);
# 384 "/root/mnt/basilisk/src/curvature.h"
} }
# 400 "/root/mnt/basilisk/src/curvature.h"
    for (int i = -1; i <= 1; i++)
      {stencil_val (point, h.x, 0, i, 0, "/root/mnt/basilisk/src/curvature.h", 401, 
# 401 "/root/mnt/basilisk/src/curvature.h" 3 4
      0
# 401 "/root/mnt/basilisk/src/curvature.h"
      );stencil_val (point, h.x, 0, i, 0, "/root/mnt/basilisk/src/curvature.h", 401, 
# 401 "/root/mnt/basilisk/src/curvature.h" 3 4
                              0
# 401 "/root/mnt/basilisk/src/curvature.h"
                              );
 {stencil_val (point, h.x, 0, i, 0, "/root/mnt/basilisk/src/curvature.h", 402, 
# 402 "/root/mnt/basilisk/src/curvature.h" 3 4
 0
# 402 "/root/mnt/basilisk/src/curvature.h"
 ); } }






  }
# 422 "/root/mnt/basilisk/src/curvature.h"
   _stencil_mycs (point, c);
  stencil_val (point, c, 0, 0, 0, "/root/mnt/basilisk/src/curvature.h", 423, 
# 423 "/root/mnt/basilisk/src/curvature.h" 3 4
 0
# 423 "/root/mnt/basilisk/src/curvature.h"
 );
# 438 "/root/mnt/basilisk/src/curvature.h"







  return ;
}






static double centroids_curvature_fit (Point point, scalar c)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;





  coord m = mycs (point, c), fc;
  double alpha = line_alpha (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(c.i)], m);
  line_length_center(m,alpha,&fc);
  ParabolaFit fit;
  parabola_fit_init (&fit, fc, m);





  coord r = {x,y,z};
  {{ int _nn = 1 + 0 ? 1 + 0 : 2; int _i = point.i, _j = point.j; for (int _k = - _nn; _k <= _nn; _k++) { point.i = _i + _k; for (int _l = - _nn; _l <= _nn; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(c.i)] > 0. && ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(c.i)] < 1.) {
      coord m = mycs (point, c), fc;
      double alpha = line_alpha (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(c.i)], m);
      double area = line_length_center(m,alpha,&fc);
      coord rn = {x,y,z};

 fc.x += (rn.x - r.x)/Delta;
# 478 "/root/mnt/basilisk/src/curvature.h"
fc.y += (rn.y - r.y)/Delta;
      parabola_fit_add (&fit, fc, area);
    }} } point.i = _i; point.j = _j;}}
  parabola_fit_solve (&fit);
  double kappa = parabola_fit_curvature (&fit, 2., 
# 482 "/root/mnt/basilisk/src/curvature.h" 3 4
                                                  ((void *)0)
# 482 "/root/mnt/basilisk/src/curvature.h"
                                                      )/Delta;



  return kappa;
}
# 453 "/root/mnt/basilisk/src/curvature.h"
static void _stencil_centroids_curvature_fit (Point point, scalar c)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;





   _stencil_mycs (point, c);
  stencil_val (point, c, 0, 0, 0, "/root/mnt/basilisk/src/curvature.h", 461, 
# 461 "/root/mnt/basilisk/src/curvature.h" 3 4
 0
# 461 "/root/mnt/basilisk/src/curvature.h"
 );
# 471 "/root/mnt/basilisk/src/curvature.h"
  {{ int _nn = 1 + 0 ? 1 + 0 : 2; int _i = point.i, _j = point.j; for (int _k = - _nn; _k <= _nn; _k++) { point.i = _i + _k; for (int _l = - _nn; _l <= _nn; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    {stencil_val (point, c, 0, 0, 0, "/root/mnt/basilisk/src/curvature.h", 472, 
# 472 "/root/mnt/basilisk/src/curvature.h" 3 4
    0
# 472 "/root/mnt/basilisk/src/curvature.h"
    ); stencil_val (point, c, 0, 0, 0, "/root/mnt/basilisk/src/curvature.h", 472, 
# 472 "/root/mnt/basilisk/src/curvature.h" 3 4
                           0
# 472 "/root/mnt/basilisk/src/curvature.h"
                           ); {
       _stencil_mycs (point, c);
      stencil_val (point, c, 0, 0, 0, "/root/mnt/basilisk/src/curvature.h", 474, 
# 474 "/root/mnt/basilisk/src/curvature.h" 3 4
     0
# 474 "/root/mnt/basilisk/src/curvature.h"
     );





    } }} } point.i = _i; point.j = _j;}}





  return ;
}
# 500 "/root/mnt/basilisk/src/curvature.h"
static inline 
# 500 "/root/mnt/basilisk/src/curvature.h" 3 4
             _Bool 
# 500 "/root/mnt/basilisk/src/curvature.h"
                  interfacial (Point point, scalar c)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(c.i)] >= 1.) {
    for (int i = -1; i <= 1; i += 2)
      {
 if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(c.i)] <= 0.)
   return 
# 506 "/root/mnt/basilisk/src/curvature.h" 3 4
         1
# 506 "/root/mnt/basilisk/src/curvature.h"
             ;
# 505 "/root/mnt/basilisk/src/curvature.h"
if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(c.i)] <= 0.)
   return 
# 506 "/root/mnt/basilisk/src/curvature.h" 3 4
         1
# 506 "/root/mnt/basilisk/src/curvature.h"
             ;}
  }
  else if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(c.i)] <= 0.) {
    for (int i = -1; i <= 1; i += 2)
      {
 if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+i][point.j+0]) ) + sizeof(Cell)))[(c.i)] >= 1.)
   return 
# 512 "/root/mnt/basilisk/src/curvature.h" 3 4
         1
# 512 "/root/mnt/basilisk/src/curvature.h"
             ;
# 511 "/root/mnt/basilisk/src/curvature.h"
if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+i]) ) + sizeof(Cell)))[(c.i)] >= 1.)
   return 
# 512 "/root/mnt/basilisk/src/curvature.h" 3 4
         1
# 512 "/root/mnt/basilisk/src/curvature.h"
             ;}
  }
  else
    return 
# 515 "/root/mnt/basilisk/src/curvature.h" 3 4
          1
# 515 "/root/mnt/basilisk/src/curvature.h"
              ;
  return 
# 516 "/root/mnt/basilisk/src/curvature.h" 3 4
        0
# 516 "/root/mnt/basilisk/src/curvature.h"
             ;
}
# 500 "/root/mnt/basilisk/src/curvature.h"
static void _stencil_interfacial (Point point, scalar c)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
stencil_val (point, c, 0, 0, 0, "/root/mnt/basilisk/src/curvature.h", 502, 
# 502 "/root/mnt/basilisk/src/curvature.h" 3 4
0
# 502 "/root/mnt/basilisk/src/curvature.h"
);{ {
    for (int i = -1; i <= 1; i += 2)
      {
 {stencil_val (point, c, i, 0, 0, "/root/mnt/basilisk/src/curvature.h", 505, 
# 505 "/root/mnt/basilisk/src/curvature.h" 3 4
 0
# 505 "/root/mnt/basilisk/src/curvature.h"
 );
      }
# 505 "/root/mnt/basilisk/src/curvature.h"
{stencil_val (point, c, 0, i, 0, "/root/mnt/basilisk/src/curvature.h", 505, 
# 505 "/root/mnt/basilisk/src/curvature.h" 3 4
0
# 505 "/root/mnt/basilisk/src/curvature.h"
);
      }}
  }
{stencil_val (point, c, 0, 0, 0, "/root/mnt/basilisk/src/curvature.h", 508, 
# 508 "/root/mnt/basilisk/src/curvature.h" 3 4
0
# 508 "/root/mnt/basilisk/src/curvature.h"
);{ {
    for (int i = -1; i <= 1; i += 2)
      {
 {stencil_val (point, c, i, 0, 0, "/root/mnt/basilisk/src/curvature.h", 511, 
# 511 "/root/mnt/basilisk/src/curvature.h" 3 4
 0
# 511 "/root/mnt/basilisk/src/curvature.h"
 );
      }
# 511 "/root/mnt/basilisk/src/curvature.h"
{stencil_val (point, c, 0, i, 0, "/root/mnt/basilisk/src/curvature.h", 511, 
# 511 "/root/mnt/basilisk/src/curvature.h" 3 4
0
# 511 "/root/mnt/basilisk/src/curvature.h"
);
      }}
  }

}
# 515 "/root/mnt/basilisk/src/curvature.h"
}}
# 516 "/root/mnt/basilisk/src/curvature.h"
return ;
}
# 530 "/root/mnt/basilisk/src/curvature.h"
typedef struct {
  int h;
  int f;
  int a;
  int c;
} cstats;

struct Curvature {
  scalar c, kappa;
  double sigma;
  
# 540 "/root/mnt/basilisk/src/curvature.h" 3 4
 _Bool 
# 540 "/root/mnt/basilisk/src/curvature.h"
      add;
};


cstats curvature (struct Curvature p)
{;
  scalar c = p.c, kappa = p.kappa;
  double sigma = p.sigma ? p.sigma : 1.;
  int sh = 0, f = 0, sa = 0, sc = 0;
  vector ch = _attribute[c.i].height, h=(ch).x.i?(ch):new_vector("h");
  if (!ch.x.i)
    heights (c, h);






  _attribute[kappa.i].refine = _attribute[kappa.i].prolongation = curvature_prolongation;
  _attribute[kappa.i].restriction = curvature_restriction;






  scalar k=new_scalar("k");
  scalar_clone (k, kappa);

  { static ForeachData _loop = { "/root/mnt/basilisk/src/curvature.h", 569, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 569 "/root/mnt/basilisk/src/curvature.h" 3 4
 0
# 569 "/root/mnt/basilisk/src/curvature.h"
 ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point); {




_stencil_interfacial (point, c);{
      {stencil_val_a (point, k, 0, 0, 0, 
# 575 "/root/mnt/basilisk/src/curvature.h" 3 4
      0
# 575 "/root/mnt/basilisk/src/curvature.h"
      , "/root/mnt/basilisk/src/curvature.h", 575); }





{stencil_val_a (point, k, 0, 0, 0, 
# 581 "/root/mnt/basilisk/src/curvature.h" 3 4
0
# 581 "/root/mnt/basilisk/src/curvature.h"
, "/root/mnt/basilisk/src/curvature.h", 581); _stencil_height_curvature (point, c, h);{

{stencil_val_a (point, k, 0, 0, 0, 
# 583 "/root/mnt/basilisk/src/curvature.h" 3 4
0
# 583 "/root/mnt/basilisk/src/curvature.h"
, "/root/mnt/basilisk/src/curvature.h", 583); _stencil_height_curvature_fit (point, c, h);
          }}
# 584 "/root/mnt/basilisk/src/curvature.h"
}}
# 585 "/root/mnt/basilisk/src/curvature.h"
}end_stencil (&_loop); _loop.first = 0;};




{
# 569 "/root/mnt/basilisk/src/curvature.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {




    if (!interfacial (point, c))
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(k.i)] = ((double)1e30);





    else if ((((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(k.i)] = height_curvature (point, c, h)) != ((double)1e30))
      sh++;
    else if ((((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(k.i)] = height_curvature_fit (point, c, h)) != ((double)1e30))
      f++;
  }} } };;;


}
# 587 "/root/mnt/basilisk/src/curvature.h"
{ static ForeachData _loop = { "/root/mnt/basilisk/src/curvature.h", 587, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 587 "/root/mnt/basilisk/src/curvature.h" 3 4
0
# 587 "/root/mnt/basilisk/src/curvature.h"
; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point); {






stencil_val (point, k, 0, 0, 0, "/root/mnt/basilisk/src/curvature.h", 594, 
# 594 "/root/mnt/basilisk/src/curvature.h" 3 4
0
# 594 "/root/mnt/basilisk/src/curvature.h"
);{
      { stencil_val (point, k, 0, 0, 0, "/root/mnt/basilisk/src/curvature.h", 595, 
# 595 "/root/mnt/basilisk/src/curvature.h" 3 4
       0
# 595 "/root/mnt/basilisk/src/curvature.h"
       ); }
{_stencil_interfacial (point, c);{ {






      {{ int _nn = 1 + 0 ? 1 + 0 : 2; int _i = point.i, _j = point.j; for (int _k = - _nn; _k <= _nn; _k++) { point.i = _i + _k; for (int _l = - _nn; _l <= _nn; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
 {stencil_val (point, k, 0, 0, 0, "/root/mnt/basilisk/src/curvature.h", 604, 
# 604 "/root/mnt/basilisk/src/curvature.h" 3 4
 0
# 604 "/root/mnt/basilisk/src/curvature.h"
 );
   { stencil_val (point, k, 0, 0, 0, "/root/mnt/basilisk/src/curvature.h", 605, 
# 605 "/root/mnt/basilisk/src/curvature.h" 3 4
    0
# 605 "/root/mnt/basilisk/src/curvature.h"
    ); } }} } point.i = _i; point.j = _j;}}







{ _stencil_centroids_curvature_fit (point, c); }
# 614 "/root/mnt/basilisk/src/curvature.h"
}

}
# 616 "/root/mnt/basilisk/src/curvature.h"
}}




{
      {stencil_val_a (point, kappa, 0, 0, 0, 
# 622 "/root/mnt/basilisk/src/curvature.h" 3 4
      0
# 622 "/root/mnt/basilisk/src/curvature.h"
      , "/root/mnt/basilisk/src/curvature.h", 622); }
if (p.add)
      {stencil_val_a (point, kappa, 0, 0, 0, 
# 624 "/root/mnt/basilisk/src/curvature.h" 3 4
      1
# 624 "/root/mnt/basilisk/src/curvature.h"
      , "/root/mnt/basilisk/src/curvature.h", 624); }
    else
      {stencil_val_a (point, kappa, 0, 0, 0, 
# 626 "/root/mnt/basilisk/src/curvature.h" 3 4
      0
# 626 "/root/mnt/basilisk/src/curvature.h"
      , "/root/mnt/basilisk/src/curvature.h", 626); }}
# 627 "/root/mnt/basilisk/src/curvature.h"
}end_stencil (&_loop); _loop.first = 0;};




{
# 587 "/root/mnt/basilisk/src/curvature.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {





    double kf;
    if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(k.i)] < ((double)1e30))
      kf = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(k.i)];
    else if (interfacial (point, c)) {





      double sk = 0., a = 0.;
      {{ int _nn = 1 + 0 ? 1 + 0 : 2; int _i = point.i, _j = point.j; for (int _k = - _nn; _k <= _nn; _k++) { point.i = _i + _k; for (int _l = - _nn; _l <= _nn; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
 if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(k.i)] < ((double)1e30))
   sk += ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(k.i)], a++;} } point.i = _i; point.j = _j;}}
      if (a > 0.)
 kf = sk/a, sa++;
      else




 kf = centroids_curvature_fit (point, c), sc++;
    }
    else
      kf = ((double)1e30);




    if (kf == ((double)1e30))
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(kappa.i)] = ((double)1e30);
    else if (p.add)
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(kappa.i)] += sigma*kf;
    else
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(kappa.i)] = sigma*kf;
  }} } };;;


}
# 629 "/root/mnt/basilisk/src/curvature.h"
{ cstats _ret= (cstats){sh, f, sa, sc};delete((scalar*)((scalar[]){k,{-1}}));if(!(ch).x.i)delete((scalar*)((vector[]){h,{{-1},{-1}}}));{;return _ret;}}delete((scalar*)((scalar[]){k,{-1}}));
;}
# 649 "/root/mnt/basilisk/src/curvature.h"

static double pos_x (Point point, vector h, coord * G, coord * Z)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  if (fabs(height(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.x.i)])) > 1.)
    return ((double)1e30);
  coord o = {x, y, z};
  o.x += height(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.x.i)])*Delta;
  double pos = 0.;

    pos += (o.x - Z->x)*G->x;
# 658 "/root/mnt/basilisk/src/curvature.h"
pos += (o.y - Z->y)*G->y;
  return pos;
}
# 650 "/root/mnt/basilisk/src/curvature.h"
static double pos_y (Point point, vector h, coord * G, coord * Z)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
  if (fabs(height(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.y.i)])) > 1.)
    return ((double)1e30);
  coord o = {x, y, z};
  o.y += height(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(h.y.i)])*Delta;
  double pos = 0.;

    pos += (o.y - Z->y)*G->y;
# 658 "/root/mnt/basilisk/src/curvature.h"
pos += (o.x - Z->x)*G->x;
  return pos;
}







static double height_position (Point point, scalar f, vector h,
          coord * G, coord * Z)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;






  typedef struct {
    double n;
    double (* pos) (Point, vector, coord *, coord *);
  } NormPos;
  struct { NormPos x, y, z; } n;

    n.x.n = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+1][point.j+0]) ) + sizeof(Cell)))[(f.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+-1][point.j+0]) ) + sizeof(Cell)))[(f.i)], n.x.pos = pos_x;
# 683 "/root/mnt/basilisk/src/curvature.h"
n.y.n = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+1]) ) + sizeof(Cell)))[(f.i)] - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+-1]) ) + sizeof(Cell)))[(f.i)], n.y.pos = pos_y;




  if (fabs(n.x.n) < fabs(n.y.n))
    do { NormPos __tmp = n.x; n.x = n.y; n.y = __tmp; } while(0);
# 700 "/root/mnt/basilisk/src/curvature.h"
  double pos = ((double)1e30);

    if (pos == ((double)1e30))
      pos = n.x.pos (point, h, G, Z);
# 702 "/root/mnt/basilisk/src/curvature.h"
if (pos == ((double)1e30))
      pos = n.y.pos (point, h, G, Z);

  return pos;
}
# 668 "/root/mnt/basilisk/src/curvature.h"
static void _stencil_height_position (Point point, scalar f, vector h,
          coord * G, coord * Z)
{int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 683 "/root/mnt/basilisk/src/curvature.h"
    { stencil_val (point, f, 1, 0, 0, "/root/mnt/basilisk/src/curvature.h", 683, 
# 683 "/root/mnt/basilisk/src/curvature.h" 3 4
     0
# 683 "/root/mnt/basilisk/src/curvature.h"
     ); stencil_val (point, f, -1, 0, 0, "/root/mnt/basilisk/src/curvature.h", 683, 
# 683 "/root/mnt/basilisk/src/curvature.h" 3 4
                            0
# 683 "/root/mnt/basilisk/src/curvature.h"
                            ); }
# 683 "/root/mnt/basilisk/src/curvature.h"
{ stencil_val (point, f, 0, 1, 0, "/root/mnt/basilisk/src/curvature.h", 683, 
# 683 "/root/mnt/basilisk/src/curvature.h" 3 4
 0
# 683 "/root/mnt/basilisk/src/curvature.h"
 ); stencil_val (point, f, 0, -1, 0, "/root/mnt/basilisk/src/curvature.h", 683, 
# 683 "/root/mnt/basilisk/src/curvature.h" 3 4
                        0
# 683 "/root/mnt/basilisk/src/curvature.h"
                        ); }
# 700 "/root/mnt/basilisk/src/curvature.h"





  return ;
}
# 717 "/root/mnt/basilisk/src/curvature.h"
struct Position {
  scalar f, pos;
  coord G, Z;
  
# 720 "/root/mnt/basilisk/src/curvature.h" 3 4
 _Bool 
# 720 "/root/mnt/basilisk/src/curvature.h"
      add;
};

void position (struct Position p)
{
  scalar f = p.f, pos = p.pos;
  coord * G = &p.G, * Z = &p.Z;






  _attribute[pos.i].refine = _attribute[pos.i].prolongation = curvature_prolongation;
  _attribute[pos.i].restriction = curvature_restriction;


  vector fh = _attribute[f.i].height, h=(fh).x.i?(fh):new_vector("h");
  if (!fh.x.i)
    heights (f, h);
  { static ForeachData _loop = { "/root/mnt/basilisk/src/curvature.h", 740, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 740 "/root/mnt/basilisk/src/curvature.h" 3 4
 0
# 740 "/root/mnt/basilisk/src/curvature.h"
 ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point); {
_stencil_interfacial (point, f);{ {
       _stencil_height_position (point, f, h, G, Z);
{





  _stencil_mycs (point, f);
 stencil_val (point, f, 0, 0, 0, "/root/mnt/basilisk/src/curvature.h", 750, 
# 750 "/root/mnt/basilisk/src/curvature.h" 3 4
0
# 750 "/root/mnt/basilisk/src/curvature.h"
);




      }
# 756 "/root/mnt/basilisk/src/curvature.h"
if (p.add)
 {stencil_val_a (point, pos, 0, 0, 0, 
# 757 "/root/mnt/basilisk/src/curvature.h" 3 4
 1
# 757 "/root/mnt/basilisk/src/curvature.h"
 , "/root/mnt/basilisk/src/curvature.h", 757); }
      else
 {stencil_val_a (point, pos, 0, 0, 0, 
# 759 "/root/mnt/basilisk/src/curvature.h" 3 4
 0
# 759 "/root/mnt/basilisk/src/curvature.h"
 , "/root/mnt/basilisk/src/curvature.h", 759); }
    }

{stencil_val_a (point, pos, 0, 0, 0, 
# 762 "/root/mnt/basilisk/src/curvature.h" 3 4
0
# 762 "/root/mnt/basilisk/src/curvature.h"
, "/root/mnt/basilisk/src/curvature.h", 762); }}
# 763 "/root/mnt/basilisk/src/curvature.h"
}end_stencil (&_loop); _loop.first = 0;};
  {
# 740 "/root/mnt/basilisk/src/curvature.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
    if (interfacial (point, f)) {
      double hp = height_position (point, f, h, G, Z);
      if (hp == ((double)1e30)) {





 coord n = mycs (point, f), o = {x,y,z}, c;
 double alpha = line_alpha (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)], n);
 line_length_center(n,alpha,&c);
 hp = 0.;

   hp += (o.x + Delta*c.x - Z->x)*G->x;
# 754 "/root/mnt/basilisk/src/curvature.h"
hp += (o.y + Delta*c.y - Z->y)*G->y;
      }
      if (p.add)
 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(pos.i)] += hp;
      else
 ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(pos.i)] = hp;
    }
    else
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(pos.i)] = ((double)1e30);
  }} } };}if(!(fh).x.i)delete((scalar*)((vector[]){h,{{-1},{-1}}}));
}
# 17 "/root/mnt/basilisk/src/tension.h"
# 36 "/root/mnt/basilisk/src/tension.h"
static int stability_1_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;} static int stability_1(const int i,const double t,Event *_ev){;
{





  double amin = ((double)1e30), amax = -((double)1e30), dmin = ((double)1e30);
  { static ForeachData _loop = { "/root/mnt/basilisk/src/tension.h", 44, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 44 "/root/mnt/basilisk/src/tension.h" 3 4
 0
# 44 "/root/mnt/basilisk/src/tension.h"
 ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point);{{ _loop.face |= (1 << 0);{
    {stencil_val (point, fm.x, 0, 0, 0, "/root/mnt/basilisk/src/tension.h", 45, 
# 45 "/root/mnt/basilisk/src/tension.h" 3 4
    0
# 45 "/root/mnt/basilisk/src/tension.h"
    ); {
stencil_val (point, alpha.x, 0, 0, 0, "/root/mnt/basilisk/src/tension.h", 46, 
# 46 "/root/mnt/basilisk/src/tension.h" 3 4
0
# 46 "/root/mnt/basilisk/src/tension.h"
);stencil_val (point, fm.x, 0, 0, 0, "/root/mnt/basilisk/src/tension.h", 46, 
# 46 "/root/mnt/basilisk/src/tension.h" 3 4
                           0
# 46 "/root/mnt/basilisk/src/tension.h"
                           ); { stencil_val (point, alpha.x, 0, 0, 0, "/root/mnt/basilisk/src/tension.h", 46, 
# 46 "/root/mnt/basilisk/src/tension.h" 3 4
                                                       0
# 46 "/root/mnt/basilisk/src/tension.h"
                                                       );stencil_val (point, fm.x, 0, 0, 0, "/root/mnt/basilisk/src/tension.h", 46, 
# 46 "/root/mnt/basilisk/src/tension.h" 3 4
                                                                                   0
# 46 "/root/mnt/basilisk/src/tension.h"
                                                                                   ); }
stencil_val (point, alpha.x, 0, 0, 0, "/root/mnt/basilisk/src/tension.h", 47, 
# 47 "/root/mnt/basilisk/src/tension.h" 3 4
0
# 47 "/root/mnt/basilisk/src/tension.h"
);stencil_val (point, fm.x, 0, 0, 0, "/root/mnt/basilisk/src/tension.h", 47, 
# 47 "/root/mnt/basilisk/src/tension.h" 3 4
                           0
# 47 "/root/mnt/basilisk/src/tension.h"
                           ); { stencil_val (point, alpha.x, 0, 0, 0, "/root/mnt/basilisk/src/tension.h", 47, 
# 47 "/root/mnt/basilisk/src/tension.h" 3 4
                                                       0
# 47 "/root/mnt/basilisk/src/tension.h"
                                                       );stencil_val (point, fm.x, 0, 0, 0, "/root/mnt/basilisk/src/tension.h", 47, 
# 47 "/root/mnt/basilisk/src/tension.h" 3 4
                                                                                   0
# 47 "/root/mnt/basilisk/src/tension.h"
                                                                                   ); }
# 49 "/root/mnt/basilisk/src/tension.h"
} }}}
# 44 "/root/mnt/basilisk/src/tension.h"
{ _loop.face |= (1 << 1);{
    {stencil_val (point, fm.y, 0, 0, 0, "/root/mnt/basilisk/src/tension.h", 45, 
# 45 "/root/mnt/basilisk/src/tension.h" 3 4
    0
# 45 "/root/mnt/basilisk/src/tension.h"
    ); {
stencil_val (point, alpha.y, 0, 0, 0, "/root/mnt/basilisk/src/tension.h", 46, 
# 46 "/root/mnt/basilisk/src/tension.h" 3 4
0
# 46 "/root/mnt/basilisk/src/tension.h"
);stencil_val (point, fm.y, 0, 0, 0, "/root/mnt/basilisk/src/tension.h", 46, 
# 46 "/root/mnt/basilisk/src/tension.h" 3 4
                           0
# 46 "/root/mnt/basilisk/src/tension.h"
                           ); { stencil_val (point, alpha.y, 0, 0, 0, "/root/mnt/basilisk/src/tension.h", 46, 
# 46 "/root/mnt/basilisk/src/tension.h" 3 4
                                                       0
# 46 "/root/mnt/basilisk/src/tension.h"
                                                       );stencil_val (point, fm.y, 0, 0, 0, "/root/mnt/basilisk/src/tension.h", 46, 
# 46 "/root/mnt/basilisk/src/tension.h" 3 4
                                                                                   0
# 46 "/root/mnt/basilisk/src/tension.h"
                                                                                   ); }
stencil_val (point, alpha.y, 0, 0, 0, "/root/mnt/basilisk/src/tension.h", 47, 
# 47 "/root/mnt/basilisk/src/tension.h" 3 4
0
# 47 "/root/mnt/basilisk/src/tension.h"
);stencil_val (point, fm.y, 0, 0, 0, "/root/mnt/basilisk/src/tension.h", 47, 
# 47 "/root/mnt/basilisk/src/tension.h" 3 4
                           0
# 47 "/root/mnt/basilisk/src/tension.h"
                           ); { stencil_val (point, alpha.y, 0, 0, 0, "/root/mnt/basilisk/src/tension.h", 47, 
# 47 "/root/mnt/basilisk/src/tension.h" 3 4
                                                       0
# 47 "/root/mnt/basilisk/src/tension.h"
                                                       );stencil_val (point, fm.y, 0, 0, 0, "/root/mnt/basilisk/src/tension.h", 47, 
# 47 "/root/mnt/basilisk/src/tension.h" 3 4
                                                                                   0
# 47 "/root/mnt/basilisk/src/tension.h"
                                                                                   ); }
# 49 "/root/mnt/basilisk/src/tension.h"
} }}}}end_stencil (&_loop); _loop.first = 0;};
# 44 "/root/mnt/basilisk/src/tension.h"
if(!((fm.x).i >= 65536) && !((alpha.x).i >= 65536)){


{
# 44 "/root/mnt/basilisk/src/tension.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{
    if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)] > 0.) {
      if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.x.i)]/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)] > amax) amax = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.x.i)]/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)];
      if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.x.i)]/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)] < amin) amin = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.x.i)]/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)];
      if (Delta < dmin) dmin = Delta;
    }}}}
# 44 "/root/mnt/basilisk/src/tension.h"
{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{
    if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)] > 0.) {
      if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.y.i)]/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)] > amax) amax = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.y.i)]/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)];
      if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.y.i)]/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)] < amin) amin = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.y.i)]/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)];
      if (Delta < dmin) dmin = Delta;
    }}}}}} } };;;;


}
# 49 "/root/mnt/basilisk/src/tension.h"
}else if(((fm.x).i >= 65536) && !((alpha.x).i >= 65536)){struct{double x,y;}_const_fm={_constant[fm.x.i-65536],_constant[fm.y.i-65536]};(void)(_const_fm);



{
# 44 "/root/mnt/basilisk/src/tension.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{
    if (_const_fm.x > 0.) {
      if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.x.i)]/_const_fm.x > amax) amax = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.x.i)]/_const_fm.x;
      if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.x.i)]/_const_fm.x < amin) amin = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.x.i)]/_const_fm.x;
      if (Delta < dmin) dmin = Delta;
    }}}}
# 44 "/root/mnt/basilisk/src/tension.h"
{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{
    if (_const_fm.y > 0.) {
      if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.y.i)]/_const_fm.y > amax) amax = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.y.i)]/_const_fm.y;
      if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.y.i)]/_const_fm.y < amin) amin = ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(alpha.y.i)]/_const_fm.y;
      if (Delta < dmin) dmin = Delta;
    }}}}}} } };;;;


}
# 49 "/root/mnt/basilisk/src/tension.h"
}else if(!((fm.x).i >= 65536) && ((alpha.x).i >= 65536)){struct{double x,y;}_const_alpha={_constant[alpha.x.i-65536],_constant[alpha.y.i-65536]};(void)(_const_alpha);



{
# 44 "/root/mnt/basilisk/src/tension.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{
    if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)] > 0.) {
      if (_const_alpha.x/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)] > amax) amax = _const_alpha.x/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)];
      if (_const_alpha.x/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)] < amin) amin = _const_alpha.x/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.x.i)];
      if (Delta < dmin) dmin = Delta;
    }}}}
# 44 "/root/mnt/basilisk/src/tension.h"
{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{
    if (((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)] > 0.) {
      if (_const_alpha.y/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)] > amax) amax = _const_alpha.y/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)];
      if (_const_alpha.y/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)] < amin) amin = _const_alpha.y/((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(fm.y.i)];
      if (Delta < dmin) dmin = Delta;
    }}}}}} } };;;;


}
# 49 "/root/mnt/basilisk/src/tension.h"
}else {struct{double x,y;}_const_fm={_constant[fm.x.i-65536],_constant[fm.y.i-65536]};(void)(_const_fm);struct{double x,y;}_const_alpha={_constant[alpha.x.i-65536],_constant[alpha.y.i-65536]};(void)(_const_alpha);



{
# 44 "/root/mnt/basilisk/src/tension.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{
    if (_const_fm.x > 0.) {
      if (_const_alpha.x/_const_fm.x > amax) amax = _const_alpha.x/_const_fm.x;
      if (_const_alpha.x/_const_fm.x < amin) amin = _const_alpha.x/_const_fm.x;
      if (Delta < dmin) dmin = Delta;
    }}}}
# 44 "/root/mnt/basilisk/src/tension.h"
{ int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_y) {{
    if (_const_fm.y > 0.) {
      if (_const_alpha.y/_const_fm.y > amax) amax = _const_alpha.y/_const_fm.y;
      if (_const_alpha.y/_const_fm.y < amin) amin = _const_alpha.y/_const_fm.y;
      if (Delta < dmin) dmin = Delta;
    }}}}}} } };;;;


}
# 49 "/root/mnt/basilisk/src/tension.h"
}
  double rhom = (1./amin + 1./amax)/2.;





  double sigma = 0.;
  {scalar*_i=(scalar*)( interfaces);if(_i)for(scalar c=*_i;(&c)->i>=0;c=*++_i){
    sigma += _attribute[c.i].sigma;}}
  if (sigma) {
    double dt = sqrt (rhom*((dmin)*(dmin)*(dmin))/(3.14159265358979*sigma));
    if (dt < dtmax)
      dtmax = dt;
  }
}{;return 0;};}







static int acceleration_1_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;} static int acceleration_1(const int i,const double t,Event *_ev){;
{




  {scalar*_i=(scalar*)( interfaces);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
    if (_attribute[f.i].sigma) {





      scalar phi = _attribute[f.i].phi;
      if (phi.i)
 curvature ((struct Curvature){f, phi, _attribute[f.i].sigma, .add = 
# 87 "/root/mnt/basilisk/src/tension.h" 3 4
                                                                    1
# 87 "/root/mnt/basilisk/src/tension.h"
                                                                        });
      else {
 phi = new_scalar("phi");
 curvature ((struct Curvature){f, phi, _attribute[f.i].sigma, .add = 
# 90 "/root/mnt/basilisk/src/tension.h" 3 4
                                                                    0
# 90 "/root/mnt/basilisk/src/tension.h"
                                                                         });
 _attribute[f.i].phi = phi;
      }
    }}}
}{;return 0;};}
# 50 "rising.c"
static double _boundary4(Point point,Point neighbor,scalar _s,void *data){int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;(void)(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;return (2.*(0) - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(_s.i)]);}}static double _boundary4_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;(void)(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;return (- ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(_s.i)]);}}
static double _boundary5(Point point,Point neighbor,scalar _s,void *data){int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;(void)(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;return (2.*(0) - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(_s.i)]);}}static double _boundary5_homogeneous(Point point,Point neighbor,scalar _s,void *data){int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;(void)(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;return (- ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(_s.i)]);}}





static double _boundary6(Point point,Point neighbor,scalar _s,void *data){int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;(void)(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;return 0.;}}
static double _boundary7(Point point,Point neighbor,scalar _s,void *data){int ig=0;(void)(ig);int jg=0;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;(void)(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;(void)(jg);double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;return 0.;}}

int main()
{_init_solver();



  size(2);
  init_grid(1 << 9);




  rho1 = 1000., mu1 = 10.;




  rho2 = 1., mu2 = 0.1, _attribute[f.i].sigma = 1.96;


  TOLERANCE = 1e-4;




  run();
free_solver();}


static int init_0_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(t = 0);*ip=i;*tp=t;return ret;} static int init_0(const int i,const double t,Event *_ev){;
{





  { {{ Point root = {2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point = {0}; struct { int l, i, j, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; }; if (!(((point.i+0) >= (((Tree *)grid)->L[point.level]->m)->r1.start && (point.i+0) < (((Tree *)grid)->L[point.level]->m->r1.end) && (((Tree *)grid)->L[point.level]->m)->b[point.i+0] && (point.j+0) >= (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].start && (point.j+0) < (((Tree *)grid)->L[point.level]->m)->r2[point.i+0].end && (((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; if (point.level == grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 8; }; } else { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; }; if (!(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & leaf)) { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; }; if (!(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & leaf)) { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; }; if (!(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & leaf)) { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 4; }; if (!(((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & leaf)) { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; default: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { if ((((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ))))).flags & leaf)) { int bid = (y > 0.5 ? top : -1); if (bid >= 0) (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).pid = - bid - 1; } else { int pid = -1; {{ int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; if ((*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).pid >= 0 || pid < 0) pid = (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).pid;} } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}} (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).pid = pid; if (pid < 0) { (*((Cell *)((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) )))).flags |= leaf; decrement_neighbors (point); } } }} } } } };} ((Tree *)grid)->dirty = 
# 95 "rising.c" 3 4
                                                                                                                                                                                                                                                                                                                                                                                  1
# 95 "rising.c"
                                                                                                                                                                                                                                                                                                                                                                                      ; };


  do { scalar phi=new_vertex_scalar("phi"); { static ForeachData _loop = { "rising.c", 98, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 98 "rising.c" 3 4
                                            0
# 98 "rising.c"
                                            ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point); _loop.vertex = 
# 98 "rising.c" 3 4
                                            1
# 98 "rising.c"
                                            ; {stencil_val_a (point, phi, 0, 0, 0, 
# 98 "rising.c" 3 4
                                                                      0
# 98 "rising.c"
                                                                      , "rising.c", 98); }end_stencil (&_loop); _loop.first = 0;}; {{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->vertices.n; _k++) { point.i = ((Tree *)grid)->vertices.p[_k].i; point.j = ((Tree *)grid)->vertices.p[_k].j; point.level = ((Tree *)grid)->vertices.p[_k].level; _flags = ((Tree *)grid)->vertices.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { x -= Delta/2.; y -= Delta/2.; ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(phi.i)] = ((x - 0.5)*(x - 0.5)) + ((y)*(y)) - ((0.25)*(0.25));} } } };} fractions ((struct Fractions){phi, f});delete((scalar*)((scalar[]){phi,{-1}})); } while(0);
}{;return 0;};}




static int acceleration_2_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;} static int acceleration_2(const int i,const double t,Event *_ev){;
{
  vector av = a;
  { static ForeachData _loop = { "rising.c", 107, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 107 "rising.c" 3 4
 0
# 107 "rising.c"
 ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point);{ _loop.face |= (1 << 0);{
      {stencil_val_a (point, av.x, 0, 0, 0, 
# 108 "rising.c" 3 4
      1
# 108 "rising.c"
      , "rising.c", 108); }}}end_stencil (&_loop); _loop.first = 0;};
  {
# 107 "rising.c"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{ int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if (_flags & face_x) {{
      ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(av.x.i)] -= 0.98;}}}} } };}
}{;return 0;};}
# 158 "rising.c"
static int logfile_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++);*ip=i;*tp=t;return ret;} static int logfile(const int i,const double t,Event *_ev){;
{

  char nameF[80] = "rising_output_9_2/log_file.txt";
  static FILE * fp1;

  double xb = 0., vb = 0., sb = 0.;
  { static ForeachData _loop = { "rising.c", 165, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 165 "rising.c" 3 4
 0
# 165 "rising.c"
 ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point);



  {


    stencil_val (point, cm, 0, 0, 0, "rising.c", 172, 
# 172 "rising.c" 3 4
   0
# 172 "rising.c"
   ); stencil_val (point, f, 0, 0, 0, "rising.c", 172, 
# 172 "rising.c" 3 4
                           0
# 172 "rising.c"
                           );

stencil_val (point, u.x, 0, 0, 0, "rising.c", 174, 
# 174 "rising.c" 3 4
0
# 174 "rising.c"
);
# 176 "rising.c"
}end_stencil (&_loop); _loop.first = 0;};
# 165 "rising.c"
if(!((cm).i >= 65536)){





                           {
# 165 "rising.c"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;



  {


    double dv = (1. - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)]) * (((Delta)*(Delta))*((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(cm.i)]);
    xb += x * dv;
    vb += ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.x.i)] * dv;
    sb += dv;
  }} } };;;;


}
# 176 "rising.c"
}else {double _const_cm=_constant[cm.i-65536];(void)(_const_cm);






                           {
# 165 "rising.c"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;



  {


    double dv = (1. - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)]) * (((Delta)*(Delta))*_const_cm);
    xb += x * dv;
    vb += ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.x.i)] * dv;
    sb += dv;
  }} } };;;;


}
# 176 "rising.c"
}

    if (i==0)
    {

        fp1 = fopen (nameF, "w");


        fprintf (fp1, "%g %g %g %g %g %g %g",
                t, sb, xb / sb, vb / sb, dt, perf.t, perf.speed);
        fprintf(fp1, "\r\n");
        fclose(fp1);
    }
    else
    {

        fp1 = fopen (nameF, "a");
        fprintf (fp1, "%g %g %g %g %g %g %g",
                t, sb, xb / sb, vb / sb, dt, perf.t, perf.speed);
        fprintf(fp1, "\r\n");
        fclose(fp1);
    }
}{;return 0;};}



static int output_field_bolla_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=( t <= 6.0001);*ip=i;*tp=t;return ret;}static int output_field_bolla_expr1(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=( t += 0.1);*ip=i;*tp=t;return ret;}static int output_field_bolla_expr2(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(t = 0.0);*ip=i;*tp=t;return ret;} static int output_field_bolla(const int i,const double t,Event *_ev){;
{

    char nameF[80];
    sprintf (nameF, "rising_output_9_2/output_field_bolla-%2.1f.txt", t);


    scalar vort=new_scalar("vort");
    vorticity (u, vort);

    static FILE * fp2;

     if (i == 0) {
       fp2 = fopen (nameF, "w");
       { static ForeachData _loop = { "rising.c", 216, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 216 "rising.c" 3 4
      0
# 216 "rising.c"
      ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point);
       {
stencil_val (point, u.x, 0, 0, 0, "rising.c", 218, 
# 218 "rising.c" 3 4
0
# 218 "rising.c"
); stencil_val (point, f, 0, 0, 0, "rising.c", 218, 
# 218 "rising.c" 3 4
                        0
# 218 "rising.c"
                        );stencil_val (point, u.y, 0, 0, 0, "rising.c", 218, 
# 218 "rising.c" 3 4
                                              0
# 218 "rising.c"
                                              ); stencil_val (point, f, 0, 0, 0, "rising.c", 218, 
# 218 "rising.c" 3 4
                                                                       0
# 218 "rising.c"
                                                                       ); stencil_val (point, p, 0, 0, 0, "rising.c", 218, 
# 218 "rising.c" 3 4
                                                                                              0
# 218 "rising.c"
                                                                                              ); stencil_val (point, f, 0, 0, 0, "rising.c", 218, 
# 218 "rising.c" 3 4
                                                                                                                     0
# 218 "rising.c"
                                                                                                                     ); stencil_val (point, vort, 0, 0, 0, "rising.c", 218, 
# 218 "rising.c" 3 4
                                                                                                                                            0
# 218 "rising.c"
                                                                                                                                            ); stencil_val (point, f, 0, 0, 0, "rising.c", 218, 
# 218 "rising.c" 3 4
                                                                                                                                                                      0
# 218 "rising.c"
                                                                                                                                                                      );
# 219 "rising.c"
}end_stencil (&_loop); _loop.first = 0;};
       {
# 216 "rising.c"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
       {
         fprintf (fp2, "%f %f %f %f %f %f\r\n",x,y,((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.x.i)]*(1. - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)]) ,((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.y.i)]*(1. - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)]), ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(p.i)]*(1. - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)]), ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(vort.i)]*(1. - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)]));
       }} } };}
       fclose(fp2);
     } else {
       fp2 = fopen (nameF, "a");
       { static ForeachData _loop = { "rising.c", 223, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 223 "rising.c" 3 4
      0
# 223 "rising.c"
      ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point);
       {
stencil_val (point, u.x, 0, 0, 0, "rising.c", 225, 
# 225 "rising.c" 3 4
0
# 225 "rising.c"
); stencil_val (point, f, 0, 0, 0, "rising.c", 225, 
# 225 "rising.c" 3 4
                        0
# 225 "rising.c"
                        );stencil_val (point, u.y, 0, 0, 0, "rising.c", 225, 
# 225 "rising.c" 3 4
                                              0
# 225 "rising.c"
                                              ); stencil_val (point, f, 0, 0, 0, "rising.c", 225, 
# 225 "rising.c" 3 4
                                                                       0
# 225 "rising.c"
                                                                       ); stencil_val (point, p, 0, 0, 0, "rising.c", 225, 
# 225 "rising.c" 3 4
                                                                                              0
# 225 "rising.c"
                                                                                              ); stencil_val (point, f, 0, 0, 0, "rising.c", 225, 
# 225 "rising.c" 3 4
                                                                                                                     0
# 225 "rising.c"
                                                                                                                     ); stencil_val (point, vort, 0, 0, 0, "rising.c", 225, 
# 225 "rising.c" 3 4
                                                                                                                                            0
# 225 "rising.c"
                                                                                                                                            ); stencil_val (point, f, 0, 0, 0, "rising.c", 225, 
# 225 "rising.c" 3 4
                                                                                                                                                                      0
# 225 "rising.c"
                                                                                                                                                                      );
# 226 "rising.c"
}end_stencil (&_loop); _loop.first = 0;};
       {
# 223 "rising.c"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
       {
         fprintf (fp2, "%f %f %f %f %f %f\r\n",x,y,((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.x.i)]*(1. - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)]),((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.y.i)]*(1. - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)]), ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(p.i)]*(1. - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)]), ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(vort.i)]*(1. - ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)]));
       }} } };}
       fclose(fp2);
   }delete((scalar*)((scalar[]){vort,{-1}}));





}{;return 0;};}

static int output_field_fuori_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=( t <= 6.0001);*ip=i;*tp=t;return ret;}static int output_field_fuori_expr1(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=( t += 0.1);*ip=i;*tp=t;return ret;}static int output_field_fuori_expr2(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(t = 0.0);*ip=i;*tp=t;return ret;} static int output_field_fuori(const int i,const double t,Event *_ev){;
{

    char nameF[80];
    sprintf (nameF, "rising_output_9_2/output_field-%2.1f.txt", t);


    scalar vort=new_scalar("vort");
    vorticity (u, vort);

    static FILE * fp2;

     if (i == 0) {
       fp2 = fopen (nameF, "w");
       { static ForeachData _loop = { "rising.c", 250, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 250 "rising.c" 3 4
      0
# 250 "rising.c"
      ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point);
       {
stencil_val (point, u.x, 0, 0, 0, "rising.c", 252, 
# 252 "rising.c" 3 4
0
# 252 "rising.c"
);stencil_val (point, f, 0, 0, 0, "rising.c", 252, 
# 252 "rising.c" 3 4
                       0
# 252 "rising.c"
                       );stencil_val (point, u.y, 0, 0, 0, "rising.c", 252, 
# 252 "rising.c" 3 4
                                             0
# 252 "rising.c"
                                             );stencil_val (point, f, 0, 0, 0, "rising.c", 252, 
# 252 "rising.c" 3 4
                                                                     0
# 252 "rising.c"
                                                                     ); stencil_val (point, p, 0, 0, 0, "rising.c", 252, 
# 252 "rising.c" 3 4
                                                                                            0
# 252 "rising.c"
                                                                                            );stencil_val (point, f, 0, 0, 0, "rising.c", 252, 
# 252 "rising.c" 3 4
                                                                                                                  0
# 252 "rising.c"
                                                                                                                  ); stencil_val (point, vort, 0, 0, 0, "rising.c", 252, 
# 252 "rising.c" 3 4
                                                                                                                                         0
# 252 "rising.c"
                                                                                                                                         );stencil_val (point, f, 0, 0, 0, "rising.c", 252, 
# 252 "rising.c" 3 4
                                                                                                                                                                  0
# 252 "rising.c"
                                                                                                                                                                  );
# 253 "rising.c"
}end_stencil (&_loop); _loop.first = 0;};
       {
# 250 "rising.c"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
       {
         fprintf (fp2, "%f %f %f %f %f %f\r\n",x,y,((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.x.i)]*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)]) ,((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.y.i)]*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)]), ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(p.i)]*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)]), ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(vort.i)]*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)]));
       }} } };}
       fclose(fp2);
     } else {
       fp2 = fopen (nameF, "a");
       { static ForeachData _loop = { "rising.c", 257, 1, 0, 0 }; if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) { _attribute[s.i].input = _attribute[s.i].output = 
# 257 "rising.c" 3 4
      0
# 257 "rising.c"
      ; _attribute[s.i].width = 0; } int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; (void)(point);
       {
stencil_val (point, u.x, 0, 0, 0, "rising.c", 259, 
# 259 "rising.c" 3 4
0
# 259 "rising.c"
);stencil_val (point, f, 0, 0, 0, "rising.c", 259, 
# 259 "rising.c" 3 4
                       0
# 259 "rising.c"
                       );stencil_val (point, u.y, 0, 0, 0, "rising.c", 259, 
# 259 "rising.c" 3 4
                                             0
# 259 "rising.c"
                                             );stencil_val (point, f, 0, 0, 0, "rising.c", 259, 
# 259 "rising.c" 3 4
                                                                     0
# 259 "rising.c"
                                                                     ); stencil_val (point, p, 0, 0, 0, "rising.c", 259, 
# 259 "rising.c" 3 4
                                                                                            0
# 259 "rising.c"
                                                                                            );stencil_val (point, f, 0, 0, 0, "rising.c", 259, 
# 259 "rising.c" 3 4
                                                                                                                  0
# 259 "rising.c"
                                                                                                                  ); stencil_val (point, vort, 0, 0, 0, "rising.c", 259, 
# 259 "rising.c" 3 4
                                                                                                                                         0
# 259 "rising.c"
                                                                                                                                         );stencil_val (point, f, 0, 0, 0, "rising.c", 259, 
# 259 "rising.c" 3 4
                                                                                                                                                                  0
# 259 "rising.c"
                                                                                                                                                                  );
# 260 "rising.c"
}end_stencil (&_loop); _loop.first = 0;};
       {
# 257 "rising.c"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
       {
         fprintf (fp2, "%f %f %f %f %f %f\r\n",x,y,((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.x.i)]*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)]),((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(u.y.i)]*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)]), ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(p.i)]*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)]), ((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(vort.i)]*(((double *) ((((((Tree *)grid)->L[point.level]->m)->b[point.i+0][point.j+0]) ) + sizeof(Cell)))[(f.i)]));
       }} } };}
       fclose(fp2);
   }delete((scalar*)((scalar[]){vort,{-1}}));





}{;return 0;};}
# 290 "rising.c"
static int interface_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=( t <= 6.0001);*ip=i;*tp=t;return ret;}static int interface_expr1(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=( t += 0.1);*ip=i;*tp=t;return ret;}static int interface_expr2(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(t = 0.0);*ip=i;*tp=t;return ret;} static int interface(const int i,const double t,Event *_ev){;
{
    char nameF[80] = "rising_output_9_2/interface.txt";
    static FILE * fp5;

    if(i==0)
    {
      fp5 = fopen (nameF, "w");
      output_facets((struct OutputFacets){f, fp5});
    } else {
      fp5 = fopen (nameF, "a");
      output_facets((struct OutputFacets){f, fp5});
    }
  fprintf(fp5, "\n=====================\n");
  fclose(fp5);
}{;return 0;};}
# 322 "rising.c"
static int snapshot_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=( t += 0.1);*ip=i;*tp=t;return ret;}static int snapshot_expr1(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(t = 0);*ip=i;*tp=t;return ret;} static int snapshot(const int i,const double t,Event *_ev){;
{
  dump ((struct Dump){.file = "dump"});
  char nameGfs[80];
  sprintf (nameGfs, "rising_intermediateGfs/snapshot-%2.1f.gfs", t);
  output_gfs ((struct OutputGfs){.file = nameGfs, .t = t});
  char nameBview[80];
  sprintf (nameBview, "rising_intermediateBview/snapshot-%2.1f", t);
  dump ((struct Dump){.file = nameBview});
}{;return 0;};}
# 401 "rising.c"
static int velocity_grid_x_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(t += 0.1);*ip=i;*tp=t;return ret;} static int velocity_grid_x(const int i,const double t,Event *_ev){; {
  char name[80];
  sprintf (name, "rising_output_9_2/velocity_grid_x-%2.1f.txt", t);

  FILE*fp = fopen (name, "w");

  for (double x = 0; x <= 2.0; x += 0.02)
  {
    for (double y = 0; y <= 0.5; y += 0.02)
    {
        fprintf (fp, " %g ", interpolate ((struct _interpolate){u.x, x, y}));
    }
    fprintf (fp, " \n ");
  }
  fclose (fp);
}{;return 0;};}
static int velocity_grid_y_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(t += 0.1);*ip=i;*tp=t;return ret;} static int velocity_grid_y(const int i,const double t,Event *_ev){; {
  char name[80];
  sprintf (name, "rising_output_9_2/velocity_grid_y-%2.1f.txt", t);

  FILE*fp = fopen (name, "w");

  for (double x = 0; x <= 2.0; x += 0.02)
  {
    for (double y = 0; y <= 0.5; y += 0.02)
    {
        fprintf (fp, " %g ", interpolate ((struct _interpolate){u.y, x, y}));
    }
    fprintf (fp, " \n ");
  }
  fclose (fp);
}{;return 0;};}
static int pressure_grid_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(t += 0.1);*ip=i;*tp=t;return ret;} static int pressure_grid(const int i,const double t,Event *_ev){; {
  char name[80];
  sprintf (name, "rising_output_9_2/pressure_grid-%2.1f.txt", t);

  FILE*fp = fopen (name, "w");

  for (double x = 0; x <= 2.0; x += 0.02)
  {
    for (double y = 0; y <= 0.5; y += 0.02)
    {
        fprintf (fp, " %g ", interpolate ((struct _interpolate){p, x, y}));
    }
    fprintf (fp, " \n ");
  }
  fclose (fp);
}{;return 0;};}
static int vorticity_grid_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(t += 0.1);*ip=i;*tp=t;return ret;} static int vorticity_grid(const int i,const double t,Event *_ev){; {
  char name[80];
  sprintf (name, "rising_output_9_2/vorticty_grid-%2.1f.txt", t);

  FILE*fp = fopen (name, "w");

  scalar vort=new_scalar("vort");
  vorticity (u, vort);

  for (double x = 0; x <= 2.0; x += 0.02)
  {
    for (double y = 0; y <= 0.5; y += 0.02)
    {
        fprintf (fp, " %g ", interpolate ((struct _interpolate){vort, x, y}));
    }
    fprintf (fp, " \n ");
  }
  fclose (fp);delete((scalar*)((scalar[]){vort,{-1}}));
}{;return 0;};}
# 2 "ast/init_solver.h"

static void _init_solver (void)
{
  void init_solver();
  datasize=12*sizeof(double);init_solver();
  quadtree_methods();{ event_register((Event){0,1,defaults,{defaults_expr0},((int *)0),((double *)0),"/root/mnt/basilisk/src/run.h",42,"defaults"});
  event_register((Event){0,1,defaults_0,{defaults_0_expr0},((int *)0),((double *)0),"/root/mnt/basilisk/src/navier-stokes/centered.h",126,"defaults"});
  event_register((Event){0,1,default_display,{default_display_expr0},((int *)0),((double *)0),"/root/mnt/basilisk/src/navier-stokes/centered.h",179,"default_display"});
  event_register((Event){0,1,init,{init_expr0},((int *)0),((double *)0),"/root/mnt/basilisk/src/navier-stokes/centered.h",188,"init"});
  event_register((Event){0,1,defaults_1,{defaults_1_expr0},((int *)0),((double *)0),"/root/mnt/basilisk/src/vof.h",107,"defaults"});
  event_register((Event){0,1,defaults_2,{defaults_2_expr0},((int *)0),((double *)0),"/root/mnt/basilisk/src/vof.h",127,"defaults"});
  event_register((Event){0,1,defaults_3,{defaults_3_expr0},((int *)0),((double *)0),"/root/mnt/basilisk/src/two-phase.h",25,"defaults"});
  event_register((Event){0,1,defaults_4,{defaults_4_expr0},((int *)0),((double *)0),"/root/mnt/basilisk/src/iforce.h",30,"defaults"});
  event_register((Event){0,1,init_0,{init_0_expr0},((int *)0),((double *)0),"rising.c",88,"init"});
  event_register((Event){0,1,logfile,{logfile_expr0},((int *)0),((double *)0),"rising.c",158,"logfile"});
  event_register((Event){0,3,output_field_bolla,{output_field_bolla_expr0,output_field_bolla_expr1,output_field_bolla_expr2},((int *)0),((double *)0),"rising.c",202,"output_field_bolla"});
  event_register((Event){0,3,output_field_fuori,{output_field_fuori_expr0,output_field_fuori_expr1,output_field_fuori_expr2},((int *)0),((double *)0),"rising.c",236,"output_field_fuori"});
  event_register((Event){0,3,interface,{interface_expr0,interface_expr1,interface_expr2},((int *)0),((double *)0),"rising.c",290,"interface"});
  event_register((Event){0,2,snapshot,{snapshot_expr0,snapshot_expr1},((int *)0),((double *)0),"rising.c",322,"snapshot"});
  event_register((Event){0,1,velocity_grid_x,{velocity_grid_x_expr0},((int *)0),((double *)0),"rising.c",401,"velocity_grid_x"});
  event_register((Event){0,1,velocity_grid_y,{velocity_grid_y_expr0},((int *)0),((double *)0),"rising.c",417,"velocity_grid_y"});
  event_register((Event){0,1,pressure_grid,{pressure_grid_expr0},((int *)0),((double *)0),"rising.c",433,"pressure_grid"});
  event_register((Event){0,1,vorticity_grid,{vorticity_grid_expr0},((int *)0),((double *)0),"rising.c",449,"vorticity_grid"});




    init_const_vector((vector){{65536 +0},{65536 +1}},"zerof",(double[]) {0.,0.,0.});
  init_const_vector((vector){{65536 +2},{65536 +3}},"unityf",(double[]) {1.,1.,1.});
  init_const_scalar((scalar){65536 +4},"unity", 1.);
  init_const_scalar((scalar){65536 +5},"zeroc", 0.);
  event_register((Event){0,1,cleanup,{cleanup_expr0},((int *)0),((double *)0),"/root/mnt/basilisk/src/run.h",50,"cleanup"});
  init_scalar((scalar){0},"p");
  init_vector((vector){{1},{2}},"u");
  init_vector((vector){{3},{4}},"g");
  init_scalar((scalar){5},"pf");
  init_face_vector((vector){{6},{7}},"uf");
  event_register((Event){0,1,set_dtmax,{set_dtmax_expr0},((int *)0),((double *)0),"/root/mnt/basilisk/src/navier-stokes/centered.h",214,"set_dtmax"});
  event_register((Event){0,1,stability,{stability_expr0},((int *)0),((double *)0),"/root/mnt/basilisk/src/navier-stokes/centered.h",216,"stability"});
  event_register((Event){0,1,vof,{vof_expr0},((int *)0),((double *)0),"/root/mnt/basilisk/src/navier-stokes/centered.h",226,"vof"});
  event_register((Event){0,1,tracer_advection,{tracer_advection_expr0},((int *)0),((double *)0),"/root/mnt/basilisk/src/navier-stokes/centered.h",227,"tracer_advection"});
  event_register((Event){0,1,tracer_diffusion,{tracer_diffusion_expr0},((int *)0),((double *)0),"/root/mnt/basilisk/src/navier-stokes/centered.h",228,"tracer_diffusion"});
  event_register((Event){0,1,properties,{properties_expr0},((int *)0),((double *)0),"/root/mnt/basilisk/src/navier-stokes/centered.h",235,"properties"});
  event_register((Event){0,1,advection_term,{advection_term_expr0},((int *)0),((double *)0),"/root/mnt/basilisk/src/navier-stokes/centered.h",308,"advection_term"});
  event_register((Event){0,1,viscous_term,{viscous_term_expr0},((int *)0),((double *)0),"/root/mnt/basilisk/src/navier-stokes/centered.h",337,"viscous_term"});
  event_register((Event){0,1,acceleration,{acceleration_expr0},((int *)0),((double *)0),"/root/mnt/basilisk/src/navier-stokes/centered.h",373,"acceleration"});
  event_register((Event){0,1,projection,{projection_expr0},((int *)0),((double *)0),"/root/mnt/basilisk/src/navier-stokes/centered.h",413,"projection"});
  event_register((Event){0,1,end_timestep,{end_timestep_expr0},((int *)0),((double *)0),"/root/mnt/basilisk/src/navier-stokes/centered.h",428,"end_timestep"});
  event_register((Event){0,1,adapt,{adapt_expr0},((int *)0),((double *)0),"/root/mnt/basilisk/src/navier-stokes/centered.h",438,"adapt"});
  event_register((Event){0,1,stability_0,{stability_0_expr0},((int *)0),((double *)0),"/root/mnt/basilisk/src/vof.h",140,"stability"});
  event_register((Event){0,1,vof_0,{vof_0_expr0},((int *)0),((double *)0),"/root/mnt/basilisk/src/vof.h",364,"vof"});
  init_scalar((scalar){8},"f");
  init_face_vector((vector){{9},{10}},"alphav");
  init_scalar((scalar){11},"rhov");
  event_register((Event){0,1,tracer_advection_0,{tracer_advection_0_expr0},((int *)0),((double *)0),"/root/mnt/basilisk/src/two-phase.h",64,"tracer_advection"});
  event_register((Event){0,1,properties_0,{properties_0_expr0},((int *)0),((double *)0),"/root/mnt/basilisk/src/two-phase.h",95,"properties"});
  event_register((Event){0,1,acceleration_0,{acceleration_0_expr0},((int *)0),((double *)0),"/root/mnt/basilisk/src/iforce.h",43,"acceleration"});
  event_register((Event){0,1,stability_1,{stability_1_expr0},((int *)0),((double *)0),"/root/mnt/basilisk/src/tension.h",36,"stability"});
  event_register((Event){0,1,acceleration_1,{acceleration_1_expr0},((int *)0),((double *)0),"/root/mnt/basilisk/src/tension.h",72,"acceleration"});
  event_register((Event){0,1,acceleration_2,{acceleration_2_expr0},((int *)0),((double *)0),"rising.c",104,"acceleration"});
# 13 "ast/init_solver.h"
} _attribute[p.i].dirty=1,_attribute[p.i].boundary[right]=_boundary0,_attribute[p.i].boundary_homogeneous[right]=_boundary0_homogeneous;
  _attribute[p.i].dirty=1,_attribute[p.i].boundary[left]=_boundary1,_attribute[p.i].boundary_homogeneous[left]=_boundary1_homogeneous;
  _attribute[p.i].dirty=1,_attribute[p.i].boundary[top]=_boundary2,_attribute[p.i].boundary_homogeneous[top]=_boundary2_homogeneous;
  _attribute[p.i].dirty=1,_attribute[p.i].boundary[bottom]=_boundary3,_attribute[p.i].boundary_homogeneous[bottom]=_boundary3_homogeneous;
  _attribute[u.y.i].dirty=1,_attribute[u.y.i].boundary[right]=_boundary4,_attribute[u.y.i].boundary_homogeneous[right]=_boundary4_homogeneous;
  _attribute[u.y.i].dirty=1,_attribute[u.y.i].boundary[left]=_boundary5,_attribute[u.y.i].boundary_homogeneous[left]=_boundary5_homogeneous;
  _attribute[uf.x.i].dirty=1,_attribute[uf.x.i].boundary[bottom]=_boundary6,_attribute[uf.x.i].boundary_homogeneous[bottom]=_boundary6;
  _attribute[uf.x.i].dirty=1,_attribute[uf.x.i].boundary[top]=_boundary7,_attribute[uf.x.i].boundary_homogeneous[top]=_boundary7;
# 14 "ast/init_solver.h"
set_fpe();
}
